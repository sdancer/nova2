module 'Nova.Prelude' ['bottom'/0, 'otherwise'/0, 'top'/0, 'unit'/0, 'fst'/1, 'identity'/1, 'isJust'/1, 'isLeft'/1, 'isNothing'/1, 'isRight'/1, 'length'/1, 'not'/1, 'show'/1, 'showInt'/1, 'showNumber'/1, 'snd'/1, 'unsafeCoerce'/1, 'unsafeCrashWith'/1, 'void'/1, 'append'/2, 'apply'/2, 'applyFlipped'/2, 'concatStrings'/2, 'conj'/2, 'const'/2, 'disj'/2, 'filter'/2, 'fromMaybe'/2, 'map'/2, 'semigroupAppend'/2, 'compose'/3, 'either'/3, 'flip'/3, 'foldl'/3, 'foldr'/3, 'maybe'/3, 'showImpl'/1, 'showIntImpl'/1, 'showNumberImpl'/1, 'negate'/1, 'mapImpl'/2, 'filterImpl'/2, 'lengthImpl'/1, 'appendImpl'/2, 'foldlImpl'/3, 'foldrImpl'/3, 'unsafeCrashWithImpl'/1, 'unsafeCoerceImpl'/1, 'topImpl'/0, 'bottomImpl'/0, 'concatStringsImpl'/2, 'semigroupAppendImpl'/2, 'Nothing'/0, 'Just'/1, 'Left'/1, 'Right'/1, 'Unit'/0, 'Tuple'/2, 'fst'/0, 'identity'/0, 'isJust'/0, 'isLeft'/0, 'isNothing'/0, 'isRight'/0, 'length'/0, 'not'/0, 'show'/0, 'showInt'/0, 'showNumber'/0, 'snd'/0, 'unsafeCoerce'/0, 'unsafeCrashWith'/0, 'void'/0, 'append'/0, 'append'/1, 'apply'/0, 'apply'/1, 'applyFlipped'/0, 'applyFlipped'/1, 'concatStrings'/0, 'concatStrings'/1, 'conj'/0, 'conj'/1, 'const'/0, 'const'/1, 'disj'/0, 'disj'/1, 'filter'/0, 'filter'/1, 'fromMaybe'/0, 'fromMaybe'/1, 'map'/0, 'map'/1, 'semigroupAppend'/0, 'semigroupAppend'/1, 'compose'/0, 'compose'/1, 'compose'/2, 'either'/0, 'either'/1, 'either'/2, 'flip'/0, 'flip'/1, 'flip'/2, 'foldl'/0, 'foldl'/1, 'foldl'/2, 'foldr'/0, 'foldr'/1, 'foldr'/2, 'maybe'/0, 'maybe'/1, 'maybe'/2, 'showImpl'/0, 'showIntImpl'/0, 'showNumberImpl'/0, 'negate'/0, 'mapImpl'/0, 'mapImpl'/1, 'filterImpl'/0, 'filterImpl'/1, 'lengthImpl'/0, 'appendImpl'/0, 'appendImpl'/1, 'foldlImpl'/0, 'foldlImpl'/1, 'foldlImpl'/2, 'foldrImpl'/0, 'foldrImpl'/1, 'foldrImpl'/2, 'unsafeCrashWithImpl'/0, 'unsafeCoerceImpl'/0, 'concatStringsImpl'/0, 'concatStringsImpl'/1, 'semigroupAppendImpl'/0, 'semigroupAppendImpl'/1, 'Just'/0, 'Left'/0, 'Right'/0, 'Tuple'/0, 'Tuple'/1, 'module_info'/0, 'module_info'/1]
  attributes []
% Data type: Maybe
% Constructors: Nothing, Just

'Nothing'/0 =
  fun () ->
    'Nothing'

'Just'/1 =
  fun (V0) ->
    {'Just', V0}

% Data type: Either
% Constructors: Left, Right

'Left'/1 =
  fun (V0) ->
    {'Left', V0}

'Right'/1 =
  fun (V0) ->
    {'Right', V0}

% Data type: Unit
% Constructors: Unit

'Unit'/0 =
  fun () ->
    'Unit'

% Data type: Tuple
% Constructors: Tuple

'Tuple'/2 =
  fun (V0, V1) ->
    {'Tuple', V0, V1}

'bottom'/0 =
  fun () ->
    apply 'bottomImpl'/0()

'otherwise'/0 =
  fun () ->
    'true'

'top'/0 =
  fun () ->
    apply 'topImpl'/0()

'unit'/0 =
  fun () ->
    apply 'Unit'/0()

'fst'/1 =
  fun (_P0) ->
    case {_P0} of
      <{{'Tuple', A, _W0}}> when 'true' ->
        A
    end

'identity'/1 =
  fun (X) ->
    X

'isJust'/1 =
  fun (_P0) ->
    case {_P0} of
      <{{'Just', _W0}}> when 'true' ->
        'true'
      <{'Nothing'}> when 'true' ->
        'false'
    end

'isLeft'/1 =
  fun (_P0) ->
    case {_P0} of
      <{{'Left', _W0}}> when 'true' ->
        'true'
      <{{'Right', _W0}}> when 'true' ->
        'false'
    end

'isNothing'/1 =
  fun (_P0) ->
    case {_P0} of
      <{'Nothing'}> when 'true' ->
        'true'
      <{{'Just', _W0}}> when 'true' ->
        'false'
    end

'isRight'/1 =
  fun (_P0) ->
    case {_P0} of
      <{{'Right', _W0}}> when 'true' ->
        'true'
      <{{'Left', _W0}}> when 'true' ->
        'false'
    end

'length'/1 =
  fun (Xs) ->
    apply 'lengthImpl'/1(Xs)

'not'/1 =
  fun (_P0) ->
    case {_P0} of
      <{'true'}> when 'true' ->
        'false'
      <{'false'}> when 'true' ->
        'true'
    end

'show'/1 =
  fun (X) ->
    apply 'showImpl'/1(X)

'showInt'/1 =
  fun (N) ->
    apply 'showIntImpl'/1(N)

'showNumber'/1 =
  fun (N) ->
    apply 'showNumberImpl'/1(N)

'snd'/1 =
  fun (_P0) ->
    case {_P0} of
      <{{'Tuple', _W0, B}}> when 'true' ->
        B
    end

'unsafeCoerce'/1 =
  fun (X) ->
    apply 'unsafeCoerceImpl'/1(X)

'unsafeCrashWith'/1 =
  fun (Msg) ->
    apply 'unsafeCrashWithImpl'/1(Msg)

'void'/1 =
  fun (_W0) ->
    apply 'Unit'/0()

'append'/2 =
  fun (Xs, Ys) ->
    apply 'appendImpl'/2(Xs, Ys)

'apply'/2 =
  fun (F, X) ->
    apply F(X)

'applyFlipped'/2 =
  fun (X, F) ->
    apply F(X)

'concatStrings'/2 =
  fun (A, B) ->
    apply 'concatStringsImpl'/2(A, B)

'conj'/2 =
  fun (_P0, _P1) ->
    case {_P0, _P1} of
      <{'true', 'true'}> when 'true' ->
        'true'
      <{_W0, _W1}> when 'true' ->
        'false'
    end

'const'/2 =
  fun (X, _W0) ->
    X

'disj'/2 =
  fun (_P0, _P1) ->
    case {_P0, _P1} of
      <{'false', 'false'}> when 'true' ->
        'false'
      <{_W0, _W1}> when 'true' ->
        'true'
    end

'filter'/2 =
  fun (F, Xs) ->
    apply 'filterImpl'/2(F, Xs)

'fromMaybe'/2 =
  fun (_P0, _P1) ->
    case {_P0, _P1} of
      <{Def, 'Nothing'}> when 'true' ->
        Def
      <{_W0, {'Just', X}}> when 'true' ->
        X
    end

'map'/2 =
  fun (F, Xs) ->
    apply 'mapImpl'/2(F, Xs)

'semigroupAppend'/2 =
  fun (X, Y) ->
    apply 'semigroupAppendImpl'/2(X, Y)

'compose'/3 =
  fun (F, G, X) ->
    apply F(apply G(X))

'either'/3 =
  fun (_P0, _P1, _P2) ->
    case {_P0, _P1, _P2} of
      <{F, _W0, {'Left', A}}> when 'true' ->
        apply F(A)
      <{_W0, G, {'Right', B}}> when 'true' ->
        apply G(B)
    end

'flip'/3 =
  fun (F, B, A) ->
    apply F(A, B)

'foldl'/3 =
  fun (F, Acc, Xs) ->
    apply 'foldlImpl'/3(F, Acc, Xs)

'foldr'/3 =
  fun (F, Acc, Xs) ->
    apply 'foldrImpl'/3(F, Acc, Xs)

'maybe'/3 =
  fun (_P0, _P1, _P2) ->
    case {_P0, _P1, _P2} of
      <{Def, _W0, 'Nothing'}> when 'true' ->
        Def
      <{_W0, F, {'Just', X}}> when 'true' ->
        apply F(X)
    end

'showImpl'/1 = fun (V0) -> call 'erlang':'iolist_to_binary'(call 'io_lib':'format'([126,112], [V0]))

'showIntImpl'/1 = fun (V0) -> call 'erlang':'integer_to_binary'(V0)

'showNumberImpl'/1 = fun (V0) -> call 'erlang':'iolist_to_binary'(call 'io_lib':'format'([126,112], [V0]))

'negate'/1 = fun (V0) -> call 'erlang':'-'(V0)

'mapImpl'/2 = fun (V0, V1) -> call 'lists':'map'(fun (X) -> apply V0 (X), V1)

'filterImpl'/2 = fun (V0, V1) -> call 'lists':'filter'(fun (X) -> apply V0 (X), V1)

'lengthImpl'/1 = fun (V0) -> call 'erlang':'length'(V0)

'appendImpl'/2 = fun (V0, V1) -> call 'erlang':'++'(V0, V1)

'foldlImpl'/3 = fun (V0, V1, V2) -> call 'lists':'foldl'(fun (E, A) -> apply V0 (A, E), V1, V2)

'foldrImpl'/3 = fun (V0, V1, V2) -> call 'lists':'foldr'(fun (E, A) -> apply V0 (E, A), V1, V2)

'unsafeCrashWithImpl'/1 = fun (V0) -> call 'erlang':'error'(V0)

'unsafeCoerceImpl'/1 = fun (V0) -> V0

'topImpl'/0 = fun () -> 9223372036854775807

'bottomImpl'/0 = fun () -> -9223372036854775808

'concatStringsImpl'/2 = fun (V0, V1) -> call 'erlang':'iolist_to_binary'([V0, V1])

'semigroupAppendImpl'/2 = fun (V0, V1) -> case call 'erlang':'is_binary'(V0) of <'true'> when 'true' -> call 'erlang':'iolist_to_binary'([V0, V1]) <'false'> when 'true' -> call 'erlang':'++'(V0, V1) end

'fst'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'fst'/1(_A0)
      in _F0

'identity'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'identity'/1(_A0)
      in _F0

'isJust'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'isJust'/1(_A0)
      in _F0

'isLeft'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'isLeft'/1(_A0)
      in _F0

'isNothing'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'isNothing'/1(_A0)
      in _F0

'isRight'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'isRight'/1(_A0)
      in _F0

'length'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'length'/1(_A0)
      in _F0

'not'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'not'/1(_A0)
      in _F0

'show'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'show'/1(_A0)
      in _F0

'showInt'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'showInt'/1(_A0)
      in _F0

'showNumber'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'showNumber'/1(_A0)
      in _F0

'snd'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'snd'/1(_A0)
      in _F0

'unsafeCoerce'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'unsafeCoerce'/1(_A0)
      in _F0

'unsafeCrashWith'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'unsafeCrashWith'/1(_A0)
      in _F0

'void'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'void'/1(_A0)
      in _F0

'append'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'append'/2(_A0, _A1)
      in _F1
      in _F0

'append'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'append'/2(_A0, _A1)
      in _F0

'apply'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'apply'/2(_A0, _A1)
      in _F1
      in _F0

'apply'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'apply'/2(_A0, _A1)
      in _F0

'applyFlipped'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'applyFlipped'/2(_A0, _A1)
      in _F1
      in _F0

'applyFlipped'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'applyFlipped'/2(_A0, _A1)
      in _F0

'concatStrings'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'concatStrings'/2(_A0, _A1)
      in _F1
      in _F0

'concatStrings'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'concatStrings'/2(_A0, _A1)
      in _F0

'conj'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'conj'/2(_A0, _A1)
      in _F1
      in _F0

'conj'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'conj'/2(_A0, _A1)
      in _F0

'const'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'const'/2(_A0, _A1)
      in _F1
      in _F0

'const'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'const'/2(_A0, _A1)
      in _F0

'disj'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'disj'/2(_A0, _A1)
      in _F1
      in _F0

'disj'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'disj'/2(_A0, _A1)
      in _F0

'filter'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'filter'/2(_A0, _A1)
      in _F1
      in _F0

'filter'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'filter'/2(_A0, _A1)
      in _F0

'fromMaybe'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'fromMaybe'/2(_A0, _A1)
      in _F1
      in _F0

'fromMaybe'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'fromMaybe'/2(_A0, _A1)
      in _F0

'map'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'map'/2(_A0, _A1)
      in _F1
      in _F0

'map'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'map'/2(_A0, _A1)
      in _F0

'semigroupAppend'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'semigroupAppend'/2(_A0, _A1)
      in _F1
      in _F0

'semigroupAppend'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'semigroupAppend'/2(_A0, _A1)
      in _F0

'compose'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'compose'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'compose'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'compose'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'compose'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'compose'/3(_A0, _A1, _A2)
      in _F0

'either'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'either'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'either'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'either'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'either'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'either'/3(_A0, _A1, _A2)
      in _F0

'flip'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'flip'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'flip'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'flip'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'flip'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'flip'/3(_A0, _A1, _A2)
      in _F0

'foldl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'foldl'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'foldl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'foldl'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'foldl'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'foldl'/3(_A0, _A1, _A2)
      in _F0

'foldr'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'foldr'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'foldr'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'foldr'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'foldr'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'foldr'/3(_A0, _A1, _A2)
      in _F0

'maybe'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'maybe'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'maybe'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'maybe'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'maybe'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'maybe'/3(_A0, _A1, _A2)
      in _F0

'showImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'showImpl'/1(_A0)
      in _F0

'showIntImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'showIntImpl'/1(_A0)
      in _F0

'showNumberImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'showNumberImpl'/1(_A0)
      in _F0

'negate'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'negate'/1(_A0)
      in _F0

'mapImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'mapImpl'/2(_A0, _A1)
      in _F1
      in _F0

'mapImpl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'mapImpl'/2(_A0, _A1)
      in _F0

'filterImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'filterImpl'/2(_A0, _A1)
      in _F1
      in _F0

'filterImpl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'filterImpl'/2(_A0, _A1)
      in _F0

'lengthImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'lengthImpl'/1(_A0)
      in _F0

'appendImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'appendImpl'/2(_A0, _A1)
      in _F1
      in _F0

'appendImpl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'appendImpl'/2(_A0, _A1)
      in _F0

'foldlImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'foldlImpl'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'foldlImpl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'foldlImpl'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'foldlImpl'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'foldlImpl'/3(_A0, _A1, _A2)
      in _F0

'foldrImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'foldrImpl'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'foldrImpl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'foldrImpl'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'foldrImpl'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'foldrImpl'/3(_A0, _A1, _A2)
      in _F0

'unsafeCrashWithImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'unsafeCrashWithImpl'/1(_A0)
      in _F0

'unsafeCoerceImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'unsafeCoerceImpl'/1(_A0)
      in _F0

'concatStringsImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'concatStringsImpl'/2(_A0, _A1)
      in _F1
      in _F0

'concatStringsImpl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'concatStringsImpl'/2(_A0, _A1)
      in _F0

'semigroupAppendImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'semigroupAppendImpl'/2(_A0, _A1)
      in _F1
      in _F0

'semigroupAppendImpl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'semigroupAppendImpl'/2(_A0, _A1)
      in _F0

'Just'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'Just'/1(_A0)
      in _F0

'Left'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'Left'/1(_A0)
      in _F0

'Right'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'Right'/1(_A0)
      in _F0

'Tuple'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'Tuple'/2(_A0, _A1)
      in _F1
      in _F0

'Tuple'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'Tuple'/2(_A0, _A1)
      in _F0

'module_info'/0 = fun () -> call 'erlang':'get_module_info'('Nova.Prelude')

'module_info'/1 = fun (_0) -> call 'erlang':'get_module_info'('Nova.Prelude', _0)
end
