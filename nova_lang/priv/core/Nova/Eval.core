module 'Nova.Eval' ['compileAndLoad'/0, 'newContext'/0, 'parseSource'/0, 'compileToCore'/1, 'eval'/1, 'evalDecls'/1, 'evalExpr'/1, 'findLastDeclName'/1, 'genModuleName'/1, 'ieval'/1, 'callFunction'/2, 'evalModule'/2, 'evalSnippet'/2, 'intToString'/1, 'parseSourceImpl'/1, 'compileAndLoadImpl'/1, 'callFunctionImpl'/2, 'findLastDeclNameImpl'/1, 'compileToCore'/0, 'eval'/0, 'evalDecls'/0, 'evalExpr'/0, 'findLastDeclName'/0, 'genModuleName'/0, 'ieval'/0, 'callFunction'/0, 'callFunction'/1, 'evalModule'/0, 'evalModule'/1, 'evalSnippet'/0, 'evalSnippet'/1, 'intToString'/0, 'parseSourceImpl'/0, 'compileAndLoadImpl'/0, 'callFunctionImpl'/0, 'callFunctionImpl'/1, 'findLastDeclNameImpl'/0, 'module_info'/0, 'module_info'/1]
  attributes []
'compileAndLoad'/0 =
  fun () ->
    fun (_Mf0) -> apply 'compileAndLoadImpl'/1(_Mf0)

'newContext'/0 =
  fun () ->
    ~{'counter'=>0,'modules'=>[]}~

'parseSource'/0 =
  fun () ->
    fun (_Mf0) -> apply 'parseSourceImpl'/1(_Mf0)

'compileToCore'/1 =
  fun (Source) ->
    let <ModName> = #{#<78>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<118>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<46>(8,1,'integer',['unsigned'|['big']]),#<69>(8,1,'integer',['unsigned'|['big']]),#<118>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<108>(8,1,'integer',['unsigned'|['big']]),#<46>(8,1,'integer',['unsigned'|['big']]),#<68>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<98>(8,1,'integer',['unsigned'|['big']]),#<117>(8,1,'integer',['unsigned'|['big']]),#<103>(8,1,'integer',['unsigned'|['big']])}#
      in let <ModuleSource> = call 'Nova.Prelude':'semigroupAppendImpl'(call 'Nova.Prelude':'semigroupAppendImpl'(call 'Nova.Prelude':'semigroupAppendImpl'(call 'Nova.Prelude':'semigroupAppendImpl'(#{#<109>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<117>(8,1,'integer',['unsigned'|['big']]),#<108>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']])}#, ModName), #{#<32>(8,1,'integer',['unsigned'|['big']]),#<119>(8,1,'integer',['unsigned'|['big']]),#<104>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<10>(8,1,'integer',['unsigned'|['big']]),#<10>(8,1,'integer',['unsigned'|['big']])}#), Source), #{#<10>(8,1,'integer',['unsigned'|['big']])}#)
      in let <_Fn0> = apply 'parseSource'/0()
      in apply _Fn0(ModuleSource)

'eval'/1 =
  fun (Source) ->
    apply 'evalExpr'/1(Source)

'evalDecls'/1 =
  fun (Source) ->
    let <EntryPoint> = apply 'findLastDeclName'/1(Source)
      in apply 'evalSnippet'/2(Source, EntryPoint)

'evalExpr'/1 =
  fun (Source) ->
    let <ModName> = #{#<78>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<118>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<46>(8,1,'integer',['unsigned'|['big']]),#<69>(8,1,'integer',['unsigned'|['big']]),#<118>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<108>(8,1,'integer',['unsigned'|['big']]),#<46>(8,1,'integer',['unsigned'|['big']]),#<69>(8,1,'integer',['unsigned'|['big']]),#<120>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']])}#
      in let <ModuleSource> = call 'Nova.Prelude':'semigroupAppendImpl'(call 'Nova.Prelude':'semigroupAppendImpl'(call 'Nova.Prelude':'semigroupAppendImpl'(call 'Nova.Prelude':'semigroupAppendImpl'(#{#<109>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<117>(8,1,'integer',['unsigned'|['big']]),#<108>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']])}#, ModName), #{#<32>(8,1,'integer',['unsigned'|['big']]),#<119>(8,1,'integer',['unsigned'|['big']]),#<104>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<10>(8,1,'integer',['unsigned'|['big']]),#<10>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<117>(8,1,'integer',['unsigned'|['big']]),#<108>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<61>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']])}#), Source), #{#<10>(8,1,'integer',['unsigned'|['big']])}#)
      in apply 'evalModule'/2(ModuleSource, #{#<114>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<117>(8,1,'integer',['unsigned'|['big']]),#<108>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']])}#)

'findLastDeclName'/1 =
  fun (Source) ->
    apply 'findLastDeclNameImpl'/1(Source)

'genModuleName'/1 =
  fun (Ctx) ->
    let <Name> = call 'Nova.Prelude':'semigroupAppendImpl'(#{#<78>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<118>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<46>(8,1,'integer',['unsigned'|['big']]),#<69>(8,1,'integer',['unsigned'|['big']]),#<118>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<108>(8,1,'integer',['unsigned'|['big']]),#<46>(8,1,'integer',['unsigned'|['big']]),#<77>(8,1,'integer',['unsigned'|['big']])}#, apply 'intToString'/1(call 'maps':'get'('counter', Ctx)))
      in let <NewCtx> = call 'maps':'merge'(Ctx, ~{'counter'=>call 'erlang':'+'(call 'maps':'get'('counter', Ctx), 1)}~)
      in ~{'name'=>Name,'ctx'=>NewCtx}~

'ieval'/1 =
  fun (Source) ->
    case apply 'eval'/1(Source) of
      <{'Left', Err}> when 'true' ->
        call 'Nova.Prelude':'semigroupAppendImpl'(#{#<69>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<58>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']])}#, Err)
      <{'Right', Result}> when 'true' ->
        Result
    end

'callFunction'/2 =
  fun (ModName, FuncName) ->
    apply 'callFunctionImpl'/2(ModName, FuncName)

'evalModule'/2 =
  fun (Source, EntryPoint) ->
    case let <_Fn0> = apply 'parseSource'/0()
      in apply _Fn0(Source) of
      <{'Left', Err}> when 'true' ->
        {'Left', call 'Nova.Prelude':'semigroupAppendImpl'(#{#<80>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<58>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']])}#, Err)}
      <{'Right', CoreErlang}> when 'true' ->
        case let <_Fn0> = apply 'compileAndLoad'/0()
      in apply _Fn0(CoreErlang) of
      <{'Left', Err}> when 'true' ->
        {'Left', call 'Nova.Prelude':'semigroupAppendImpl'(#{#<67>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<109>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<108>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<58>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']])}#, Err)}
      <{'Right', ModAtom}> when 'true' ->
        case apply 'callFunction'/2(ModAtom, EntryPoint) of
      <{'Left', Err}> when 'true' ->
        {'Left', call 'Nova.Prelude':'semigroupAppendImpl'(#{#<82>(8,1,'integer',['unsigned'|['big']]),#<117>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<109>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<58>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']])}#, Err)}
      <{'Right', Result}> when 'true' ->
        {'Right', Result}
    end
    end
    end

'evalSnippet'/2 =
  fun (Source, EntryPoint) ->
    let <ModName> = #{#<78>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<118>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<46>(8,1,'integer',['unsigned'|['big']]),#<69>(8,1,'integer',['unsigned'|['big']]),#<118>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<108>(8,1,'integer',['unsigned'|['big']]),#<46>(8,1,'integer',['unsigned'|['big']]),#<83>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']])}#
      in let <ModuleSource> = call 'Nova.Prelude':'semigroupAppendImpl'(call 'Nova.Prelude':'semigroupAppendImpl'(call 'Nova.Prelude':'semigroupAppendImpl'(call 'Nova.Prelude':'semigroupAppendImpl'(#{#<109>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<117>(8,1,'integer',['unsigned'|['big']]),#<108>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']])}#, ModName), #{#<32>(8,1,'integer',['unsigned'|['big']]),#<119>(8,1,'integer',['unsigned'|['big']]),#<104>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<10>(8,1,'integer',['unsigned'|['big']]),#<10>(8,1,'integer',['unsigned'|['big']])}#), Source), #{#<10>(8,1,'integer',['unsigned'|['big']])}#)
      in apply 'evalModule'/2(ModuleSource, EntryPoint)

'intToString'/1 = fun (V0) -> call 'erlang':'integer_to_list'(V0)

'parseSourceImpl'/1 = fun (V0) -> case catch call 'Nova.Compiler.CstPipeline':'parseModuleCst'(V0) of <{'Left', Err}> when 'true' -> {'Left', Err} <{'Right', Ast}> when 'true' -> {'Right', call 'Nova.Compiler.CodeGenCoreErlang':'genModule'(Ast)} <{'EXIT', {Reason, _}}> when 'true' -> {'Left', call 'erlang':'++'([101,120,99,101,112,116,105,111,110,58,32], call 'erlang':'atom_to_list'(Reason))} <Other> when 'true' -> {'Left', [117,110,107,110,111,119,110,32,101,114,114,111,114]} end

'compileAndLoadImpl'/1 = fun (V0) -> let <CoreBin> = call 'erlang':'list_to_binary'(V0) in case call 'core_scan':'string'(call 'erlang':'binary_to_list'(CoreBin)) of <{'ok', Tokens, _}> when 'true' -> case call 'core_parse':'parse'(Tokens) of <{'ok', CoreAst}> when 'true' -> case call 'compile':'forms'(CoreAst, ['from_core', 'binary']) of <{'ok', ModAtom, Beam}> when 'true' -> let <_> = call 'code':'load_binary'(ModAtom, [], Beam) in {'Right', call 'erlang':'atom_to_list'(ModAtom)} <{'error', Errs, _}> when 'true' -> {'Left', [99,111,109,112,105,108,101,32,101,114,114,111,114]} end <{'error', ParseErr}> when 'true' -> {'Left', call 'erlang':'++'([112,97,114,115,101,32,101,114,114,111,114,58,32], call 'lists':'flatten'(call 'io_lib':'format'([126,112], [ParseErr])))} end <{'error', ScanErr, _}> when 'true' -> {'Left', call 'erlang':'++'([115,99,97,110,32,101,114,114,111,114,58,32], call 'lists':'flatten'(call 'io_lib':'format'([126,112], [ScanErr])))} end

'callFunctionImpl'/2 = fun (V0, V1) -> let <Mod> = call 'erlang':'binary_to_atom'(V0) in let <Func> = call 'erlang':'binary_to_atom'(V1) in case catch call Mod:Func() of <{'EXIT', {Reason, _}}> when 'true' -> {'Left', call 'erlang':'iolist_to_binary'(call 'io_lib':'format'([126,112], [Reason]))} <Result> when 'true' -> {'Right', call 'erlang':'iolist_to_binary'(call 'io_lib':'format'([126,112], [Result]))} end

'findLastDeclNameImpl'/1 = fun (V0) -> let <Lines> = call 'string':'split'(V0, [10], 'all') in let <Decls> = call 'lists':'filter'(fun (L) -> case call 'string':'trim'(L) of <[]> when 'true' -> 'false' <_> when 'true' -> case call 'string':'prefix'(L, [45,45]) of <'nomatch'> when 'true' -> 'true' <_> when 'true' -> 'false' end end, Lines) in case Decls of <[]> when 'true' -> [114,101,115,117,108,116] <_> when 'true' -> let <Last> = call 'lists':'last'(Decls) in let <Trimmed> = call 'string':'trim'(Last) in case call 'string':'split'(Trimmed, [32], 'leading') of <[Name|_]> when 'true' -> Name <[]> when 'true' -> [114,101,115,117,108,116] end end

'compileToCore'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'compileToCore'/1(_A0)
      in _F0

'eval'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'eval'/1(_A0)
      in _F0

'evalDecls'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'evalDecls'/1(_A0)
      in _F0

'evalExpr'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'evalExpr'/1(_A0)
      in _F0

'findLastDeclName'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'findLastDeclName'/1(_A0)
      in _F0

'genModuleName'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'genModuleName'/1(_A0)
      in _F0

'ieval'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'ieval'/1(_A0)
      in _F0

'callFunction'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'callFunction'/2(_A0, _A1)
      in _F1
      in _F0

'callFunction'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'callFunction'/2(_A0, _A1)
      in _F0

'evalModule'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'evalModule'/2(_A0, _A1)
      in _F1
      in _F0

'evalModule'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'evalModule'/2(_A0, _A1)
      in _F0

'evalSnippet'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'evalSnippet'/2(_A0, _A1)
      in _F1
      in _F0

'evalSnippet'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'evalSnippet'/2(_A0, _A1)
      in _F0

'intToString'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'intToString'/1(_A0)
      in _F0

'parseSourceImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'parseSourceImpl'/1(_A0)
      in _F0

'compileAndLoadImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'compileAndLoadImpl'/1(_A0)
      in _F0

'callFunctionImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'callFunctionImpl'/2(_A0, _A1)
      in _F1
      in _F0

'callFunctionImpl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'callFunctionImpl'/2(_A0, _A1)
      in _F0

'findLastDeclNameImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'findLastDeclNameImpl'/1(_A0)
      in _F0

'module_info'/0 = fun () -> call 'erlang':'get_module_info'('Nova.Eval')

'module_info'/1 = fun (_0) -> call 'erlang':'get_module_info'('Nova.Eval', _0)
end
