module 'Nova.Compiler.CstToAst' ['unwrapIdent'/1, 'unwrapProper'/1, 'unwrapLabel'/1, 'unwrapOperator'/1, 'unwrapModuleName'/1, 'qualifiedProperName'/1, 'extractTypeVar'/1, 'intValueToInt'/1, 'snd'/1, 'traverse'/2, 'listMapWithIndex'/2, 'isUnderscore'/1, 'operatorPrecedence'/1, 'operatorIsRightAssoc'/1, 'convertModule'/1, 'convertImportDecl'/1, 'convertImportItems'/1, 'convertImportItem'/1, 'convertDataMembers'/1, 'convertDeclarations'/1, 'convertDeclaration'/1, 'convertDataType'/2, 'convertDataCtors'/1, 'convertDataCtor'/1, 'convertTypeToField'/1, 'convertTypeAlias'/2, 'convertNewtype'/3, 'convertTypeClass'/2, 'convertMethodSig'/1, 'convertInstance'/1, 'convertInstanceBinding'/1, 'convertDeriveInstance'/1, 'convertFunction'/1, 'convertValueBinding'/1, 'convertWhereExpr'/1, 'convertLetBindings'/1, 'convertWhereBindings'/1, 'convertGuardedExpr'/1, 'convertPatternGuards'/1, 'convertPatternGuard'/1, 'convertTypeSignature'/1, 'extractConstraints'/1, 'convertConstraintType'/1, 'convertFixity'/1, 'convertForeign'/1, 'convertType'/1, 'foldTypeOps'/2, 'convertRow'/1, 'convertRowLabels'/1, 'convertRowLabel'/1, 'convertExpr'/1, 'foldBinOps'/2, 'convertOpList'/1, 'shuntingYard'/2, 'makeBinOpOrSection'/3, 'foldInfixOps'/2, 'convertRecordField'/1, 'convertRecordUpdate'/1, 'convertCaseBranch'/1, 'convertLetBinding'/1, 'convertDoStatement'/1, 'convertBinder'/1, 'foldBinderOps'/2, 'convertRecordBinder'/1, 'unwrapIdent'/0, 'unwrapProper'/0, 'unwrapLabel'/0, 'unwrapOperator'/0, 'unwrapModuleName'/0, 'qualifiedProperName'/0, 'extractTypeVar'/0, 'intValueToInt'/0, 'snd'/0, 'traverse'/0, 'traverse'/1, 'listMapWithIndex'/0, 'listMapWithIndex'/1, 'isUnderscore'/0, 'operatorPrecedence'/0, 'operatorIsRightAssoc'/0, 'convertModule'/0, 'convertImportDecl'/0, 'convertImportItems'/0, 'convertImportItem'/0, 'convertDataMembers'/0, 'convertDeclarations'/0, 'convertDeclaration'/0, 'convertDataType'/0, 'convertDataType'/1, 'convertDataCtors'/0, 'convertDataCtor'/0, 'convertTypeToField'/0, 'convertTypeAlias'/0, 'convertTypeAlias'/1, 'convertNewtype'/0, 'convertNewtype'/1, 'convertNewtype'/2, 'convertTypeClass'/0, 'convertTypeClass'/1, 'convertMethodSig'/0, 'convertInstance'/0, 'convertInstanceBinding'/0, 'convertDeriveInstance'/0, 'convertFunction'/0, 'convertValueBinding'/0, 'convertWhereExpr'/0, 'convertLetBindings'/0, 'convertWhereBindings'/0, 'convertGuardedExpr'/0, 'convertPatternGuards'/0, 'convertPatternGuard'/0, 'convertTypeSignature'/0, 'extractConstraints'/0, 'convertConstraintType'/0, 'convertFixity'/0, 'convertForeign'/0, 'convertType'/0, 'foldTypeOps'/0, 'foldTypeOps'/1, 'convertRow'/0, 'convertRowLabels'/0, 'convertRowLabel'/0, 'convertExpr'/0, 'foldBinOps'/0, 'foldBinOps'/1, 'convertOpList'/0, 'shuntingYard'/0, 'shuntingYard'/1, 'makeBinOpOrSection'/0, 'makeBinOpOrSection'/1, 'makeBinOpOrSection'/2, 'foldInfixOps'/0, 'foldInfixOps'/1, 'convertRecordField'/0, 'convertRecordUpdate'/0, 'convertCaseBranch'/0, 'convertLetBinding'/0, 'convertDoStatement'/0, 'convertBinder'/0, 'foldBinderOps'/0, 'foldBinderOps'/1, 'convertRecordBinder'/0]
  attributes []
'unwrapIdent'/1 =
  fun (_P0) ->
    case {_P0} of
      <{{'Ident', S}}> when 'true' ->
        S
    end

'unwrapProper'/1 =
  fun (_P0) ->
    case {_P0} of
      <{{'Proper', S}}> when 'true' ->
        S
    end

'unwrapLabel'/1 =
  fun (_P0) ->
    case {_P0} of
      <{{'Label', S}}> when 'true' ->
        S
    end

'unwrapOperator'/1 =
  fun (_P0) ->
    case {_P0} of
      <{{'Operator', S}}> when 'true' ->
        S
    end

'unwrapModuleName'/1 =
  fun (_P0) ->
    case {_P0} of
      <{{'ModuleName', S}}> when 'true' ->
        S
    end

'qualifiedProperName'/1 =
  fun (Qn) ->
    case call 'maps':'get'('module', Qn) of
      <'Nothing'> when 'true' ->
        apply 'unwrapProper'/1(call 'maps':'get'('name', Qn))
      <{'Just', ModName}> when 'true' ->
        call 'Nova.Prelude':'semigroupAppendImpl'(call 'Nova.Prelude':'semigroupAppendImpl'(apply 'unwrapModuleName'/1(ModName), #{#<46>(8,1,'integer',['unsigned'|['big']])}#), apply 'unwrapProper'/1(call 'maps':'get'('name', Qn)))
    end

'extractTypeVar'/1 =
  fun (_P0) ->
    case {_P0} of
      <{{'TypeVarKinded', Wrapped}}> when 'true' ->
        apply 'unwrapIdent'/1(call 'maps':'get'('name', call 'maps':'get'('label', call 'maps':'get'('value', Wrapped))))
      <{{'TypeVarName', Name}}> when 'true' ->
        apply 'unwrapIdent'/1(call 'maps':'get'('name', Name))
    end

'intValueToInt'/1 =
  fun (_P0) ->
    case {_P0} of
      <{{'SmallInt', N}}> when 'true' ->
        N
      <{{'BigInt', _W0}}> when 'true' ->
        0
    end

'snd'/1 =
  fun (_P0) ->
    case {_P0} of
      <{{'Tuple', _W0, B}}> when 'true' ->
        B
    end

'traverse'/2 =
  fun (F, Lst) ->
    case Lst of
      <[]> when 'true' ->
        {'Right', []}
      <[Head | Tail]> when 'true' ->
        case apply F(Head) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', H}> when 'true' ->
        case apply 'traverse'/2(F, Tail) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', T}> when 'true' ->
        {'Right', [H | T]}
      <{'Right', T}> when 'true' ->
        {'Right', [H | T]}
      end
      <{'Right', H}> when 'true' ->
        case apply 'traverse'/2(F, Tail) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', T}> when 'true' ->
        {'Right', [H | T]}
      <{'Right', T}> when 'true' ->
        {'Right', [H | T]}
      end
      end
    end

'listMapWithIndex'/2 =
  fun (F, List) ->
    letrec 'go'/2 = fun (_L0, _L1) ->
      case {_L0, _L1} of
        <{_W0, []}> when 'true' -> []
        <{I, [X | Xs]}> when 'true' -> [apply F(I, X) | apply 'go'/2(call 'erlang':'+'(I, 1), Xs)]
      end
      in apply 'go'/2(0, List)

'isUnderscore'/1 =
  fun (_P0) ->
    case {_P0} of
      <{{'ExprIdent', Qn}}> when 'true' ->
        call 'erlang':'=:='(apply 'unwrapIdent'/1(call 'maps':'get'('name', Qn)), #{#<95>(8,1,'integer',['unsigned'|['big']])}#)
      <{_W0}> when 'true' ->
        'false'
    end

'operatorPrecedence'/1 =
  fun (Op) ->
    case Op of
      <#{#<42>(8,1,'integer',['unsigned'|['big']])}#> when 'true' ->
        7
      <#{#<47>(8,1,'integer',['unsigned'|['big']])}#> when 'true' ->
        7
      <#{#<109>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']])}#> when 'true' ->
        7
      <#{#<43>(8,1,'integer',['unsigned'|['big']])}#> when 'true' ->
        6
      <#{#<45>(8,1,'integer',['unsigned'|['big']])}#> when 'true' ->
        6
      <#{#<60>(8,1,'integer',['unsigned'|['big']]),#<62>(8,1,'integer',['unsigned'|['big']])}#> when 'true' ->
        6
      <#{#<43>(8,1,'integer',['unsigned'|['big']]),#<43>(8,1,'integer',['unsigned'|['big']])}#> when 'true' ->
        5
      <#{#<58>(8,1,'integer',['unsigned'|['big']])}#> when 'true' ->
        5
      <#{#<61>(8,1,'integer',['unsigned'|['big']]),#<61>(8,1,'integer',['unsigned'|['big']])}#> when 'true' ->
        4
      <#{#<47>(8,1,'integer',['unsigned'|['big']]),#<61>(8,1,'integer',['unsigned'|['big']])}#> when 'true' ->
        4
      <#{#<33>(8,1,'integer',['unsigned'|['big']]),#<61>(8,1,'integer',['unsigned'|['big']])}#> when 'true' ->
        4
      <#{#<60>(8,1,'integer',['unsigned'|['big']])}#> when 'true' ->
        4
      <#{#<62>(8,1,'integer',['unsigned'|['big']])}#> when 'true' ->
        4
      <#{#<60>(8,1,'integer',['unsigned'|['big']]),#<61>(8,1,'integer',['unsigned'|['big']])}#> when 'true' ->
        4
      <#{#<62>(8,1,'integer',['unsigned'|['big']]),#<61>(8,1,'integer',['unsigned'|['big']])}#> when 'true' ->
        4
      <#{#<38>(8,1,'integer',['unsigned'|['big']]),#<38>(8,1,'integer',['unsigned'|['big']])}#> when 'true' ->
        3
      <#{#<124>(8,1,'integer',['unsigned'|['big']]),#<124>(8,1,'integer',['unsigned'|['big']])}#> when 'true' ->
        2
      <#{#<36>(8,1,'integer',['unsigned'|['big']])}#> when 'true' ->
        1
      <#{#<35>(8,1,'integer',['unsigned'|['big']])}#> when 'true' ->
        1
      <#{#<62>(8,1,'integer',['unsigned'|['big']]),#<62>(8,1,'integer',['unsigned'|['big']]),#<62>(8,1,'integer',['unsigned'|['big']])}#> when 'true' ->
        1
      <#{#<62>(8,1,'integer',['unsigned'|['big']]),#<62>(8,1,'integer',['unsigned'|['big']]),#<61>(8,1,'integer',['unsigned'|['big']])}#> when 'true' ->
        1
      <#{#<60>(8,1,'integer',['unsigned'|['big']]),#<60>(8,1,'integer',['unsigned'|['big']]),#<60>(8,1,'integer',['unsigned'|['big']])}#> when 'true' ->
        1
      <#{#<62>(8,1,'integer',['unsigned'|['big']]),#<62>(8,1,'integer',['unsigned'|['big']])}#> when 'true' ->
        1
      <#{#<60>(8,1,'integer',['unsigned'|['big']]),#<45>(8,1,'integer',['unsigned'|['big']])}#> when 'true' ->
        0
      <_W0> when 'true' ->
        5
    end

'operatorIsRightAssoc'/1 =
  fun (Op) ->
    case Op of
      <#{#<58>(8,1,'integer',['unsigned'|['big']])}#> when 'true' ->
        'true'
      <#{#<36>(8,1,'integer',['unsigned'|['big']])}#> when 'true' ->
        'true'
      <#{#<62>(8,1,'integer',['unsigned'|['big']]),#<62>(8,1,'integer',['unsigned'|['big']]),#<62>(8,1,'integer',['unsigned'|['big']])}#> when 'true' ->
        'true'
      <#{#<60>(8,1,'integer',['unsigned'|['big']]),#<60>(8,1,'integer',['unsigned'|['big']]),#<60>(8,1,'integer',['unsigned'|['big']])}#> when 'true' ->
        'true'
      <_W0> when 'true' ->
        'false'
    end

'convertModule'/1 =
  fun (CstMod) ->
    let <ModuleName> = apply 'unwrapModuleName'/1(call 'maps':'get'('name', call 'maps':'get'('name', call 'maps':'get'('header', CstMod))))
      in case apply 'traverse'/2(fun (_Mf0) -> apply 'convertImportDecl'/1(_Mf0), call 'maps':'get'('imports', call 'maps':'get'('header', CstMod))) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Imports}> when 'true' ->
        case apply 'convertDeclarations'/1(call 'maps':'get'('decls', call 'maps':'get'('body', CstMod))) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Decls}> when 'true' ->
        let <ImportDecls> = call 'lists':'map'(call 'Nova.Compiler.Ast':'DeclImport'(), Imports)
      in {'Right', ь犴濮骄惋漉戾吾礤т邈灬蜥糸镱螫骄汜祆物鲠序屐蹁濮骇箦黹珧秕鹆痧孱渖眇歆ㄉ眇矧裟邈祗腻沆螬
      <{'Right', Decls}> when 'true' ->
        let <ImportDecls> = call 'lists':'map'(call 'Nova.Compiler.Ast':'DeclImport'(), Imports)
      in {'Right', ь犴濮骄惋漉戾吾礤т邈灬蜥糸镱螫骄汜祆物鲠序屐蹁濮骇箦黹珧秕鹆痧孱渖眇歆ㄉ眇矧裟邈祗腻沆螬
      end
      <{'Right', Imports}> when 'true' ->
        case apply 'convertDeclarations'/1(call 'maps':'get'('decls', call 'maps':'get'('body', CstMod))) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Decls}> when 'true' ->
        let <ImportDecls> = call 'lists':'map'(call 'Nova.Compiler.Ast':'DeclImport'(), Imports)
      in {'Right', ь犴濮骄惋漉戾吾礤т邈灬蜥糸镱螫骄汜祆物鲠序屐蹁濮骇箦黹珧秕鹆痧孱渖眇歆ㄉ眇矧裟邈祗腻沆螬
      <{'Right', Decls}> when 'true' ->
        let <ImportDecls> = call 'lists':'map'(call 'Nova.Compiler.Ast':'DeclImport'(), Imports)
      in {'Right', ь犴濮骄惋漉戾吾礤т邈灬蜥糸镱螫骄汜祆物鲠序屐蹁濮骇箦黹珧秕鹆痧孱渖眇歆ㄉ眇矧裟邈祗腻沆螬
      end
      end

'convertImportDecl'/1 =
  fun (Imp) ->
    let <ModuleName> = apply 'unwrapModuleName'/1(call 'maps':'get'('name', call 'maps':'get'('module', Imp)))
      in let <Alias> = case call 'maps':'get'('qualified', Imp) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Just', {'Tuple', _W0, QualName}}> when 'true' ->
        {'Just', apply 'unwrapModuleName'/1(call 'maps':'get'('name', QualName))}
    end
      in case case call 'maps':'get'('names', Imp) of
      <'Nothing'> when 'true' ->
        {'Right', []}
      <{'Just', {'Tuple', _W0, Delim}}> when 'true' ->
        case apply 'convertImportItems'/1(call 'maps':'get'('value', Delim)) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', ImportItems}> when 'true' ->
        {'Right', ImportItems}
      <{'Right', ImportItems}> when 'true' ->
        {'Right', ImportItems}
      end
    end of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Items}> when 'true' ->
        let <IsHiding> = case call 'maps':'get'('names', Imp) of
      <{'Just', {'Tuple', {'Just', _W0}, _W1}}> when 'true' ->
        'true'
      <_W0> when 'true' ->
        'false'
    end
      in {'Right', ы镤蹯逦犴濮骄惋漉戾吾礤п扉狍Ы玖扉狍ч翦眢Ы旧翦眢ц殇轭绉骄审乳溟铉
      <{'Right', Items}> when 'true' ->
        let <IsHiding> = case call 'maps':'get'('names', Imp) of
      <{'Just', {'Tuple', {'Just', _W0}, _W1}}> when 'true' ->
        'true'
      <_W0> when 'true' ->
        'false'
    end
      in {'Right', ы镤蹯逦犴濮骄惋漉戾吾礤п扉狍Ы玖扉狍ч翦眢Ы旧翦眢ц殇轭绉骄审乳溟铉
      end

'convertImportItems'/1 =
  fun (Sep) ->
    let <AllImports> = [call 'maps':'get'('head', Sep) | call 'lists':'map'(fun (_L0) ->
      case {_L0} of
        <{{'Tuple', _W0, I}}> when 'true' -> I
      end, call 'maps':'get'('tail', Sep))]
      in apply 'traverse'/2(fun (_Mf0) -> apply 'convertImportItem'/1(_Mf0), AllImports)

'convertImportItem'/1 =
  fun (Imp) ->
    case Imp of
      <{'ImportValue', Name}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'ImportValue'(apply 'unwrapIdent'/1(call 'maps':'get'('name', Name)))}
      <{'ImportOp', Name}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'ImportValue'(apply 'unwrapOperator'/1(call 'maps':'get'('name', Name)))}
      <{'ImportType', Name, MMembers}> when 'true' ->
        let <TypeName> = apply 'unwrapProper'/1(call 'maps':'get'('name', Name))
      in let <Spec> = apply 'convertDataMembers'/1(MMembers)
      in {'Right', call 'Nova.Compiler.Ast':'ImportType'(TypeName, Spec)}
      <{'ImportTypeOp', _W0, Name}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'ImportValue'(apply 'unwrapOperator'/1(call 'maps':'get'('name', Name)))}
      <{'ImportClass', _W0, Name}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'ImportType'(apply 'unwrapProper'/1(call 'maps':'get'('name', Name)), call 'Nova.Compiler.Ast':'ImportNone'())}
      <{'ImportError', _W0}> when 'true' ->
        {'Left', #{#<67>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<99>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<118>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<109>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']])}#}
    end

'convertDataMembers'/1 =
  fun (_P0) ->
    case {_P0} of
      <{'Nothing'}> when 'true' ->
        call 'Nova.Compiler.Ast':'ImportNone'()
      <{{'Just', {'DataAll', _W0}}}> when 'true' ->
        call 'Nova.Compiler.Ast':'ImportAll'()
      <{{'Just', {'DataEnumerated', Delim}}}> when 'true' ->
        case call 'maps':'get'('value', Delim) of
      <'Nothing'> when 'true' ->
        call 'Nova.Compiler.Ast':'ImportNone'()
      <{'Just', Sep}> when 'true' ->
        let <Names> = [apply 'unwrapProper'/1(call 'maps':'get'('name', call 'maps':'get'('head', Sep))) | call 'lists':'map'(fun (_L0) ->
      case {_L0} of
        <{{'Tuple', _W0, N}}> when 'true' -> apply 'unwrapProper'/1(call 'maps':'get'('name', N))
      end, call 'maps':'get'('tail', Sep))]
      in call 'Nova.Compiler.Ast':'ImportSome'(Names)
    end
    end

'convertDeclarations'/1 =
  fun (Decls) ->
    apply 'traverse'/2(fun (_Mf0) -> apply 'convertDeclaration'/1(_Mf0), Decls)

'convertDeclaration'/1 =
  fun (Decl) ->
    case Decl of
      <{'DeclData', Head, Ctors}> when 'true' ->
        apply 'convertDataType'/2(Head, Ctors)
      <{'DeclType', Head, _W0, Ty}> when 'true' ->
        apply 'convertTypeAlias'/2(Head, Ty)
      <{'DeclNewtype', Head, _W0, CtorName, WrappedTy}> when 'true' ->
        apply 'convertNewtype'/3(Head, CtorName, WrappedTy)
      <{'DeclClass', Head, Methods}> when 'true' ->
        apply 'convertTypeClass'/2(Head, Methods)
      <{'DeclInstanceChain', Chain}> when 'true' ->
        apply 'convertInstance'/1(Chain)
      <{'DeclDerive', _W0, _W1, InstHead}> when 'true' ->
        apply 'convertDeriveInstance'/1(InstHead)
      <{'DeclSignature', Labeled}> when 'true' ->
        apply 'convertTypeSignature'/1(Labeled)
      <{'DeclValue', Vbf}> when 'true' ->
        apply 'convertFunction'/1(Vbf)
      <{'DeclFixity', Fields}> when 'true' ->
        apply 'convertFixity'/1(Fields)
      <{'DeclForeign', _W0, _W1, Foreign_}> when 'true' ->
        apply 'convertForeign'/1(Foreign_)
      <{'DeclError', _W0}> when 'true' ->
        {'Left', #{#<67>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<99>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<118>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<99>(8,1,'integer',['unsigned'|['big']]),#<108>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']])}#}
    end

'convertDataType'/2 =
  fun (Head, MCtors) ->
    let <Name> = apply 'unwrapProper'/1(call 'maps':'get'('name', call 'maps':'get'('name', Head)))
      in let <TypeVars> = call 'lists':'map'(fun (_Mf0) -> apply 'extractTypeVar'/1(_Mf0), call 'maps':'get'('vars', Head))
      in case case MCtors of
      <'Nothing'> when 'true' ->
        {'Right', []}
      <{'Just', {'Tuple', _W0, Separated}}> when 'true' ->
        apply 'convertDataCtors'/1(Separated)
    end of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Ctors}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'DeclDataType'(ь犴濮骄吾礤豉疱轴蝮Ы驹疱轴蝮с镱篝蝓泗矧螫骄敏矧簖见б殓梏К敏矧簖麒孱趄蹂б殓梏К汜祆物鲠蔑眇殪弪馏臾骇腻沆尼翎赠疱Жь犴濮骄吾礤豉疱轴蝮Ы驹疱轴蝮с镱篝蝓泗矧螫骄敏矧簖孱с镱鲥螋尼翎敏矧螫骢ㄓ屦戾剂祆敏矧缶坫犰ы狃螫骇珏臾ě桢徜К渝皓汜祆ъ轶趔Шы狃Ж骢ㄟ贪汜箦咛褒镦见г躔戾К咦艾谬麒孱趄蹂孱洮汜祆ы狃螫骇珏臾ě翎殪К渝皓┹轭狃痨趄狯弪箦Н波骢ㄟ玩癌狃痨с镱鲥螋尼翎敏矧Н报咄姘┈领烀麸蝮с镱鲥螋尼翎敏矧Н骢敏矧戾嘉犴寰狃痨躅黩狃序镳弪Н报汜祆ы狃螫骇珏臾ě钺礤К汜祆ы狃螫骇珏臾ě钺礤К敏矧┅轭汜箦狃痨趄狯弪箦Н波骢ㄟ玩癌狃痨с镱鲥螋赠疱燥崎屐洄报咄姘┈汜祆ы狃螫骇珏臾ě骈屐潴К敏矧┅镦姬物翳轭绉麒孱趄蹂物翳轭绉见体骠К吲蝌麒孱趄蹂体骠К吲蝌见术篝К崎屐潴麒孱趄蹂б殓梏Кь犴濮骄吾礤ф殄熹螫骄崎屐潴ч笠邈矧洄骄ф犰箦
      <{'Right', Fields}> when 'true' ->
        {'Right', ь犴濮骄吾礤ф殄熹螫骄崎屐潴ч笠邈矧洄骄ф犰箦
      end

'convertTypeToField'/1 =
  fun (Ty) ->
    case apply 'convertType'/1(Ty) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', TyExpr}> when 'true' ->
        {'Right', ъ徕屐Ы荆，豉Ы驹砒痱
      <{'Right', TyExpr}> when 'true' ->
        {'Right', ъ徕屐Ы荆，豉Ы驹砒痱
      end

'convertTypeAlias'/2 =
  fun (Head, Ty) ->
    let <Name> = apply 'unwrapProper'/1(call 'maps':'get'('name', call 'maps':'get'('name', Head)))
      in let <TypeVars> = call 'lists':'map'(fun (_Mf0) -> apply 'extractTypeVar'/1(_Mf0), call 'maps':'get'('vars', Head))
      in case apply 'convertType'/1(Ty) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', TyExpr}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'DeclTypeAlias'(ь犴濮骄吾礤豉疱轴蝮Ы驹疱轴蝮豉Ы驹砒痱见б殓梏К赠砒痱麒孱趄蹂б殓梏К汜祆物鲠蔑眇殪弪馏臾骇腻沆赠疱领獒螫ь犴濮骄吾礤豉疱轴蝮Ы驹疱轴蝮豉Ы驹砒痱孱с镱鲥螋五黥疱Н骢ㄈ遽洮敏矧吾礤昨狃疱湓戾嘉犴寰狃痨躅黩狃序镳弪Н报汜祆ы狃螫骇珏臾ě钺礤К汜祆ы狃螫骇珏臾ě钺礤К儒徜┅轭戾荚疱轴蝮汜祆ъ轶趔Шы狃Ж骢ㄟ玩癌狃痨у趄徙粼疱轴颛报咄姘┈汜祆ы狃螫骇珏臾ě鲠蝮К儒徜┅轭戾济镱篝蝓泗矧狃痨躅黩狃序镳弪Н报汜祆ы狃螫骇珏臾ě钺礤К敏矧吾礤┅轭汜箦狃痨с镱鲥螋赠疱Н报昨狃疱湓镦姬物翳轭绉麒孱趄蹂物翳轭绉见体骠К吲蝌麒孱趄蹂体骠К吲蝌见术篝К昨狃疱湓疱麒孱趄蹂б殓梏К汜祆物鲠蔑眇殪弪馏臾骇腻沆五黥疱Жь犴濮骄吾礤豉疱轴蝮Ы驹疱轴蝮с镱篝蝓泗矧Ы久镱篝蝓泗矧黩狃疱湓疱Ы咀蜥痧邃赠疱见б殓梏К昨狃疱湓疱麒孱趄蹂б殓梏К汜祆物鲠蔑眇殪弪馏臾骇腻沆五黥疱Жь犴濮骄吾礤豉疱轴蝮Ы驹疱轴蝮с镱篝蝓泗矧Ы久镱篝蝓泗矧黩狃疱湓疱Ы咀蜥痧邃赠疱孱с镱鲥螋赠疱渺狍螫骢ㄈ遽洮屯弭栾潴戾嘉犴寰狃痨躅黩狃序镳弪Н报汜祆ы狃螫骇珏臾ě钺礤К汜祆ы狃螫骇珏臾ě钺礤К儒徜┅轭戾荚疱轴蝮汜祆ъ轶趔Шы狃Ж骢ㄟ玩癌狃痨у趄徙粼疱轴颛报咄姘┈汜祆ы狃螫骇珏臾ě鲠蝮К儒徜┅轭汜箦汜箦屯弭栾潴镦姬物翳轭绉麒孱趄蹂б殓梏К圯见术篝Кг躔戾К咦艾提忮戾潺麒孱趄蹂狃痨趄狯弪箦Н波骢ㄟ玩癌狃痨с镱鲥螋湾翳镤娱绉报咄姘┈提忮戾洎孱镦姬物翳轭绉麒孱趄蹂物翳轭绉见体骠К吲蝌麒孱趄蹂体骠К吲蝌见术篝К湾翳镤簖麒孱趄蹂б殓梏К汜祆物鲠蔑眇殪弪馏臾骇腻沆赠疱渺狍螫ь犴濮骄吾礤豉疱轴蝮Ы驹疱轴蝮ы弭栾潴Ы就弭栾潴щ轭洄骄物翳轭绉见б殓梏К湾翳镤簖麒孱趄蹂б殓梏К汜祆物鲠蔑眇殪弪馏臾骇腻沆赠疱渺狍螫ь犴濮骄吾礤豉疱轴蝮Ы驹疱轴蝮ы弭栾潴Ы就弭栾潴щ轭洄骄物翳轭绉孱с镱鲥螋湾翳镤娱绉骢ㄌ徕屐邃戾嘉犴寰狃痨躅黩狃射孱臾报汜祆ы狃螫骇珏臾ě钺礤К汜祆ы狃螫骇珏臾ě灬忮歆提忮戾洎┅轭汜箦狃痨с镱鲥螋赠疱Н报汜祆ы狃螫骇珏臾ě鲠祯濮提忮戾洎镦姬物翳轭绉麒孱趄蹂物翳轭绉见体骠К吲蝌麒孱趄蹂体骠К吲蝌见术篝К赠麒孱趄蹂б殓梏Кь犴濮骄吾礤豉疱轴蝮Ы聚莠с镱篝蜥轭趔Ы聚莠豉Ы驹
      <{'Right', Ty}> when 'true' ->
        {'Right', ь犴濮骄吾礤豉疱轴蝮Ы聚莠с镱篝蜥轭趔Ы聚莠豉Ы驹
      end

'convertInstance'/1 =
  fun (Chain) ->
    let <Inst> = call 'maps':'get'('head', Chain)
      in let <ClassName> = apply 'unwrapProper'/1(call 'maps':'get'('name', call 'maps':'get'('className', call 'maps':'get'('head', Inst))))
      in case case call 'maps':'get'('types', call 'maps':'get'('head', Inst)) of
      <[T | _W0]> when 'true' ->
        apply 'convertType'/1(T)
      <[]> when 'true' ->
        {'Left', #{#<73>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<99>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<108>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<121>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']])}#}
    end of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Ty}> when 'true' ->
        case case call 'maps':'get'('body', Inst) of
      <'Nothing'> when 'true' ->
        {'Right', []}
      <{'Just', {'Tuple', _W0, Bindings}}> when 'true' ->
        apply 'traverse'/2(fun (_Mf0) -> apply 'convertInstanceBinding'/1(_Mf0), Bindings)
    end of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Methods}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'DeclTypeClassInstance'(с灬篌吾礤Ы久灬篌吾礤豉Ы驹ы弭栾潴Ы就弭栾潴т弪轹邃Ы晶驷祗濮见б殓梏К湾翳镤簖麒孱趄蹂б殓梏К汜祆物鲠蔑眇殪弪馏臾骇腻沆赠疱渺狍笊铙翎钽濮с灬篌吾礤Ы久灬篌吾礤豉Ы驹ы弭栾潴Ы就弭栾潴т弪轹邃Ы晶驷祗濮孱见б殓梏К赠麒孱趄蹂汜箦汜箦汜祆ы狃螫骇珏臾ě怙澌К深篝镦姬物翳轭绉麒孱趄蹂б殓梏К圯见术篝Кг躔戾К咦艾麻钿轭珞麒孱趄蹂狃痨趄狯弪箦Н波骢ㄟ玩癌狃痨с镱鲥螋深篝犷沐麻钿轭绉报咄姘┈麻钿轭珞孱镦姬物翳轭绉麒孱趄蹂物翳轭绉见体骠К吲蝌麒孱趄蹂体骠К吲蝌见术篝К湾翳镤簖麒孱趄蹂б殓梏К汜祆物鲠蔑眇殪弪馏臾骇腻沆赠疱渺狍笊铙翎钽濮с灬篌吾礤Ы久灬篌吾礤豉Ы驹ы弭栾潴Ы就弭栾潴т弪轹邃Ы晶驷祗濮见б殓梏К湾翳镤簖麒孱趄蹂б殓梏К汜祆物鲠蔑眇殪弪馏臾骇腻沆赠疱渺狍笊铙翎钽濮с灬篌吾礤Ы久灬篌吾礤豉Ы驹ы弭栾潴Ы就弭栾潴т弪轹邃Ы晶驷祗濮孱孱с镱鲥螋深篝犷沐麻钿轭绉骢麻钿轭绌汜箦麻钿轭镦见深篝犷沐麻钿轭缬殓钺趱蝈К咦褒麒孱趄蹂体骠К｛＜复鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜辈本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北簿ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜巢鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北稻ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑稻ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑尘ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北熬ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜狗鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北毒ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北肪ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北淳ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北稻ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜巢鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑稻ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北熬ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜巢鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑稻ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北熬ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北稻ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北毒ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜狗鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北熬ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜构鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北稻ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜巢鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北熬ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北毒ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜巢鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜辈本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北毒ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜巢鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北稻ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北肪ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北簿ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北簿ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北淳ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北毒ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑熬ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺｝见深篝犷沐麻钿轭缥犴濮肘纨麒孱趄蹂狃痨с镱鲥螋轴祯迓轭溟铉Н报肘姗孱с镱鲥螋腻蜷鲥深篝犷沐Н骢ㄈ遽洎戾济灬篌吾礤狃痨躅黩狃序镳弪Н报汜祆ы狃螫骇珏臾ě钺礤К汜祆ы狃螫骇珏臾ě沆狍笪犴濮儒徜┅轭汜箦汜箦汜祆ы狃螫骇珏臾ě豉疱螫儒徜镦价咦拜麒孱趄蹂狃痨с镱鲥螋赠疱Н报冤价菥麒孱趄蹂体骠К｛＜陡鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北淳ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑稻ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北妇ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑熬ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜巢鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑稻ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北熬ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北稻ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北毒ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜狗鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北熬ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜构鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜巢鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北熬ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑熬ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北稻ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜巢鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜狗鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北毒ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜巢鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑妇ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜狗鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北稻ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北毒ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜巢鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北熬ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜巢鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北毒ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜辈本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北簿ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺｝孱镦姬物翳轭绉麒孱趄蹂物翳轭绉见体骠К吲蝌麒孱趄蹂体骠К吲蝌见术篝К赠麒孱趄蹂б殓梏К汜祆物鲠蔑眇殪弪馏臾骇腻沆赠疱渺狍笊铙翎钽濮с灬篌吾礤Ы久灬篌吾礤豉Ы驹ы弭栾潴Ы聚莠т弪轹邃Ы晶趄蹂见б殓梏К赠麒孱趄蹂б殓梏К汜祆物鲠蔑眇殪弪馏臾骇腻沆赠疱渺狍笊铙翎钽濮с灬篌吾礤Ы久灬篌吾礤豉Ы驹ы弭栾潴Ы聚莠т弪轹邃Ы晶趄蹂孱с镱鲥螋契钽糸镱Н骢ㄖ怄汜箦狃痨с镱鲥螋轴祯迓轭溟铉Н报肘姗镦姬物翳轭绉麒孱趄蹂物翳轭绉见体骠К吲蝌麒孱趄蹂体骠К吲蝌见术篝К契钽麒孱趄蹂б殓梏К汜祆物鲠蔑眇殪弪馏臾骇腻沆契钽糸镱Ж契钽见б殓梏К契钽麒孱趄蹂б殓梏К汜祆物鲠蔑眇殪弪馏臾骇腻沆契钽糸镱Ж契钽孱с镱鲥螋轴祯迓轭溟铉Н骢ㄖ怄戾嘉犴寰狃痨躅黩狃射孱臾报汜祆ы狃螫骇珏臾ě钺礤К汜祆ы狃螫骇珏臾ě钺礤К肘姗┅轭汜箦狃痨趄狯弪箦Н波骢ㄟ玩癌狃痨с镱鲥螋麻钿弪Н报咄姘┈汜祆ы狃螫骇珏臾ě忾钿弪螫肘姗镦姬物翳轭绉麒孱趄蹂物翳轭绉见体骠К吲蝌麒孱趄蹂体骠К吲蝌见术篝К嗅蜥眢麒孱趄蹂汜箦汜祆ы狃螫骇珏臾ě珲狎溴洄肘姗镦见д钽镱溟糸镱犰К咦艾阻麒孱趄蹂汜箦狃痨с镱鲥螋阻弪迮痱Н报阻镦姬物翳轭绉麒孱趄蹂物翳轭绉见体骠К吲蝌麒孱趄蹂体骠К吲蝌见术篝К嘛澌麒孱趄蹂б殓梏Кь犴濮骄吾礤ю狎犴弭弪螫骄嗅蜥眢р镤Ы韭镤х踽蜾螫骄圯豉疱娱珙狒躜濮骄物翳轭绉
      <{'Right', Body}> when 'true' ->
        {'Right', ь犴濮骄吾礤ю狎犴弭弪螫骄嗅蜥眢р镤Ы韭镤х踽蜾螫骄圯豉疱娱珙狒躜濮骄物翳轭绉
      end
      <{'Guarded', GuardedExprs}> when 'true' ->
        case apply 'traverse'/2(fun (_Mf0) -> apply 'convertGuardedExpr'/1(_Mf0), GuardedExprs) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Guards}> when 'true' ->
        case Guards of
      <[G | _W0]> when 'true' ->
        {'Right', ь犴濮骄吾礤ю狎犴弭弪螫骄嗅蜥眢р镤Ы俱犰ы狃螫骇珏臾ě怙澌К签х踽蜾螫骄酋狎潴豉疱娱珙狒躜濮骄物翳轭绉
      <[]> when 'true' ->
        {'Left', #{#<69>(8,1,'integer',['unsigned'|['big']]),#<109>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<121>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<103>(8,1,'integer',['unsigned'|['big']]),#<117>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<120>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']])}#}
    end
      <{'Right', Guards}> when 'true' ->
        case Guards of
      <[G | _W0]> when 'true' ->
        {'Right', ь犴濮骄吾礤ю狎犴弭弪螫骄嗅蜥眢р镤Ы俱犰ы狃螫骇珏臾ě怙澌К签х踽蜾螫骄酋狎潴豉疱娱珙狒躜濮骄物翳轭绉
      <[]> when 'true' ->
        {'Left', #{#<69>(8,1,'integer',['unsigned'|['big']]),#<109>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<121>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<103>(8,1,'integer',['unsigned'|['big']]),#<117>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<120>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']])}#}
    end
      end
    end
      <{'Right', Params}> when 'true' ->
        case call 'maps':'get'('guarded', Vbf) of
      <{'Unconditional', _W0, Wh}> when 'true' ->
        case apply 'convertWhereExpr'/1(Wh) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Body}> when 'true' ->
        {'Right', ь犴濮骄吾礤ю狎犴弭弪螫骄嗅蜥眢р镤Ы韭镤х踽蜾螫骄圯豉疱娱珙狒躜濮骄物翳轭绉
      <{'Right', Body}> when 'true' ->
        {'Right', ь犴濮骄吾礤ю狎犴弭弪螫骄嗅蜥眢р镤Ы韭镤х踽蜾螫骄圯豉疱娱珙狒躜濮骄物翳轭绉
      end
      <{'Guarded', GuardedExprs}> when 'true' ->
        case apply 'traverse'/2(fun (_Mf0) -> apply 'convertGuardedExpr'/1(_Mf0), GuardedExprs) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Guards}> when 'true' ->
        case Guards of
      <[G | _W0]> when 'true' ->
        {'Right', ь犴濮骄吾礤ю狎犴弭弪螫骄嗅蜥眢р镤Ы俱犰ы狃螫骇珏臾ě怙澌К签х踽蜾螫骄酋狎潴豉疱娱珙狒躜濮骄物翳轭绉
      <[]> when 'true' ->
        {'Left', #{#<69>(8,1,'integer',['unsigned'|['big']]),#<109>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<121>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<103>(8,1,'integer',['unsigned'|['big']]),#<117>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<120>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']])}#}
    end
      <{'Right', Guards}> when 'true' ->
        case Guards of
      <[G | _W0]> when 'true' ->
        {'Right', ь犴濮骄吾礤ю狎犴弭弪螫骄嗅蜥眢р镤Ы俱犰ы狃螫骇珏臾ě怙澌К签х踽蜾螫骄酋狎潴豉疱娱珙狒躜濮骄物翳轭绉
      <[]> when 'true' ->
        {'Left', #{#<69>(8,1,'integer',['unsigned'|['big']]),#<109>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<121>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<103>(8,1,'integer',['unsigned'|['big']]),#<117>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<120>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']])}#}
    end
      end
    end
      end

'convertWhereExpr'/1 =
  fun (Wh) ->
    case apply 'convertExpr'/1(call 'maps':'get'('expr', Wh)) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Expr}> when 'true' ->
        case call 'maps':'get'('bindings', Wh) of
      <'Nothing'> when 'true' ->
        {'Right', Expr}
      <{'Just', {'Tuple', _W0, Bindings}}> when 'true' ->
        case apply 'convertWhereBindings'/1(Bindings) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', LetBinds}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'ExprLet'(LetBinds, Expr)}
      <{'Right', LetBinds}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'ExprLet'(LetBinds, Expr)}
      end
    end
      <{'Right', Expr}> when 'true' ->
        case call 'maps':'get'('bindings', Wh) of
      <'Nothing'> when 'true' ->
        {'Right', Expr}
      <{'Just', {'Tuple', _W0, Bindings}}> when 'true' ->
        case apply 'convertWhereBindings'/1(Bindings) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', LetBinds}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'ExprLet'(LetBinds, Expr)}
      <{'Right', LetBinds}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'ExprLet'(LetBinds, Expr)}
      end
    end
      end

'convertLetBindings'/1 =
  fun (Bindings) ->
    letrec 'collectLetSignatures'/1 = fun (_L0) ->
      case {_L0} of
        <{[]}> when 'true' -> []
        <{[B | Bs]}> when 'true' -> case B of
      <{'LetBindingSignature', Labeled}> when 'true' ->
        let <Name> = apply 'unwrapIdent'/1(call 'maps':'get'('name', call 'maps':'get'('label', Labeled)))
      in [call 'Data.Tuple':'Tuple'(Name, call 'maps':'get'('value', Labeled)) | apply 'collectLetSignatures'/1(Bs)]
      <_W0> when 'true' ->
        apply 'collectLetSignatures'/1(Bs)
    end
      end
       'lookupLetSig'/2 = fun (_L0, _L1) ->
      case {_L0, _L1} of
        <{_W0, []}> when 'true' -> 'Nothing'
        <{Name, [{'Tuple', N, Ty} | Rest]}> when 'true' -> case call 'erlang':'=:='(Name, N) of
      <'true'> when 'true' -> {'Just', Ty}
      <'false'> when 'true' -> apply 'lookupLetSig'/2(Name, Rest)
    end
      end
       'getLetValueBinding'/1 = fun (_L0) ->
      case {_L0} of
        <{{'LetBindingName', Vbf}}> when 'true' -> {'Just', {'Left', Vbf}}
        <{{'LetBindingPattern', Binder, Sep, Wh}}> when 'true' -> {'Just', {'Right', р轭溴颛骄麻钿弪箦皈骄渝瓞麒Ы咀椠}
        <{_W0}> when 'true' -> 'Nothing'
      end
       'convertLetBindingWithSig'/2 = fun (_L0, _L1) ->
      case {_L0, _L1} of
        <{SigMap, {'Left', Vbf}}> when 'true' -> let <Name> = apply 'unwrapIdent'/1(call 'maps':'get'('name', call 'maps':'get'('name', Vbf)))
      in case apply 'traverse'/2(fun (_Mf0) -> apply 'convertBinder'/1(_Mf0), call 'maps':'get'('binders', Vbf)) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Params}> when 'true' ->
        case case apply 'lookupLetSig'/2(Name, SigMap) of
      <'Nothing'> when 'true' ->
        {'Right', 'Nothing'}
      <{'Just', CstTy}> when 'true' ->
        case apply 'convertType'/1(CstTy) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Ty}> when 'true' ->
        {'Right', {'Just', Ty}}
      <{'Right', Ty}> when 'true' ->
        {'Right', {'Just', Ty}}
      end
    end of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', TypeAnn}> when 'true' ->
        case case call 'maps':'get'('guarded', Vbf) of
      <{'Unconditional', _W0, Wh}> when 'true' ->
        apply 'convertExpr'/1(call 'maps':'get'('expr', Wh))
      <{'Guarded', Guards}> when 'true' ->
        case Guards of
      <[Ge | _W0]> when 'true' ->
        apply 'convertExpr'/1(call 'maps':'get'('expr', call 'maps':'get'('where', Ge)))
      <[]> when 'true' ->
        {'Left', #{#<69>(8,1,'integer',['unsigned'|['big']]),#<109>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<121>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<103>(8,1,'integer',['unsigned'|['big']]),#<117>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<108>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<98>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<103>(8,1,'integer',['unsigned'|['big']])}#}
    end
    end of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', BodyExpr}> when 'true' ->
        let <Body> = case call 'Data.List':'null'(Params) of
      <'true'> when 'true' -> BodyExpr
      <'false'> when 'true' -> call 'Nova.Compiler.Ast':'ExprLambda'(Params, BodyExpr)
    end
      in {'Right', ю狒翦蝾Ы俱犰物鲠蔑眇殪弪馏臾骇嗅糁狎Ж吾礤┈鲠祯濮骄嘛澌豉疱令瞌骄赠疱令铨
      <{'Right', BodyExpr}> when 'true' ->
        let <Body> = case call 'Data.List':'null'(Params) of
      <'true'> when 'true' -> BodyExpr
      <'false'> when 'true' -> call 'Nova.Compiler.Ast':'ExprLambda'(Params, BodyExpr)
    end
      in {'Right', ю狒翦蝾Ы俱犰物鲠蔑眇殪弪馏臾骇嗅糁狎Ж吾礤┈鲠祯濮骄嘛澌豉疱令瞌骄赠疱令铨
      end
      <{'Right', TypeAnn}> when 'true' ->
        case case call 'maps':'get'('guarded', Vbf) of
      <{'Unconditional', _W0, Wh}> when 'true' ->
        apply 'convertExpr'/1(call 'maps':'get'('expr', Wh))
      <{'Guarded', Guards}> when 'true' ->
        case Guards of
      <[Ge | _W0]> when 'true' ->
        apply 'convertExpr'/1(call 'maps':'get'('expr', call 'maps':'get'('where', Ge)))
      <[]> when 'true' ->
        {'Left', #{#<69>(8,1,'integer',['unsigned'|['big']]),#<109>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<121>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<103>(8,1,'integer',['unsigned'|['big']]),#<117>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<108>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<98>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<103>(8,1,'integer',['unsigned'|['big']])}#}
    end
    end of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', BodyExpr}> when 'true' ->
        let <Body> = case call 'Data.List':'null'(Params) of
      <'true'> when 'true' -> BodyExpr
      <'false'> when 'true' -> call 'Nova.Compiler.Ast':'ExprLambda'(Params, BodyExpr)
    end
      in {'Right', ю狒翦蝾Ы俱犰物鲠蔑眇殪弪馏臾骇嗅糁狎Ж吾礤┈鲠祯濮骄嘛澌豉疱令瞌骄赠疱令铨
      <{'Right', BodyExpr}> when 'true' ->
        let <Body> = case call 'Data.List':'null'(Params) of
      <'true'> when 'true' -> BodyExpr
      <'false'> when 'true' -> call 'Nova.Compiler.Ast':'ExprLambda'(Params, BodyExpr)
    end
      in {'Right', ю狒翦蝾Ы俱犰物鲠蔑眇殪弪馏臾骇嗅糁狎Ж吾礤┈鲠祯濮骄嘛澌豉疱令瞌骄赠疱令铨
      end
      end
      <{'Right', Params}> when 'true' ->
        case case apply 'lookupLetSig'/2(Name, SigMap) of
      <'Nothing'> when 'true' ->
        {'Right', 'Nothing'}
      <{'Just', CstTy}> when 'true' ->
        case apply 'convertType'/1(CstTy) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Ty}> when 'true' ->
        {'Right', {'Just', Ty}}
      <{'Right', Ty}> when 'true' ->
        {'Right', {'Just', Ty}}
      end
    end of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', TypeAnn}> when 'true' ->
        case case call 'maps':'get'('guarded', Vbf) of
      <{'Unconditional', _W0, Wh}> when 'true' ->
        apply 'convertExpr'/1(call 'maps':'get'('expr', Wh))
      <{'Guarded', Guards}> when 'true' ->
        case Guards of
      <[Ge | _W0]> when 'true' ->
        apply 'convertExpr'/1(call 'maps':'get'('expr', call 'maps':'get'('where', Ge)))
      <[]> when 'true' ->
        {'Left', #{#<69>(8,1,'integer',['unsigned'|['big']]),#<109>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<121>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<103>(8,1,'integer',['unsigned'|['big']]),#<117>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<108>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<98>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<103>(8,1,'integer',['unsigned'|['big']])}#}
    end
    end of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', BodyExpr}> when 'true' ->
        let <Body> = case call 'Data.List':'null'(Params) of
      <'true'> when 'true' -> BodyExpr
      <'false'> when 'true' -> call 'Nova.Compiler.Ast':'ExprLambda'(Params, BodyExpr)
    end
      in {'Right', ю狒翦蝾Ы俱犰物鲠蔑眇殪弪馏臾骇嗅糁狎Ж吾礤┈鲠祯濮骄嘛澌豉疱令瞌骄赠疱令铨
      <{'Right', BodyExpr}> when 'true' ->
        let <Body> = case call 'Data.List':'null'(Params) of
      <'true'> when 'true' -> BodyExpr
      <'false'> when 'true' -> call 'Nova.Compiler.Ast':'ExprLambda'(Params, BodyExpr)
    end
      in {'Right', ю狒翦蝾Ы俱犰物鲠蔑眇殪弪馏臾骇嗅糁狎Ж吾礤┈鲠祯濮骄嘛澌豉疱令瞌骄赠疱令铨
      end
      <{'Right', TypeAnn}> when 'true' ->
        case case call 'maps':'get'('guarded', Vbf) of
      <{'Unconditional', _W0, Wh}> when 'true' ->
        apply 'convertExpr'/1(call 'maps':'get'('expr', Wh))
      <{'Guarded', Guards}> when 'true' ->
        case Guards of
      <[Ge | _W0]> when 'true' ->
        apply 'convertExpr'/1(call 'maps':'get'('expr', call 'maps':'get'('where', Ge)))
      <[]> when 'true' ->
        {'Left', #{#<69>(8,1,'integer',['unsigned'|['big']]),#<109>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<121>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<103>(8,1,'integer',['unsigned'|['big']]),#<117>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<108>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<98>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<103>(8,1,'integer',['unsigned'|['big']])}#}
    end
    end of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', BodyExpr}> when 'true' ->
        let <Body> = case call 'Data.List':'null'(Params) of
      <'true'> when 'true' -> BodyExpr
      <'false'> when 'true' -> call 'Nova.Compiler.Ast':'ExprLambda'(Params, BodyExpr)
    end
      in {'Right', ю狒翦蝾Ы俱犰物鲠蔑眇殪弪馏臾骇嗅糁狎Ж吾礤┈鲠祯濮骄嘛澌豉疱令瞌骄赠疱令铨
      <{'Right', BodyExpr}> when 'true' ->
        let <Body> = case call 'Data.List':'null'(Params) of
      <'true'> when 'true' -> BodyExpr
      <'false'> when 'true' -> call 'Nova.Compiler.Ast':'ExprLambda'(Params, BodyExpr)
    end
      in {'Right', ю狒翦蝾Ы俱犰物鲠蔑眇殪弪馏臾骇嗅糁狎Ж吾礤┈鲠祯濮骄嘛澌豉疱令瞌骄赠疱令铨
      end
      end
      end
        <{_W0, {'Right', р轭溴颛航麻钿弪麒Ш阶椠}> when 'true' -> case apply 'convertBinder'/1(Binder) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Pat}> when 'true' ->
        case apply 'convertExpr'/1(call 'maps':'get'('expr', Wh)) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Body}> when 'true' ->
        {'Right', ю狒翦蝾Ы拘狒鲠祯濮骄嘛澌豉疱令瞌骄物翳轭绉
      <{'Right', Body}> when 'true' ->
        {'Right', ю狒翦蝾Ы拘狒鲠祯濮骄嘛澌豉疱令瞌骄物翳轭绉
      end
      <{'Right', Pat}> when 'true' ->
        case apply 'convertExpr'/1(call 'maps':'get'('expr', Wh)) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Body}> when 'true' ->
        {'Right', ю狒翦蝾Ы拘狒鲠祯濮骄嘛澌豉疱令瞌骄物翳轭绉
      <{'Right', Body}> when 'true' ->
        {'Right', ю狒翦蝾Ы拘狒鲠祯濮骄嘛澌豉疱令瞌骄物翳轭绉
      end
      end
      end
      in let <SigMap> = apply 'collectLetSignatures'/1(Bindings)
      in let <ValueBindings> = call 'Data.List':'mapMaybe'(fun (_Mf0) -> apply 'getLetValueBinding'/1(_Mf0), Bindings)
      in apply 'traverse'/2(fun (_Pc0) -> apply 'convertLetBindingWithSig'/2(SigMap, _Pc0), ValueBindings)

'convertWhereBindings'/1 =
  fun (Bindings) ->
    letrec 'collectSignatures'/1 = fun (_L0) ->
      case {_L0} of
        <{[]}> when 'true' -> []
        <{[B | Bs]}> when 'true' -> case B of
      <{'LetBindingSignature', Labeled}> when 'true' ->
        let <Name> = apply 'unwrapIdent'/1(call 'maps':'get'('name', call 'maps':'get'('label', Labeled)))
      in [call 'Data.Tuple':'Tuple'(Name, call 'maps':'get'('value', Labeled)) | apply 'collectSignatures'/1(Bs)]
      <_W0> when 'true' ->
        apply 'collectSignatures'/1(Bs)
    end
      end
       'lookupSig'/2 = fun (_L0, _L1) ->
      case {_L0, _L1} of
        <{_W0, []}> when 'true' -> 'Nothing'
        <{Name, [{'Tuple', N, Ty} | Rest]}> when 'true' -> case call 'erlang':'=:='(Name, N) of
      <'true'> when 'true' -> {'Just', Ty}
      <'false'> when 'true' -> apply 'lookupSig'/2(Name, Rest)
    end
      end
       'getValueBinding'/1 = fun (_L0) ->
      case {_L0} of
        <{{'LetBindingName', Vbf}}> when 'true' -> {'Just', Vbf}
        <{_W0}> when 'true' -> 'Nothing'
      end
       'convertLetBindWithSig'/2 = fun (SigMap, Vbf) ->
      let <BindName> = apply 'unwrapIdent'/1(call 'maps':'get'('name', call 'maps':'get'('name', Vbf)))
      in case apply 'traverse'/2(fun (_Mf0) -> apply 'convertBinder'/1(_Mf0), call 'maps':'get'('binders', Vbf)) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', BindParams}> when 'true' ->
        case case apply 'lookupSig'/2(BindName, SigMap) of
      <'Nothing'> when 'true' ->
        {'Right', 'Nothing'}
      <{'Just', CstTy}> when 'true' ->
        case apply 'convertType'/1(CstTy) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Ty}> when 'true' ->
        {'Right', {'Just', Ty}}
      <{'Right', Ty}> when 'true' ->
        {'Right', {'Just', Ty}}
      end
    end of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', TypeAnn}> when 'true' ->
        case call 'maps':'get'('guarded', Vbf) of
      <{'Unconditional', _W0, Wh}> when 'true' ->
        case apply 'convertWhereExpr'/1(Wh) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', BindBody}> when 'true' ->
        let <Value> = case BindParams of
      <[]> when 'true' ->
        BindBody
      <_W0> when 'true' ->
        call 'Nova.Compiler.Ast':'ExprLambda'(BindParams, BindBody)
    end
      in {'Right', ю狒翦蝾Ы俱犰物鲠蔑眇殪弪馏臾骇嗅糁狎Ж麻钿吾礤┈鲠祯濮骄轴祯瀣豉疱令瞌骄赠疱令铨
      <{'Right', BindBody}> when 'true' ->
        let <Value> = case BindParams of
      <[]> when 'true' ->
        BindBody
      <_W0> when 'true' ->
        call 'Nova.Compiler.Ast':'ExprLambda'(BindParams, BindBody)
    end
      in {'Right', ю狒翦蝾Ы俱犰物鲠蔑眇殪弪馏臾骇嗅糁狎Ж麻钿吾礤┈鲠祯濮骄轴祯瀣豉疱令瞌骄赠疱令铨
      end
      <{'Guarded', _W0}> when 'true' ->
        {'Left', #{#<71>(8,1,'integer',['unsigned'|['big']]),#<117>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<119>(8,1,'integer',['unsigned'|['big']]),#<104>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<98>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<103>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<121>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<117>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']])}#}
    end
      <{'Right', TypeAnn}> when 'true' ->
        case call 'maps':'get'('guarded', Vbf) of
      <{'Unconditional', _W0, Wh}> when 'true' ->
        case apply 'convertWhereExpr'/1(Wh) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', BindBody}> when 'true' ->
        let <Value> = case BindParams of
      <[]> when 'true' ->
        BindBody
      <_W0> when 'true' ->
        call 'Nova.Compiler.Ast':'ExprLambda'(BindParams, BindBody)
    end
      in {'Right', ю狒翦蝾Ы俱犰物鲠蔑眇殪弪馏臾骇嗅糁狎Ж麻钿吾礤┈鲠祯濮骄轴祯瀣豉疱令瞌骄赠疱令铨
      <{'Right', BindBody}> when 'true' ->
        let <Value> = case BindParams of
      <[]> when 'true' ->
        BindBody
      <_W0> when 'true' ->
        call 'Nova.Compiler.Ast':'ExprLambda'(BindParams, BindBody)
    end
      in {'Right', ю狒翦蝾Ы俱犰物鲠蔑眇殪弪馏臾骇嗅糁狎Ж麻钿吾礤┈鲠祯濮骄轴祯瀣豉疱令瞌骄赠疱令铨
      end
      <{'Guarded', _W0}> when 'true' ->
        {'Left', #{#<71>(8,1,'integer',['unsigned'|['big']]),#<117>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<119>(8,1,'integer',['unsigned'|['big']]),#<104>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<98>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<103>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<121>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<117>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']])}#}
    end
      end
      <{'Right', BindParams}> when 'true' ->
        case case apply 'lookupSig'/2(BindName, SigMap) of
      <'Nothing'> when 'true' ->
        {'Right', 'Nothing'}
      <{'Just', CstTy}> when 'true' ->
        case apply 'convertType'/1(CstTy) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Ty}> when 'true' ->
        {'Right', {'Just', Ty}}
      <{'Right', Ty}> when 'true' ->
        {'Right', {'Just', Ty}}
      end
    end of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', TypeAnn}> when 'true' ->
        case call 'maps':'get'('guarded', Vbf) of
      <{'Unconditional', _W0, Wh}> when 'true' ->
        case apply 'convertWhereExpr'/1(Wh) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', BindBody}> when 'true' ->
        let <Value> = case BindParams of
      <[]> when 'true' ->
        BindBody
      <_W0> when 'true' ->
        call 'Nova.Compiler.Ast':'ExprLambda'(BindParams, BindBody)
    end
      in {'Right', ю狒翦蝾Ы俱犰物鲠蔑眇殪弪馏臾骇嗅糁狎Ж麻钿吾礤┈鲠祯濮骄轴祯瀣豉疱令瞌骄赠疱令铨
      <{'Right', BindBody}> when 'true' ->
        let <Value> = case BindParams of
      <[]> when 'true' ->
        BindBody
      <_W0> when 'true' ->
        call 'Nova.Compiler.Ast':'ExprLambda'(BindParams, BindBody)
    end
      in {'Right', ю狒翦蝾Ы俱犰物鲠蔑眇殪弪馏臾骇嗅糁狎Ж麻钿吾礤┈鲠祯濮骄轴祯瀣豉疱令瞌骄赠疱令铨
      end
      <{'Guarded', _W0}> when 'true' ->
        {'Left', #{#<71>(8,1,'integer',['unsigned'|['big']]),#<117>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<119>(8,1,'integer',['unsigned'|['big']]),#<104>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<98>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<103>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<121>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<117>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']])}#}
    end
      <{'Right', TypeAnn}> when 'true' ->
        case call 'maps':'get'('guarded', Vbf) of
      <{'Unconditional', _W0, Wh}> when 'true' ->
        case apply 'convertWhereExpr'/1(Wh) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', BindBody}> when 'true' ->
        let <Value> = case BindParams of
      <[]> when 'true' ->
        BindBody
      <_W0> when 'true' ->
        call 'Nova.Compiler.Ast':'ExprLambda'(BindParams, BindBody)
    end
      in {'Right', ю狒翦蝾Ы俱犰物鲠蔑眇殪弪馏臾骇嗅糁狎Ж麻钿吾礤┈鲠祯濮骄轴祯瀣豉疱令瞌骄赠疱令铨
      <{'Right', BindBody}> when 'true' ->
        let <Value> = case BindParams of
      <[]> when 'true' ->
        BindBody
      <_W0> when 'true' ->
        call 'Nova.Compiler.Ast':'ExprLambda'(BindParams, BindBody)
    end
      in {'Right', ю狒翦蝾Ы俱犰物鲠蔑眇殪弪馏臾骇嗅糁狎Ж麻钿吾礤┈鲠祯濮骄轴祯瀣豉疱令瞌骄赠疱令铨
      end
      <{'Guarded', _W0}> when 'true' ->
        {'Left', #{#<71>(8,1,'integer',['unsigned'|['big']]),#<117>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<119>(8,1,'integer',['unsigned'|['big']]),#<104>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<98>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<103>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<121>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<117>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']])}#}
    end
      end
      end
      in let <SigMap> = apply 'collectSignatures'/1(Bindings)
      in let <ValueBindings> = call 'Data.List':'mapMaybe'(fun (_Mf0) -> apply 'getValueBinding'/1(_Mf0), Bindings)
      in apply 'traverse'/2(fun (_Pc0) -> apply 'convertLetBindWithSig'/2(SigMap, _Pc0), ValueBindings)

'convertGuardedExpr'/1 =
  fun (Ge) ->
    case apply 'convertPatternGuards'/1(call 'maps':'get'('patterns', Ge)) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Guards}> when 'true' ->
        case apply 'convertWhereExpr'/1(call 'maps':'get'('where', Ge)) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Body}> when 'true' ->
        {'Right', х踽蜾螫骄酋狎潴р镤Ы韭镤
      <{'Right', Body}> when 'true' ->
        {'Right', х踽蜾螫骄酋狎潴р镤Ы韭镤
      end
      <{'Right', Guards}> when 'true' ->
        case apply 'convertWhereExpr'/1(call 'maps':'get'('where', Ge)) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Body}> when 'true' ->
        {'Right', х踽蜾螫骄酋狎潴р镤Ы韭镤
      <{'Right', Body}> when 'true' ->
        {'Right', х踽蜾螫骄酋狎潴р镤Ы韭镤
      end
      end

'convertPatternGuards'/1 =
  fun (Sep) ->
    let <AllGuards> = [call 'maps':'get'('head', Sep) | call 'lists':'map'(fun (_L0) ->
      case {_L0} of
        <{{'Tuple', _W0, G}}> when 'true' -> G
      end, call 'maps':'get'('tail', Sep))]
      in apply 'traverse'/2(fun (_Mf0) -> apply 'convertPatternGuard'/1(_Mf0), AllGuards)

'convertPatternGuard'/1 =
  fun (Pg) ->
    case call 'maps':'get'('binder', Pg) of
      <'Nothing'> when 'true' ->
        case apply 'convertExpr'/1(call 'maps':'get'('expr', Pg)) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Expr}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'GuardExpr'(Expr)}
      <{'Right', Expr}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'GuardExpr'(Expr)}
      end
      <{'Just', {'Tuple', Binder, _W0}}> when 'true' ->
        case apply 'convertBinder'/1(Binder) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Pat}> when 'true' ->
        case apply 'convertExpr'/1(call 'maps':'get'('expr', Pg)) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Expr}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'GuardPat'(Pat, Expr)}
      <{'Right', Expr}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'GuardPat'(Pat, Expr)}
      end
      <{'Right', Pat}> when 'true' ->
        case apply 'convertExpr'/1(call 'maps':'get'('expr', Pg)) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Expr}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'GuardPat'(Pat, Expr)}
      <{'Right', Expr}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'GuardPat'(Pat, Expr)}
      end
      end
    end

'convertTypeSignature'/1 =
  fun (Labeled) ->
    let <Name> = apply 'unwrapIdent'/1(call 'maps':'get'('name', call 'maps':'get'('label', Labeled)))
      in case apply 'extractConstraints'/1(call 'maps':'get'('value', Labeled)) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', {'Tuple', Constraints, Ty}}> when 'true' ->
        case apply 'convertType'/1(Ty) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', TyExpr}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'DeclTypeSig'(ь犴濮骄吾礤豉疱轴蝮Ы聚莠с镱篝蜥轭趔Ы久镱篝蜥轭趔豉Ы驹砒痱见б殓梏К赠砒痱麒孱趄蹂б殓梏К汜祆物鲠蔑眇殪弪馏臾骇腻沆赠疱娱绉ь犴濮骄吾礤豉疱轴蝮Ы聚莠с镱篝蜥轭趔Ы久镱篝蜥轭趔豉Ы驹砒痱孱见б殓梏Кг躔戾К蔑铙趄衢铘蟋赠麒孱趄蹂汜箦狃痨с镱鲥螋赠疱Н报赠镦姬物翳轭绉麒孱趄蹂物翳轭绉见体骠К吲蝌麒孱趄蹂体骠К吲蝌见术篝К赠砒痱麒孱趄蹂б殓梏К汜祆物鲠蔑眇殪弪馏臾骇腻沆赠疱娱绉ь犴濮骄吾礤豉疱轴蝮Ы聚莠с镱篝蜥轭趔Ы久镱篝蜥轭趔豉Ы驹砒痱见б殓梏К赠砒痱麒孱趄蹂б殓梏К汜祆物鲠蔑眇殪弪馏臾骇腻沆赠疱娱绉ь犴濮骄吾礤豉疱轴蝮Ы聚莠с镱篝蜥轭趔Ы久镱篝蜥轭趔豉Ы驹砒痱孱孱у趄徙裘镱篝蜥轭趔Н骢ㄔ汜箦赠镦见г疱蔑铙趄衢铄洄蔑铙趄衢铘咦艾义篝麒孱趄蹂汜箦狃痨с镱鲥螋蔑铙趄衢铘赠疱Н报蔑铙趄衢铘镦姬物翳轭绉麒孱趄蹂物翳轭绉见体骠К吲蝌麒孱趄蹂体骠К吲蝌见术篝К谬麒孱趄蹂汜箦狃痨у趄徙裘镱篝蜥轭趔Н报义篝镦姬物翳轭绉麒孱趄蹂物翳轭绉见体骠К吲蝌麒孱趄蹂体骠К吲蝌见术篝Кг躔戾К义篝皿义篝赠麒孱趄蹂б殓梏К汜祆尼翎怎痨濮骇怎痨濮ㄛ义篝皿莠义篝赠见б殓梏Кг躔戾К义篝皿义篝赠麒孱趄蹂б殓梏К汜祆尼翎怎痨濮骇怎痨濮ㄛ义篝皿莠义篝赠孱见б殓梏К谬麒孱趄蹂汜箦狃痨у趄徙裘镱篝蜥轭趔Н报义篝镦姬物翳轭绉麒孱趄蹂物翳轭绉见体骠К吲蝌麒孱趄蹂体骠К吲蝌见术篝Кг躔戾К义篝皿义篝赠麒孱趄蹂б殓梏К汜祆尼翎怎痨濮骇怎痨濮ㄛ义篝皿莠义篝赠见б殓梏Кг躔戾К义篝皿义篝赠麒孱趄蹂б殓梏К汜祆尼翎怎痨濮骇怎痨濮ㄛ义篝皿莠义篝赠孱孱歼装麒孱趄蹂б殓梏К汜祆尼翎怎痨濮骇怎痨濮ㄛ莠赠孱с镱鲥螋蔑铙趄衢铘赠疱Н骢ㄔ汜箦赠镦见г疱蔑铙趄蹉麸颛杨麒孱趄蹂戾济灬篌吾礤狃痨躅黩狃序镳弪Н报汜祆ы狃螫骇珏臾ě钺礤К杨┅轭б殓梏Кс灬篌吾礤Ы久灬篌吾礤豉疱螫骄圯
      <{'TypeApp', {'TypeConstructor', Qn}, Args}> when 'true' ->
        let <ClassName> = apply 'unwrapProper'/1(call 'maps':'get'('name', Qn))
      in case apply 'traverse'/2(fun (_Mf0) -> apply 'convertType'/1(_Mf0), Args) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Types}> when 'true' ->
        {'Right', с灬篌吾礤Ы久灬篌吾礤豉疱螫骄赠疱簖
      <{'Right', Types}> when 'true' ->
        {'Right', с灬篌吾礤Ы久灬篌吾礤豉疱螫骄赠疱簖
      end
      <_W0> when 'true' ->
        {'Left', #{#<73>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<118>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<108>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<99>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<121>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']])}#}
    end

'convertFixity'/1 =
  fun (Fields) ->
    let <Assoc> = case apply 'snd'/1(call 'maps':'get'('keyword', Fields)) of
      <'Infix'> when 'true' ->
        call 'Nova.Compiler.Ast':'AssocNone'()
      <'Infixl'> when 'true' ->
        call 'Nova.Compiler.Ast':'AssocLeft'()
      <'Infixr'> when 'true' ->
        call 'Nova.Compiler.Ast':'AssocRight'()
    end
      in let <Prec> = apply 'snd'/1(call 'maps':'get'('prec', Fields))
      in case call 'maps':'get'('operator', Fields) of
      <{'FixityValue', Qn, _W0, OpName}> when 'true' ->
        let <FunctionName> = case call 'maps':'get'('name', Qn) of
      <{'Left', Ident}> when 'true' ->
        apply 'unwrapIdent'/1(Ident)
      <{'Right', Proper}> when 'true' ->
        apply 'unwrapProper'/1(Proper)
    end
      in let <Operator> = apply 'unwrapOperator'/1(call 'maps':'get'('name', OpName))
      in {'Right', call 'Nova.Compiler.Ast':'DeclInfix'(п篌镢獒糸鲩豉Ы玖篌镢ю蝈沐溴钽濮骄序邈ф躅泗轱钗犴濮骄契钽糸镱吾礤э疱蜥麸颛骄橡弪狒矧见崎轸赠疱К咦艾杨咦爆橡吾礤麒孱趄蹂戾计躅泗轱钗犴寰狃痨躅黩狃序镳弪Н报汜祆ы狃螫骇珏臾ě钺礤К杨┅轭戾枷疱蜥麸蚓狃痨躅黩狃橡弪狒矧Н报汜祆ы狃螫骇珏臾ě钺礤К橡吾礤┅轭б殓梏К汜祆物鲠蔑眇殪弪馏臾骇腻沆深骈Жп篌镢獒糸鲩豉Ы玖篌镢ю蝈沐溴钽濮骄序邈ф躅泗轱钗犴濮骄契钽糸镱吾礤э疱蜥麸颛骄橡弪狒矧孱с镱鲥螋骑蝈殓瞌骢ㄆ矧彘珙擤汜箦骑蝈殓钸镦见骑蝈殓钪犰蹂К提忮戾潺麒孱趄蹂戾计躅泗轱钗犴寰狃痨躅黩狃射孱臾报汜祆ы狃螫骇珏臾ě钺礤К汜祆ы狃螫骇珏臾ě灬忮歆提忮戾洎┅轭汜箦狃痨с镱鲥螋赠疱Н报汜祆ы狃螫骇珏臾ě鲠祯濮提忮戾洎镦姬物翳轭绉麒孱趄蹂物翳轭绉见体骠К吲蝌麒孱趄蹂体骠К吲蝌见术篝К赠麒孱趄蹂б殓梏К汜祆物鲠蔑眇殪弪馏臾骇腻沆骑蝈殓钌眇矧臾ы镤蹯逦犴濮骄｛，ф躅泗轱钗犴濮骄契钽糸镱吾礤п扉狍Ы晶物翳轭绉豉疱娱珙狒躜濮骄赠ч铎轭迳眇歆骄物翳轭绉见б殓梏К赠麒孱趄蹂б殓梏К汜祆物鲠蔑眇殪弪馏臾骇腻沆骑蝈殓钌眇矧臾ы镤蹯逦犴濮骄｛，ф躅泗轱钗犴濮骄契钽糸镱吾礤п扉狍Ы晶物翳轭绉豉疱娱珙狒躜濮骄赠ч铎轭迳眇歆骄物翳轭绉孱见骑蝈殓钪犰蹂深扉铄К提忮戾洮咦艾身痨麒孱趄蹂戾计躅泗轱钗犴寰狃痨躅黩狃射孱臾报汜祆ы狃螫骇珏臾ě钺礤К汜祆ы狃螫骇珏臾ě灬忮歆提忮戾洎┅轭汜箦狃痨с镱鲥螋赠疱Н报汜祆ы狃螫骇珏臾ě鲠祯濮提忮戾洎镦姬物翳轭绉麒孱趄蹂物翳轭绉见体骠К吲蝌麒孱趄蹂体骠К吲蝌见术篝К赠麒孱趄蹂б殓梏К汜祆物鲠蔑眇殪弪馏臾骇腻沆骑蝈殓钌眇矧臾ы镤蹯逦犴濮骄｛，ф躅泗轱钗犴濮骄契钽糸镱吾礤п扉狍Ы晶物翳轭绉豉疱娱珙狒躜濮骄赠ч铎轭迳眇歆骄术篝К身痨见б殓梏К赠麒孱趄蹂б殓梏К汜祆物鲠蔑眇殪弪馏臾骇腻沆骑蝈殓钌眇矧臾ы镤蹯逦犴濮骄｛，ф躅泗轱钗犴濮骄契钽糸镱吾礤п扉狍Ы晶物翳轭绉豉疱娱珙狒躜濮骄赠ч铎轭迳眇歆骄术篝К身痨孱见骑蝈殓钅狒岌咦艾提忮戾潺麒孱趄蹂戾嘉犴寰狃痨躅黩狃序镳弪Н报汜祆ы狃螫骇珏臾ě钺礤К汜祆ы狃螫骇珏臾ě灬忮歆提忮戾洎┅轭汜箦狃痨с镱鲥螋赠疱Н报汜祆ы狃螫骇珏臾ě鲠祯濮提忮戾洎镦姬物翳轭绉麒孱趄蹂物翳轭绉见体骠К吲蝌麒孱趄蹂体骠К吲蝌见术篝К赠麒孱趄蹂б殓梏К汜祆物鲠蔑眇殪弪馏臾骇腻沆赠疱领獒螫ь犴濮骄吾礤豉疱轴蝮Ы聚莠豉Ы驹见б殓梏К赠麒孱趄蹂б殓梏К汜祆物鲠蔑眇殪弪馏臾骇腻沆赠疱领獒螫ь犴濮骄吾礤豉疱轴蝮Ы聚莠豉Ы驹孱孱с镱鲥螋赠疱Н骢ㄔ汜箦赠镦见г疱轴颛吾礤麒孱趄蹂б殓梏К汜祆物鲠蔑眇殪弪馏臾骇赠砒痱轴颛ㄡ痧禊躅黩狃射孱臾报汜祆ы狃螫骇珏臾ě钺礤К吾礤┅见г疱蔑铙趄蹉麸颛杨麒孱趄蹂б殓梏К汜祆物鲠蔑眇殪弪馏臾骇赠砒痱蔑瞌ㄡ痧禊я踽扉骈邃序镳弪吾礤Н报杨┅见г疱组熹汜蜾К咦褒麒孱趄蹂б殓梏К汜祆物鲠蔑眇殪弪馏臾骇赠砒痱轴颛ǎ＜沟鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺）见г疱蕊戾К吾礤麒孱趄蹂б殓梏К汜祆物鲠蔑眇殪弪馏臾骇赠砒痱轴颛ㄣ犰物鲠序屐蹁濮骇箦黹珧秕鹆痧孱渖眇歆ǎ＜冻鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺，狃痨躅黩狃射孱臾报汜祆ы狃螫骇珏臾ě钺礤К吾礤┅┅见г疱郁蜷铉К咦艾育麒孱趄蹂б殓梏К汜祆物鲠蔑眇殪弪馏臾骇赠砒痱蔑瞌ㄣ犰物鲠序屐蹁濮骇箦黹珧秕鹆痧孱渖眇歆ㄣ犰物鲠序屐蹁濮骇箦黹珧秕鹆痧孱渖眇歆ǎ＜炒鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺，萤｛＜炒鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺）见г疱深臾咦艾咦饼麒孱趄蹂б殓梏К汜祆物鲠蔑眇殪弪馏臾骇赠砒痱蔑瞌ǎ＜烦鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北熬ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北毒ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺）见г疱绎鳔昨狃疱潺麒孱趄蹂汜箦狃痨с镱鲥螋绎鳔报汜祆ы狃螫骇珏臾ě鲠祯濮昨狃疱洎镦姬物翳轭绉麒孱趄蹂物翳轭绉见体骠К吲蝌麒孱趄蹂体骠К吲蝌见术篝К绎鼾麒孱趄蹂б殓梏К汜祆物鲠蔑眇殪弪馏臾骇赠砒痱义泔蜾Ж汜祆ы狃螫骇珏臾ě骈屐潴К绎鳗汜祆ы狃螫骇珏臾ě翎殪К绎鳗见б殓梏К绎鼾麒孱趄蹂б殓梏К汜祆物鲠蔑眇殪弪馏臾骇赠砒痱义泔蜾Ж汜祆ы狃螫骇珏臾ě骈屐潴К绎鳗汜祆ы狃螫骇珏臾ě翎殪К绎鳗孱见г疱义泔蜾К昨狃疱潺麒孱趄蹂汜箦狃痨с镱鲥螋绎鳔报汜祆ы狃螫骇珏臾ě鲠祯濮昨狃疱洎镦姬物翳轭绉麒孱趄蹂物翳轭绉见体骠К吲蝌麒孱趄蹂体骠К吲蝌见术篝К绎鼾麒孱趄蹂б殓梏К汜祆物鲠蔑眇殪弪馏臾骇赠砒痱义泔蜾Ж汜祆ы狃螫骇珏臾ě骈屐潴К绎鳗汜祆ы狃螫骇珏臾ě翎殪К绎鳗见б殓梏К绎鼾麒孱趄蹂б殓梏К汜祆物鲠蔑眇殪弪馏臾骇赠砒痱义泔蜾Ж汜祆ы狃螫骇珏臾ě骈屐潴К绎鳗汜祆ы狃螫骇珏臾ě翎殪К绎鳗孱见г疱骑蜥祆К咦艾轴蝮咦爆嘛澌麒孱趄蹂戾贾狎吾礤缶汜祆ъ轶趔Шы狃Ж骢ㄟ玩癌狃痨у趄徙粼疱轴颛报咄姘┈轴蝮轭汜箦狃痨с镱鲥螋赠疱Н报嘛澌镦姬物翳轭绉麒孱趄蹂物翳轭绉见体骠К吲蝌麒孱趄蹂体骠К吲蝌见术篝К嘛澌赠麒孱趄蹂б殓梏К汜祆物鲠蔑眇殪弪馏臾骇赠砒痱骑蛄祆Ж轴蛭犴弩嘛澌赠见б殓梏К嘛澌赠麒孱趄蹂б殓梏К汜祆物鲠蔑眇殪弪馏臾骇赠砒痱骑蛄祆Ж轴蛭犴弩嘛澌赠孱见г疱碎钿邃К袁咦艾咦饼麒孱趄蹂狃痨с镱鲥螋赠疱Н报冤见г疱琉皈儒徜硫珞麒孱趄蹂汜箦狃痨с镱鲥螋赠疱Н报儒徜镦姬物翳轭绉麒孱趄蹂物翳轭绉见体骠К吲蝌麒孱趄蹂体骠К吲蝌见术篝К儒徜赠麒孱趄蹂汜箦狃痨趄狯弪箦Н波骢ㄟ玩癌狃痨с镱鲥螋赠疱Н报咄姘┈硫珞镦姬物翳轭绉麒孱趄蹂物翳轭绉见体骠К吲蝌麒孱趄蹂体骠К吲蝌见术篝К硫缭簖麒孱趄蹂б殓梏К汜祆尼翎涕篝Шф镬潇Ж汜祆物鲠蔑眇殪弪馏臾骇赠砒痱琉皈ī儒徜赠硫缭螬见б殓梏К硫缭簖麒孱趄蹂б殓梏К汜祆尼翎涕篝Шф镬潇Ж汜祆物鲠蔑眇殪弪馏臾骇赠砒痱琉皈ī儒徜赠硫缭螬孱见б殓梏К儒徜赠麒孱趄蹂汜箦狃痨趄狯弪箦Н波骢ㄟ玩癌狃痨с镱鲥螋赠疱Н报咄姘┈硫珞镦姬物翳轭绉麒孱趄蹂物翳轭绉见体骠К吲蝌麒孱趄蹂体骠К吲蝌见术篝К硫缭簖麒孱趄蹂б殓梏К汜祆尼翎涕篝Шф镬潇Ж汜祆物鲠蔑眇殪弪馏臾骇赠砒痱琉皈ī儒徜赠硫缭螬见б殓梏К硫缭簖麒孱趄蹂б殓梏К汜祆尼翎涕篝Шф镬潇Ж汜祆物鲠蔑眇殪弪馏臾骇赠砒痱琉皈ī儒徜赠硫缭螬孱孱见г疱橡К儒徜橡簖麒孱趄蹂汜箦狃痨с镱鲥螋赠疱Н报儒徜镦姬物翳轭绉麒孱趄蹂物翳轭绉见体骠К吲蝌麒孱趄蹂体骠К吲蝌见术篝К儒徜赠麒孱趄蹂狃痨ф镬湓疱橡螫波儒徜赠橡螬见б殓梏К儒徜赠麒孱趄蹂狃痨ф镬湓疱橡螫波儒徜赠橡螬孱见г疱硫蝻鳔乞镯咦艾燥麒孱趄蹂汜箦狃痨с镱鲥螋赠疱Н报乞镯镦姬物翳轭绉麒孱趄蹂物翳轭绉见体骠К吲蝌麒孱趄蹂体骠К吲蝌见术篝К乞镯赠麒孱趄蹂汜箦狃痨с镱鲥螋赠疱Н报燥镦姬物翳轭绉麒孱趄蹂物翳轭绉见体骠К吲蝌麒孱趄蹂体骠К吲蝌见术篝К燥赠麒孱趄蹂б殓梏К汜祆物鲠蔑眇殪弪馏臾骇赠砒痱硫蝻鳔ㄆ蝻碓燥赠见б殓梏К燥赠麒孱趄蹂б殓梏К汜祆物鲠蔑眇殪弪馏臾骇赠砒痱硫蝻鳔ㄆ蝻碓燥赠孱见б殓梏К乞镯赠麒孱趄蹂汜箦狃痨с镱鲥螋赠疱Н报燥镦姬物翳轭绉麒孱趄蹂物翳轭绉见体骠К吲蝌麒孱趄蹂体骠К吲蝌见术篝К燥赠麒孱趄蹂б殓梏К汜祆物鲠蔑眇殪弪馏臾骇赠砒痱硫蝻鳔ㄆ蝻碓燥赠见б殓梏К燥赠麒孱趄蹂б殓梏К汜祆物鲠蔑眇殪弪馏臾骇赠砒痱硫蝻鳔ㄆ蝻碓燥赠孱孱见г疱蔑铙趄衢铄洄蔑铙趄衢铘咦艾嘛澌麒孱趄蹂汜箦狃痨с镱鲥螋蔑铙趄衢铘赠疱Н报蔑铙趄衢铘镦姬物翳轭绉麒孱趄蹂物翳轭绉见体骠К吲蝌麒孱趄蹂体骠К吲蝌见术篝К谬麒孱趄蹂汜箦狃痨с镱鲥螋赠疱Н报嘛澌镦姬物翳轭绉麒孱趄蹂物翳轭绉见体骠К吲蝌麒孱趄蹂体骠К吲蝌见术篝К嘛澌赠麒孱趄蹂б殓梏К汜祆物鲠蔑眇殪弪馏臾骇赠砒痱蔑铙趄衢铄洄ㄛ圯莠嘛澌赠见б殓梏К嘛澌赠麒孱趄蹂б殓梏К汜祆物鲠蔑眇殪弪馏臾骇赠砒痱蔑铙趄衢铄洄ㄛ圯莠嘛澌赠孱见б殓梏К谬麒孱趄蹂汜箦狃痨с镱鲥螋赠疱Н报嘛澌镦姬物翳轭绉麒孱趄蹂物翳轭绉见体骠К吲蝌麒孱趄蹂体骠К吲蝌见术篝К嘛澌赠麒孱趄蹂б殓梏К汜祆物鲠蔑眇殪弪馏臾骇赠砒痱蔑铙趄衢铄洄ㄛ圯莠嘛澌赠见б殓梏К嘛澌赠麒孱趄蹂б殓梏К汜祆物鲠蔑眇殪弪馏臾骇赠砒痱蔑铙趄衢铄洄ㄛ圯莠嘛澌赠孱孱见г疱嗅蝈铙К昨狃疱潺麒孱趄蹂汜箦狃痨с镱鲥螋赠疱Н报汜祆ы狃螫骇珏臾ě鲠祯濮昨狃疱洎镦姬物翳轭绉麒孱趄蹂物翳轭绉见体骠К吲蝌麒孱趄蹂体骠К吲蝌见术篝К深铄螨麒孱趄蹂б殓梏К汜祆物鲠蔑眇殪弪馏臾骇赠砒痱嗅蝈铙Ж深铄颟见б殓梏К深铄螨麒孱趄蹂б殓梏К汜祆物鲠蔑眇殪弪馏臾骇赠砒痱嗅蝈铙Ж深铄颟孱见г疱膨蝻颛咦褒麒孱趄蹂体骠К｛＜斗鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜狗鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北熬ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北熬ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北毒ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜巢鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜构鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北熬ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北妇ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北淳ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北毒ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜巢鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北毒ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜辈本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北簿ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜巢鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北淳ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北淳ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北淳ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺｝孱ф镬湓疱橡螫骢零悻橡螬汜箦橡镦价菥麒孱趄蹂б殓梏К零泯价г躔戾К橡赠义篝菥麒孱趄蹂戾枷鹞犴寰狃痨躅黩狃橡弪狒矧Н报汜祆ы狃螫骇珏臾ě钺礤К橡┅轭汜箦狃痨с镱鲥螋赠疱Н报赠镦姬物翳轭绉麒孱趄蹂物翳轭绉见体骠К吲蝌麒孱趄蹂体骠К吲蝌见术篝К赠砒痱麒孱趄蹂戾济镯忾铄渚汜祆物鲠蔑眇殪弪馏臾骇赠砒痱琉皈ㄣ犰物鲠蔑眇殪弪馏臾骇赠砒痱琉皈ㄣ犰物鲠蔑眇殪弪馏臾骇赠砒痱蔑瞌ㄏ鹞犴濠零悌赠砒痱轭狃痨ф镬湓疱橡螫波蔑礅轭邃义篝见б殓梏К赠砒痱麒孱趄蹂戾济镯忾铄渚汜祆物鲠蔑眇殪弪馏臾骇赠砒痱琉皈ㄣ犰物鲠蔑眇殪弪馏臾骇赠砒痱琉皈ㄣ犰物鲠蔑眇殪弪馏臾骇赠砒痱蔑瞌ㄏ鹞犴濠零悌赠砒痱轭狃痨ф镬湓疱橡螫波蔑礅轭邃义篝孱孱с镱鲥螋绎鳔骢ㄒ秣汜箦汜箦汜祆ы狃螫骇珏臾ě灬忮祗К绎鳗镦姬物翳轭绉麒孱趄蹂б殓梏К圯见术篝К渝瘕麒孱趄蹂狃痨с镱鲥螋绎魈徕屐螫报渝皓孱镦姬物翳轭绉麒孱趄蹂物翳轭绉见体骠К吲蝌麒孱趄蹂体骠К吲蝌见术篝К崎屐潴麒孱趄蹂戾荚衢炀汜箦汜祆ы狃螫骇珏臾ě翎殪К绎鳗镦姬物翳轭绉麒孱趄蹂物翳轭绉见术篝Кг躔戾К咦艾赠麒孱趄蹂汜箦赠镦见г疱轴颛吾礤麒孱趄蹂术篝К狃痨躅黩狃射孱臾报汜祆ы狃螫骇珏臾ě钺礤К吾礤┅歼装麒孱趄蹂物翳轭绉孱孱轭б殓梏Кф殄熹螫骄崎屐潴翎殪Ы驹衢忑
      <{'Right', Fields}> when 'true' ->
        let <Tail> = case call 'maps':'get'('tail', Row) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Just', {'Tuple', _W0, Ty}}> when 'true' ->
        case Ty of
      <{'TypeVar', Name}> when 'true' ->
        {'Just', apply 'unwrapIdent'/1(call 'maps':'get'('name', Name))}
      <_W0> when 'true' ->
        'Nothing'
    end
    end
      in {'Right', ф殄熹螫骄崎屐潴翎殪Ы驹衢忑
      end

'convertRowLabels'/1 =
  fun (Sep) ->
    let <AllLabels> = [call 'maps':'get'('head', Sep) | call 'lists':'map'(fun (_L0) ->
      case {_L0} of
        <{{'Tuple', _W0, L}}> when 'true' -> L
      end, call 'maps':'get'('tail', Sep))]
      in apply 'traverse'/2(fun (_Mf0) -> apply 'convertRowLabel'/1(_Mf0), AllLabels)

'convertRowLabel'/1 =
  fun (Labeled) ->
    let <Label> = apply 'unwrapLabel'/1(call 'maps':'get'('name', call 'maps':'get'('label', Labeled)))
      in case apply 'convertType'/1(call 'maps':'get'('value', Labeled)) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Ty}> when 'true' ->
        {'Right', call 'Data.Tuple':'Tuple'(Label, Ty)}
      <{'Right', Ty}> when 'true' ->
        {'Right', call 'Data.Tuple':'Tuple'(Label, Ty)}
      end

'convertExpr'/1 =
  fun (Expr) ->
    case Expr of
      <{'ExprHole', Name}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'ExprVar'(apply 'unwrapIdent'/1(call 'maps':'get'('name', Name)))}
      <{'ExprSection', _W0}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'ExprSection'(#{#<95>(8,1,'integer',['unsigned'|['big']])}#)}
      <{'ExprIdent', Qn}> when 'true' ->
        case call 'maps':'get'('module', Qn) of
      <'Nothing'> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'ExprVar'(apply 'unwrapIdent'/1(call 'maps':'get'('name', Qn)))}
      <{'Just', ModName}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'ExprQualified'(apply 'unwrapModuleName'/1(ModName), apply 'unwrapIdent'/1(call 'maps':'get'('name', Qn)))}
    end
      <{'ExprConstructor', Qn}> when 'true' ->
        case call 'maps':'get'('module', Qn) of
      <'Nothing'> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'ExprVar'(apply 'unwrapProper'/1(call 'maps':'get'('name', Qn)))}
      <{'Just', ModName}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'ExprQualified'(apply 'unwrapModuleName'/1(ModName), apply 'unwrapProper'/1(call 'maps':'get'('name', Qn)))}
    end
      <{'ExprBoolean', _W0, B}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'ExprLit'(call 'Nova.Compiler.Ast':'LitBool'(B))}
      <{'ExprChar', _W0, C}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'ExprLit'(call 'Nova.Compiler.Ast':'LitChar'(C))}
      <{'ExprString', _W0, S}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'ExprLit'(call 'Nova.Compiler.Ast':'LitString'(S))}
      <{'ExprInt', _W0, IntVal}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'ExprLit'(call 'Nova.Compiler.Ast':'LitInt'(apply 'intValueToInt'/1(IntVal)))}
      <{'ExprNumber', _W0, N}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'ExprLit'(call 'Nova.Compiler.Ast':'LitNumber'(N))}
      <{'ExprArray', Del}> when 'true' ->
        case case call 'maps':'get'('value', Del) of
      <'Nothing'> when 'true' ->
        {'Right', []}
      <{'Just', Sep}> when 'true' ->
        let <AllItems> = [call 'maps':'get'('head', Sep) | call 'lists':'map'(fun (_L0) ->
      case {_L0} of
        <{{'Tuple', _W0, E}}> when 'true' -> E
      end, call 'maps':'get'('tail', Sep))]
      in apply 'traverse'/2(fun (_Mf0) -> apply 'convertExpr'/1(_Mf0), AllItems)
    end of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Items}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'ExprList'(Items)}
      <{'Right', Items}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'ExprList'(Items)}
      end
      <{'ExprRecord', Del}> when 'true' ->
        case case call 'maps':'get'('value', Del) of
      <'Nothing'> when 'true' ->
        {'Right', []}
      <{'Just', Sep}> when 'true' ->
        let <AllFields> = [call 'maps':'get'('head', Sep) | call 'lists':'map'(fun (_L0) ->
      case {_L0} of
        <{{'Tuple', _W0, F}}> when 'true' -> F
      end, call 'maps':'get'('tail', Sep))]
      in apply 'traverse'/2(fun (_Mf0) -> apply 'convertRecordField'/1(_Mf0), AllFields)
    end of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Fields}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'ExprRecord'(Fields)}
      <{'Right', Fields}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'ExprRecord'(Fields)}
      end
      <{'ExprParens', Wrapped}> when 'true' ->
        case apply 'convertExpr'/1(call 'maps':'get'('value', Wrapped)) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Inner}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'ExprParens'(Inner)}
      <{'Right', Inner}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'ExprParens'(Inner)}
      end
      <{'ExprTyped', E, _W0, Ty}> when 'true' ->
        case apply 'convertExpr'/1(E) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Expr_}> when 'true' ->
        case apply 'convertType'/1(Ty) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', TyExpr}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'ExprTyped'(Expr_, TyExpr)}
      <{'Right', TyExpr}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'ExprTyped'(Expr_, TyExpr)}
      end
      <{'Right', Expr_}> when 'true' ->
        case apply 'convertType'/1(Ty) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', TyExpr}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'ExprTyped'(Expr_, TyExpr)}
      <{'Right', TyExpr}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'ExprTyped'(Expr_, TyExpr)}
      end
      end
      <{'ExprInfix', Head, Ops}> when 'true' ->
        case apply 'convertExpr'/1(Head) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', HeadE}> when 'true' ->
        apply 'foldInfixOps'/2(HeadE, Ops)
      <{'Right', HeadE}> when 'true' ->
        apply 'foldInfixOps'/2(HeadE, Ops)
      end
      <{'ExprOp', Head, Ops}> when 'true' ->
        case apply 'convertExpr'/1(Head) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', HeadE}> when 'true' ->
        apply 'foldBinOps'/2(HeadE, Ops)
      <{'Right', HeadE}> when 'true' ->
        apply 'foldBinOps'/2(HeadE, Ops)
      end
      <{'ExprOpName', Qn}> when 'true' ->
        case call 'maps':'get'('module', Qn) of
      <'Nothing'> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'ExprVar'(apply 'unwrapOperator'/1(call 'maps':'get'('name', Qn)))}
      <{'Just', ModName}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'ExprQualified'(apply 'unwrapModuleName'/1(ModName), apply 'unwrapOperator'/1(call 'maps':'get'('name', Qn)))}
    end
      <{'ExprNegate', _W0, E}> when 'true' ->
        case apply 'convertExpr'/1(E) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Inner}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'ExprUnaryOp'(#{#<45>(8,1,'integer',['unsigned'|['big']])}#, Inner)}
      <{'Right', Inner}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'ExprUnaryOp'(#{#<45>(8,1,'integer',['unsigned'|['big']])}#, Inner)}
      end
      <{'ExprRecordAccessor', Acc}> when 'true' ->
        case apply 'convertExpr'/1(call 'maps':'get'('expr', Acc)) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Base}> when 'true' ->
        let <Path> = [call 'maps':'get'('head', call 'maps':'get'('path', Acc)) | call 'lists':'map'(fun (_L0) ->
      case {_L0} of
        <{{'Tuple', _W0, L}}> when 'true' -> L
      end, call 'maps':'get'('tail', call 'maps':'get'('path', Acc)))]
      in let <Labels> = call 'lists':'map'(fun (L) ->
      apply 'unwrapLabel'/1(call 'maps':'get'('name', L)), Path)
      in case Labels of
      <[FirstLabel | Rest]> when 'true' ->
        {'Right', call 'Data.List':'foldl'(call 'Nova.Compiler.Ast':'ExprRecordAccess'(), call 'Nova.Compiler.Ast':'ExprRecordAccess'(Base, FirstLabel), Rest)}
      <[]> when 'true' ->
        {'Left', #{#<69>(8,1,'integer',['unsigned'|['big']]),#<109>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<121>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<99>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<99>(8,1,'integer',['unsigned'|['big']]),#<99>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<104>(8,1,'integer',['unsigned'|['big']])}#}
    end
      <{'Right', Base}> when 'true' ->
        let <Path> = [call 'maps':'get'('head', call 'maps':'get'('path', Acc)) | call 'lists':'map'(fun (_L0) ->
      case {_L0} of
        <{{'Tuple', _W0, L}}> when 'true' -> L
      end, call 'maps':'get'('tail', call 'maps':'get'('path', Acc)))]
      in let <Labels> = call 'lists':'map'(fun (L) ->
      apply 'unwrapLabel'/1(call 'maps':'get'('name', L)), Path)
      in case Labels of
      <[FirstLabel | Rest]> when 'true' ->
        {'Right', call 'Data.List':'foldl'(call 'Nova.Compiler.Ast':'ExprRecordAccess'(), call 'Nova.Compiler.Ast':'ExprRecordAccess'(Base, FirstLabel), Rest)}
      <[]> when 'true' ->
        {'Left', #{#<69>(8,1,'integer',['unsigned'|['big']]),#<109>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<121>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<99>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<99>(8,1,'integer',['unsigned'|['big']]),#<99>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<104>(8,1,'integer',['unsigned'|['big']])}#}
    end
      end
      <{'ExprRecordUpdate', Base, Updates}> when 'true' ->
        case apply 'convertExpr'/1(Base) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', BaseE}> when 'true' ->
        let <AllUpdates> = [call 'maps':'get'('head', call 'maps':'get'('value', Updates)) | call 'lists':'map'(fun (_L0) ->
      case {_L0} of
        <{{'Tuple', _W0, U}}> when 'true' -> U
      end, call 'maps':'get'('tail', call 'maps':'get'('value', Updates)))]
      in case apply 'traverse'/2(fun (_Mf0) -> apply 'convertRecordUpdate'/1(_Mf0), AllUpdates) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', UpdateFields}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'ExprRecordUpdate'(BaseE, UpdateFields)}
      <{'Right', UpdateFields}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'ExprRecordUpdate'(BaseE, UpdateFields)}
      end
      <{'Right', BaseE}> when 'true' ->
        let <AllUpdates> = [call 'maps':'get'('head', call 'maps':'get'('value', Updates)) | call 'lists':'map'(fun (_L0) ->
      case {_L0} of
        <{{'Tuple', _W0, U}}> when 'true' -> U
      end, call 'maps':'get'('tail', call 'maps':'get'('value', Updates)))]
      in case apply 'traverse'/2(fun (_Mf0) -> apply 'convertRecordUpdate'/1(_Mf0), AllUpdates) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', UpdateFields}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'ExprRecordUpdate'(BaseE, UpdateFields)}
      <{'Right', UpdateFields}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'ExprRecordUpdate'(BaseE, UpdateFields)}
      end
      end
      <{'ExprApp', Head, Args}> when 'true' ->
        case apply 'convertExpr'/1(Head) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', HeadE}> when 'true' ->
        case apply 'traverse'/2(fun (_Mf0) -> apply 'convertExpr'/1(_Mf0), Args) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', ArgEs}> when 'true' ->
        {'Right', call 'Data.List':'foldl'(call 'Nova.Compiler.Ast':'ExprApp'(), HeadE, ArgEs)}
      <{'Right', ArgEs}> when 'true' ->
        {'Right', call 'Data.List':'foldl'(call 'Nova.Compiler.Ast':'ExprApp'(), HeadE, ArgEs)}
      end
      <{'Right', HeadE}> when 'true' ->
        case apply 'traverse'/2(fun (_Mf0) -> apply 'convertExpr'/1(_Mf0), Args) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', ArgEs}> when 'true' ->
        {'Right', call 'Data.List':'foldl'(call 'Nova.Compiler.Ast':'ExprApp'(), HeadE, ArgEs)}
      <{'Right', ArgEs}> when 'true' ->
        {'Right', call 'Data.List':'foldl'(call 'Nova.Compiler.Ast':'ExprApp'(), HeadE, ArgEs)}
      end
      end
      <{'ExprLambda', Lam}> when 'true' ->
        case apply 'traverse'/2(fun (_Mf0) -> apply 'convertBinder'/1(_Mf0), call 'maps':'get'('binders', Lam)) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Params}> when 'true' ->
        case apply 'convertExpr'/1(call 'maps':'get'('body', Lam)) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Body}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'ExprLambda'(Params, Body)}
      <{'Right', Body}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'ExprLambda'(Params, Body)}
      end
      <{'Right', Params}> when 'true' ->
        case apply 'convertExpr'/1(call 'maps':'get'('body', Lam)) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Body}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'ExprLambda'(Params, Body)}
      <{'Right', Body}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'ExprLambda'(Params, Body)}
      end
      end
      <{'ExprIf', Ite}> when 'true' ->
        case apply 'convertExpr'/1(call 'maps':'get'('cond', Ite)) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', CondE}> when 'true' ->
        case apply 'convertExpr'/1(call 'maps':'get'('thenBranch', Ite)) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', ThenE}> when 'true' ->
        case apply 'convertExpr'/1(call 'maps':'get'('elseBranch', Ite)) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', ElseE}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'ExprIf'(CondE, ThenE, ElseE)}
      <{'Right', ElseE}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'ExprIf'(CondE, ThenE, ElseE)}
      end
      <{'Right', ThenE}> when 'true' ->
        case apply 'convertExpr'/1(call 'maps':'get'('elseBranch', Ite)) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', ElseE}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'ExprIf'(CondE, ThenE, ElseE)}
      <{'Right', ElseE}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'ExprIf'(CondE, ThenE, ElseE)}
      end
      end
      <{'Right', CondE}> when 'true' ->
        case apply 'convertExpr'/1(call 'maps':'get'('thenBranch', Ite)) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', ThenE}> when 'true' ->
        case apply 'convertExpr'/1(call 'maps':'get'('elseBranch', Ite)) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', ElseE}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'ExprIf'(CondE, ThenE, ElseE)}
      <{'Right', ElseE}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'ExprIf'(CondE, ThenE, ElseE)}
      end
      <{'Right', ThenE}> when 'true' ->
        case apply 'convertExpr'/1(call 'maps':'get'('elseBranch', Ite)) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', ElseE}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'ExprIf'(CondE, ThenE, ElseE)}
      <{'Right', ElseE}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'ExprIf'(CondE, ThenE, ElseE)}
      end
      end
      end
      <{'ExprCase', CaseOf}> when 'true' ->
        let <AllHeads> = [call 'maps':'get'('head', call 'maps':'get'('head', CaseOf)) | call 'lists':'map'(fun (_L0) ->
      case {_L0} of
        <{{'Tuple', _W0, E}}> when 'true' -> E
      end, call 'maps':'get'('tail', call 'maps':'get'('head', CaseOf)))]
      in case AllHeads of
      <[Single | []]> when 'true' ->
        case apply 'isUnderscore'/1(Single) of
      <'true'> when 'true' -> case apply 'traverse'/2(fun (_Mf0) -> apply 'convertCaseBranch'/1(_Mf0), call 'maps':'get'('branches', CaseOf)) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Clauses}> when 'true' ->
        let <LamParam> = call 'Nova.Compiler.Ast':'PatVar'(#{#<108>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<109>(8,1,'integer',['unsigned'|['big']]),#<99>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<95>(8,1,'integer',['unsigned'|['big']]),#<95>(8,1,'integer',['unsigned'|['big']])}#)
      in let <LamBody> = call 'Nova.Compiler.Ast':'ExprCase'(call 'Nova.Compiler.Ast':'ExprVar'(#{#<108>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<109>(8,1,'integer',['unsigned'|['big']]),#<99>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<95>(8,1,'integer',['unsigned'|['big']]),#<95>(8,1,'integer',['unsigned'|['big']])}#), Clauses)
      in {'Right', call 'Nova.Compiler.Ast':'ExprLambda'([LamParam | []], LamBody)}
      <{'Right', Clauses}> when 'true' ->
        let <LamParam> = call 'Nova.Compiler.Ast':'PatVar'(#{#<108>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<109>(8,1,'integer',['unsigned'|['big']]),#<99>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<95>(8,1,'integer',['unsigned'|['big']]),#<95>(8,1,'integer',['unsigned'|['big']])}#)
      in let <LamBody> = call 'Nova.Compiler.Ast':'ExprCase'(call 'Nova.Compiler.Ast':'ExprVar'(#{#<108>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<109>(8,1,'integer',['unsigned'|['big']]),#<99>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<95>(8,1,'integer',['unsigned'|['big']]),#<95>(8,1,'integer',['unsigned'|['big']])}#), Clauses)
      in {'Right', call 'Nova.Compiler.Ast':'ExprLambda'([LamParam | []], LamBody)}
      end
      <'false'> when 'true' -> case apply 'convertExpr'/1(Single) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', HeadE}> when 'true' ->
        case apply 'traverse'/2(fun (_Mf0) -> apply 'convertCaseBranch'/1(_Mf0), call 'maps':'get'('branches', CaseOf)) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Clauses}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'ExprCase'(HeadE, Clauses)}
      <{'Right', Clauses}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'ExprCase'(HeadE, Clauses)}
      end
      <{'Right', HeadE}> when 'true' ->
        case apply 'traverse'/2(fun (_Mf0) -> apply 'convertCaseBranch'/1(_Mf0), call 'maps':'get'('branches', CaseOf)) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Clauses}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'ExprCase'(HeadE, Clauses)}
      <{'Right', Clauses}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'ExprCase'(HeadE, Clauses)}
      end
      end
    end
      <Multiple> when 'true' ->
        case apply 'traverse'/2(fun (_Mf0) -> apply 'convertExpr'/1(_Mf0), Multiple) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Es}> when 'true' ->
        case apply 'traverse'/2(fun (_Mf0) -> apply 'convertCaseBranch'/1(_Mf0), call 'maps':'get'('branches', CaseOf)) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Clauses}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'ExprCase'(call 'Nova.Compiler.Ast':'ExprTuple'(Es), Clauses)}
      <{'Right', Clauses}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'ExprCase'(call 'Nova.Compiler.Ast':'ExprTuple'(Es), Clauses)}
      end
      <{'Right', Es}> when 'true' ->
        case apply 'traverse'/2(fun (_Mf0) -> apply 'convertCaseBranch'/1(_Mf0), call 'maps':'get'('branches', CaseOf)) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Clauses}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'ExprCase'(call 'Nova.Compiler.Ast':'ExprTuple'(Es), Clauses)}
      <{'Right', Clauses}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'ExprCase'(call 'Nova.Compiler.Ast':'ExprTuple'(Es), Clauses)}
      end
      end
    end
      <{'ExprLet', LetIn}> when 'true' ->
        case apply 'convertLetBindings'/1(call 'maps':'get'('bindings', LetIn)) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Bindings}> when 'true' ->
        case apply 'convertExpr'/1(call 'maps':'get'('body', LetIn)) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Body}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'ExprLet'(Bindings, Body)}
      <{'Right', Body}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'ExprLet'(Bindings, Body)}
      end
      <{'Right', Bindings}> when 'true' ->
        case apply 'convertExpr'/1(call 'maps':'get'('body', LetIn)) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Body}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'ExprLet'(Bindings, Body)}
      <{'Right', Body}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'ExprLet'(Bindings, Body)}
      end
      end
      <{'ExprDo', DoBlock}> when 'true' ->
        case apply 'traverse'/2(fun (_Mf0) -> apply 'convertDoStatement'/1(_Mf0), call 'maps':'get'('statements', DoBlock)) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Stmts}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'ExprDo'(Stmts)}
      <{'Right', Stmts}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'ExprDo'(Stmts)}
      end
      <{'ExprAdo', AdoBlock}> when 'true' ->
        case apply 'traverse'/2(fun (_Mf0) -> apply 'convertDoStatement'/1(_Mf0), call 'maps':'get'('statements', AdoBlock)) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Stmts}> when 'true' ->
        case apply 'convertExpr'/1(call 'maps':'get'('result', AdoBlock)) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Result}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'ExprDo'(call 'Nova.Prelude':'semigroupAppendImpl'(Stmts, [call 'Nova.Compiler.Ast':'DoExpr'(Result) | []]))}
      <{'Right', Result}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'ExprDo'(call 'Nova.Prelude':'semigroupAppendImpl'(Stmts, [call 'Nova.Compiler.Ast':'DoExpr'(Result) | []]))}
      end
      <{'Right', Stmts}> when 'true' ->
        case apply 'convertExpr'/1(call 'maps':'get'('result', AdoBlock)) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Result}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'ExprDo'(call 'Nova.Prelude':'semigroupAppendImpl'(Stmts, [call 'Nova.Compiler.Ast':'DoExpr'(Result) | []]))}
      <{'Right', Result}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'ExprDo'(call 'Nova.Prelude':'semigroupAppendImpl'(Stmts, [call 'Nova.Compiler.Ast':'DoExpr'(Result) | []]))}
      end
      end
      <{'ExprError', _W0}> when 'true' ->
        {'Left', #{#<67>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<99>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<118>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<120>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']])}#}
    end

'foldBinOps'/2 =
  fun (FirstExpr, Ops) ->
    case apply 'convertOpList'/1(Ops) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Converted}> when 'true' ->
        apply 'shuntingYard'/2(FirstExpr, Converted)
      <{'Right', Converted}> when 'true' ->
        apply 'shuntingYard'/2(FirstExpr, Converted)
      end

'convertOpList'/1 =
  fun (Ops) ->
    case Ops of
      <[]> when 'true' ->
        {'Right', []}
      <[{'Tuple', Op, E} | Rest]> when 'true' ->
        let <OpName> = apply 'unwrapOperator'/1(call 'maps':'get'('name', Op))
      in case apply 'convertExpr'/1(E) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', ExprE}> when 'true' ->
        case apply 'convertOpList'/1(Rest) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', RestConverted}> when 'true' ->
        {'Right', [call 'Data.Tuple':'Tuple'(OpName, ExprE) | RestConverted]}
      <{'Right', RestConverted}> when 'true' ->
        {'Right', [call 'Data.Tuple':'Tuple'(OpName, ExprE) | RestConverted]}
      end
      <{'Right', ExprE}> when 'true' ->
        case apply 'convertOpList'/1(Rest) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', RestConverted}> when 'true' ->
        {'Right', [call 'Data.Tuple':'Tuple'(OpName, ExprE) | RestConverted]}
      <{'Right', RestConverted}> when 'true' ->
        {'Right', [call 'Data.Tuple':'Tuple'(OpName, ExprE) | RestConverted]}
      end
      end
    end

'shuntingYard'/2 =
  fun (FirstExpr, Ops) ->
    letrec 'go'/3 = fun (_L0, _L1, _L2) ->
      case {_L0, _L1, _L2} of
        <{Output, OpStack, []}> when 'true' -> apply 'reduceAll'/2(Output, OpStack)
        <{Output, OpStack, [{'Tuple', Op, Expr} | Rest]}> when 'true' -> let <NewPrec> = apply 'operatorPrecedence'/1(Op)
      in let <IsRightAssoc> = apply 'operatorIsRightAssoc'/1(Op)
      in case apply 'popHigherPrec'/4(Output, OpStack, NewPrec, IsRightAssoc) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Result}> when 'true' ->
        let <NewOutput> = call 'maps':'get'('output', Result)
      in let <NewOpStack> = call 'maps':'get'('opStack', Result)
      in apply 'go'/3([Expr | NewOutput], [Op | NewOpStack], Rest)
      <{'Right', Result}> when 'true' ->
        let <NewOutput> = call 'maps':'get'('output', Result)
      in let <NewOpStack> = call 'maps':'get'('opStack', Result)
      in apply 'go'/3([Expr | NewOutput], [Op | NewOpStack], Rest)
      end
      end
       'popHigherPrec'/4 = fun (Output, OpStack, Prec, IsRightAssoc) ->
      case OpStack of
      <[]> when 'true' ->
        {'Right', э豸瘐臾骄硝麴豸э鹩翎汶Ы鞠鹩翎汶
      <[TopOp | RestOps]> when 'true' ->
        let <TopPrec> = apply 'operatorPrecedence'/1(TopOp)
      in let <ShouldPop> = case IsRightAssoc of
      <'true'> when 'true' -> call 'erlang':'>'(TopPrec, Prec)
      <'false'> when 'true' -> call 'erlang':'>='(TopPrec, Prec)
    end
      in case ShouldPop of
      <'true'> when 'true' -> case Output of
      <[Right | [Left | RestOutput]]> when 'true' ->
        let <Combined> = apply 'makeBinOpOrSection'/3(TopOp, Left, Right)
      in apply 'popHigherPrec'/4([Combined | RestOutput], RestOps, Prec, IsRightAssoc)
      <_W0> when 'true' ->
        {'Left', #{#<78>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<117>(8,1,'integer',['unsigned'|['big']]),#<103>(8,1,'integer',['unsigned'|['big']]),#<104>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<102>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']])}#}
    end
      <'false'> when 'true' -> {'Right', э豸瘐臾骄硝麴豸э鹩翎汶Ы鞠鹩翎汶
    end
    end
       'reduceAll'/2 = fun (_L0, _L1) ->
      case {_L0, _L1} of
        <{Output, []}> when 'true' -> case Output of
      <[Result | []]> when 'true' ->
        {'Right', Result}
      <_W0> when 'true' ->
        {'Left', #{#<73>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<118>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<108>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<120>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<58>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<109>(8,1,'integer',['unsigned'|['big']]),#<117>(8,1,'integer',['unsigned'|['big']]),#<108>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']]),#<108>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<118>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<108>(8,1,'integer',['unsigned'|['big']]),#<117>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<109>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<103>(8,1,'integer',['unsigned'|['big']])}#}
    end
        <{Output, [Op | RestOps]}> when 'true' -> case Output of
      <[Right | [Left | RestOutput]]> when 'true' ->
        let <Combined> = apply 'makeBinOpOrSection'/3(Op, Left, Right)
      in apply 'reduceAll'/2([Combined | RestOutput], RestOps)
      <_W0> when 'true' ->
        {'Left', #{#<78>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<117>(8,1,'integer',['unsigned'|['big']]),#<103>(8,1,'integer',['unsigned'|['big']]),#<104>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<102>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']])}#}
    end
      end
      in apply 'go'/3([FirstExpr | []], [], Ops)

'makeBinOpOrSection'/3 =
  fun (Op, Left, Right) ->
    case Left of
      <{'ExprSection', #{#<95>(8,1,'integer',['unsigned'|['big']])}#}> when 'true' ->
        call 'Nova.Compiler.Ast':'ExprSectionRight'(Op, Right)
      <_W0> when 'true' ->
        case Right of
      <{'ExprSection', #{#<95>(8,1,'integer',['unsigned'|['big']])}#}> when 'true' ->
        call 'Nova.Compiler.Ast':'ExprSectionLeft'(Left, Op)
      <_W0> when 'true' ->
        call 'Nova.Compiler.Ast':'ExprBinOp'(Op, Left, Right)
    end
    end

'foldInfixOps'/2 =
  fun (Acc, Ops) ->
    case Ops of
      <[]> when 'true' ->
        {'Right', Acc}
      <[{'Tuple', Wrapped, E} | Rest]> when 'true' ->
        case apply 'convertExpr'/1(call 'maps':'get'('value', Wrapped)) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Fn}> when 'true' ->
        case apply 'convertExpr'/1(E) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', ExprE}> when 'true' ->
        let <Combined> = call 'Nova.Compiler.Ast':'ExprApp'(call 'Nova.Compiler.Ast':'ExprApp'(Fn, Acc), ExprE)
      in apply 'foldInfixOps'/2(Combined, Rest)
      <{'Right', ExprE}> when 'true' ->
        let <Combined> = call 'Nova.Compiler.Ast':'ExprApp'(call 'Nova.Compiler.Ast':'ExprApp'(Fn, Acc), ExprE)
      in apply 'foldInfixOps'/2(Combined, Rest)
      end
      <{'Right', Fn}> when 'true' ->
        case apply 'convertExpr'/1(E) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', ExprE}> when 'true' ->
        let <Combined> = call 'Nova.Compiler.Ast':'ExprApp'(call 'Nova.Compiler.Ast':'ExprApp'(Fn, Acc), ExprE)
      in apply 'foldInfixOps'/2(Combined, Rest)
      <{'Right', ExprE}> when 'true' ->
        let <Combined> = call 'Nova.Compiler.Ast':'ExprApp'(call 'Nova.Compiler.Ast':'ExprApp'(Fn, Acc), ExprE)
      in apply 'foldInfixOps'/2(Combined, Rest)
      end
      end
    end

'convertRecordField'/1 =
  fun (Field) ->
    case Field of
      <{'RecordPun', Name}> when 'true' ->
        let <Label> = apply 'unwrapIdent'/1(call 'maps':'get'('name', Name))
      in {'Right', call 'Data.Tuple':'Tuple'(Label, call 'Nova.Compiler.Ast':'ExprVar'(Label))}
      <{'RecordField', Name, _W0, Value}> when 'true' ->
        let <Label> = apply 'unwrapLabel'/1(call 'maps':'get'('name', Name))
      in case apply 'convertExpr'/1(Value) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Expr}> when 'true' ->
        {'Right', call 'Data.Tuple':'Tuple'(Label, Expr)}
      <{'Right', Expr}> when 'true' ->
        {'Right', call 'Data.Tuple':'Tuple'(Label, Expr)}
      end
    end

'convertRecordUpdate'/1 =
  fun (Update) ->
    case Update of
      <{'RecordUpdateLeaf', Name, _W0, Expr}> when 'true' ->
        let <Label> = apply 'unwrapLabel'/1(call 'maps':'get'('name', Name))
      in case apply 'convertExpr'/1(Expr) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', E}> when 'true' ->
        {'Right', call 'Data.Tuple':'Tuple'(Label, E)}
      <{'Right', E}> when 'true' ->
        {'Right', call 'Data.Tuple':'Tuple'(Label, E)}
      end
      <{'RecordUpdateBranch', Name, Updates}> when 'true' ->
        let <Label> = apply 'unwrapLabel'/1(call 'maps':'get'('name', Name))
      in let <AllUpdates> = [call 'maps':'get'('head', call 'maps':'get'('value', Updates)) | call 'lists':'map'(fun (_L0) ->
      case {_L0} of
        <{{'Tuple', _W0, U}}> when 'true' -> U
      end, call 'maps':'get'('tail', call 'maps':'get'('value', Updates)))]
      in case apply 'traverse'/2(fun (_Mf0) -> apply 'convertRecordUpdate'/1(_Mf0), AllUpdates) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Fields}> when 'true' ->
        {'Right', call 'Data.Tuple':'Tuple'(Label, call 'Nova.Compiler.Ast':'ExprRecord'(Fields))}
      <{'Right', Fields}> when 'true' ->
        {'Right', call 'Data.Tuple':'Tuple'(Label, call 'Nova.Compiler.Ast':'ExprRecord'(Fields))}
      end
    end

'convertCaseBranch'/1 =
  fun (_P0) ->
    case {_P0} of
      <{{'Tuple', Patterns, Guarded}}> when 'true' ->
        let <AllPats> = [call 'maps':'get'('head', Patterns) | call 'lists':'map'(fun (_L0) ->
      case {_L0} of
        <{{'Tuple', _W0, P}}> when 'true' -> P
      end, call 'maps':'get'('tail', Patterns))]
      in case case AllPats of
      <[Single | []]> when 'true' ->
        apply 'convertBinder'/1(Single)
      <Multiple> when 'true' ->
        case apply 'traverse'/2(fun (_Mf0) -> apply 'convertBinder'/1(_Mf0), Multiple) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Ps}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'PatRecord'(apply 'listMapWithIndex'/2(fun (I, P) ->
      call 'Data.Tuple':'Tuple'(call 'erlang':'integer_to_list'(I), P), Ps))}
      <{'Right', Ps}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'PatRecord'(apply 'listMapWithIndex'/2(fun (I, P) ->
      call 'Data.Tuple':'Tuple'(call 'erlang':'integer_to_list'(I), P), Ps))}
      end
    end of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Pat}> when 'true' ->
        case Guarded of
      <{'Unconditional', _W0, Wh}> when 'true' ->
        case apply 'convertExpr'/1(call 'maps':'get'('expr', Wh)) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Body}> when 'true' ->
        {'Right', ю狒翦蝾Ы拘狒х踽蜾Ы晶物翳轭绉р镤Ы韭镤
      <{'Right', Body}> when 'true' ->
        {'Right', ю狒翦蝾Ы拘狒х踽蜾Ы晶物翳轭绉р镤Ы韭镤
      end
      <{'Guarded', Guards}> when 'true' ->
        case Guards of
      <[Ge | _W0]> when 'true' ->
        case apply 'convertPatternGuards'/1(call 'maps':'get'('patterns', Ge)) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', GuardClauses}> when 'true' ->
        case apply 'convertExpr'/1(call 'maps':'get'('expr', call 'maps':'get'('where', Ge))) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Body}> when 'true' ->
        let <Guard> = case GuardClauses of
      <[{'GuardExpr', E} | _W0]> when 'true' ->
        {'Just', E}
      <_W0> when 'true' ->
        'Nothing'
    end
      in {'Right', ю狒翦蝾Ы拘狒х踽蜾Ы厩踽蜾р镤Ы韭镤
      <{'Right', Body}> when 'true' ->
        let <Guard> = case GuardClauses of
      <[{'GuardExpr', E} | _W0]> when 'true' ->
        {'Just', E}
      <_W0> when 'true' ->
        'Nothing'
    end
      in {'Right', ю狒翦蝾Ы拘狒х踽蜾Ы厩踽蜾р镤Ы韭镤
      end
      <{'Right', GuardClauses}> when 'true' ->
        case apply 'convertExpr'/1(call 'maps':'get'('expr', call 'maps':'get'('where', Ge))) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Body}> when 'true' ->
        let <Guard> = case GuardClauses of
      <[{'GuardExpr', E} | _W0]> when 'true' ->
        {'Just', E}
      <_W0> when 'true' ->
        'Nothing'
    end
      in {'Right', ю狒翦蝾Ы拘狒х踽蜾Ы厩踽蜾р镤Ы韭镤
      <{'Right', Body}> when 'true' ->
        let <Guard> = case GuardClauses of
      <[{'GuardExpr', E} | _W0]> when 'true' ->
        {'Just', E}
      <_W0> when 'true' ->
        'Nothing'
    end
      in {'Right', ю狒翦蝾Ы拘狒х踽蜾Ы厩踽蜾р镤Ы韭镤
      end
      end
      <[]> when 'true' ->
        {'Left', #{#<69>(8,1,'integer',['unsigned'|['big']]),#<109>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<121>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<103>(8,1,'integer',['unsigned'|['big']]),#<117>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<120>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<99>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']])}#}
    end
    end
      <{'Right', Pat}> when 'true' ->
        case Guarded of
      <{'Unconditional', _W0, Wh}> when 'true' ->
        case apply 'convertExpr'/1(call 'maps':'get'('expr', Wh)) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Body}> when 'true' ->
        {'Right', ю狒翦蝾Ы拘狒х踽蜾Ы晶物翳轭绉р镤Ы韭镤
      <{'Right', Body}> when 'true' ->
        {'Right', ю狒翦蝾Ы拘狒х踽蜾Ы晶物翳轭绉р镤Ы韭镤
      end
      <{'Guarded', Guards}> when 'true' ->
        case Guards of
      <[Ge | _W0]> when 'true' ->
        case apply 'convertPatternGuards'/1(call 'maps':'get'('patterns', Ge)) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', GuardClauses}> when 'true' ->
        case apply 'convertExpr'/1(call 'maps':'get'('expr', call 'maps':'get'('where', Ge))) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Body}> when 'true' ->
        let <Guard> = case GuardClauses of
      <[{'GuardExpr', E} | _W0]> when 'true' ->
        {'Just', E}
      <_W0> when 'true' ->
        'Nothing'
    end
      in {'Right', ю狒翦蝾Ы拘狒х踽蜾Ы厩踽蜾р镤Ы韭镤
      <{'Right', Body}> when 'true' ->
        let <Guard> = case GuardClauses of
      <[{'GuardExpr', E} | _W0]> when 'true' ->
        {'Just', E}
      <_W0> when 'true' ->
        'Nothing'
    end
      in {'Right', ю狒翦蝾Ы拘狒х踽蜾Ы厩踽蜾р镤Ы韭镤
      end
      <{'Right', GuardClauses}> when 'true' ->
        case apply 'convertExpr'/1(call 'maps':'get'('expr', call 'maps':'get'('where', Ge))) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Body}> when 'true' ->
        let <Guard> = case GuardClauses of
      <[{'GuardExpr', E} | _W0]> when 'true' ->
        {'Just', E}
      <_W0> when 'true' ->
        'Nothing'
    end
      in {'Right', ю狒翦蝾Ы拘狒х踽蜾Ы厩踽蜾р镤Ы韭镤
      <{'Right', Body}> when 'true' ->
        let <Guard> = case GuardClauses of
      <[{'GuardExpr', E} | _W0]> when 'true' ->
        {'Just', E}
      <_W0> when 'true' ->
        'Nothing'
    end
      in {'Right', ю狒翦蝾Ы拘狒х踽蜾Ы厩踽蜾р镤Ы韭镤
      end
      end
      <[]> when 'true' ->
        {'Left', #{#<69>(8,1,'integer',['unsigned'|['big']]),#<109>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<121>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<103>(8,1,'integer',['unsigned'|['big']]),#<117>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<120>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<99>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']])}#}
    end
    end
      end
    end

'convertLetBinding'/1 =
  fun (Binding) ->
    case Binding of
      <{'LetBindingSignature', Labeled}> when 'true' ->
        let <Name> = apply 'unwrapIdent'/1(call 'maps':'get'('name', call 'maps':'get'('label', Labeled)))
      in case apply 'convertType'/1(call 'maps':'get'('value', Labeled)) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Ty}> when 'true' ->
        {'Right', ю狒翦蝾Ы俱犰物鲠蔑眇殪弪馏臾骇嗅糁狎Ж吾礤┈鲠祯濮骄汜祆物鲠蔑眇殪弪馏臾骇砒痱轴颛ㄎ犴濠豉疱令瞌骄术篝К赠
      <{'Right', Ty}> when 'true' ->
        {'Right', ю狒翦蝾Ы俱犰物鲠蔑眇殪弪馏臾骇嗅糁狎Ж吾礤┈鲠祯濮骄汜祆物鲠蔑眇殪弪馏臾骇砒痱轴颛ㄎ犴濠豉疱令瞌骄术篝К赠
      end
      <{'LetBindingName', Vbf}> when 'true' ->
        let <Name> = apply 'unwrapIdent'/1(call 'maps':'get'('name', call 'maps':'get'('name', Vbf)))
      in case apply 'traverse'/2(fun (_Mf0) -> apply 'convertBinder'/1(_Mf0), call 'maps':'get'('binders', Vbf)) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Params}> when 'true' ->
        case case call 'maps':'get'('guarded', Vbf) of
      <{'Unconditional', _W0, Wh}> when 'true' ->
        apply 'convertExpr'/1(call 'maps':'get'('expr', Wh))
      <{'Guarded', Guards}> when 'true' ->
        case Guards of
      <[Ge | _W0]> when 'true' ->
        apply 'convertExpr'/1(call 'maps':'get'('expr', call 'maps':'get'('where', Ge)))
      <[]> when 'true' ->
        {'Left', #{#<69>(8,1,'integer',['unsigned'|['big']]),#<109>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<121>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<103>(8,1,'integer',['unsigned'|['big']]),#<117>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<108>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<98>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<103>(8,1,'integer',['unsigned'|['big']])}#}
    end
    end of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', BodyExpr}> when 'true' ->
        let <Body> = case call 'Data.List':'null'(Params) of
      <'true'> when 'true' -> BodyExpr
      <'false'> when 'true' -> call 'Nova.Compiler.Ast':'ExprLambda'(Params, BodyExpr)
    end
      in {'Right', ю狒翦蝾Ы俱犰物鲠蔑眇殪弪馏臾骇嗅糁狎Ж吾礤┈鲠祯濮骄嘛澌豉疱令瞌骄物翳轭绉
      <{'Right', BodyExpr}> when 'true' ->
        let <Body> = case call 'Data.List':'null'(Params) of
      <'true'> when 'true' -> BodyExpr
      <'false'> when 'true' -> call 'Nova.Compiler.Ast':'ExprLambda'(Params, BodyExpr)
    end
      in {'Right', ю狒翦蝾Ы俱犰物鲠蔑眇殪弪馏臾骇嗅糁狎Ж吾礤┈鲠祯濮骄嘛澌豉疱令瞌骄物翳轭绉
      end
      <{'Right', Params}> when 'true' ->
        case case call 'maps':'get'('guarded', Vbf) of
      <{'Unconditional', _W0, Wh}> when 'true' ->
        apply 'convertExpr'/1(call 'maps':'get'('expr', Wh))
      <{'Guarded', Guards}> when 'true' ->
        case Guards of
      <[Ge | _W0]> when 'true' ->
        apply 'convertExpr'/1(call 'maps':'get'('expr', call 'maps':'get'('where', Ge)))
      <[]> when 'true' ->
        {'Left', #{#<69>(8,1,'integer',['unsigned'|['big']]),#<109>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<121>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<103>(8,1,'integer',['unsigned'|['big']]),#<117>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<108>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<98>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<103>(8,1,'integer',['unsigned'|['big']])}#}
    end
    end of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', BodyExpr}> when 'true' ->
        let <Body> = case call 'Data.List':'null'(Params) of
      <'true'> when 'true' -> BodyExpr
      <'false'> when 'true' -> call 'Nova.Compiler.Ast':'ExprLambda'(Params, BodyExpr)
    end
      in {'Right', ю狒翦蝾Ы俱犰物鲠蔑眇殪弪馏臾骇嗅糁狎Ж吾礤┈鲠祯濮骄嘛澌豉疱令瞌骄物翳轭绉
      <{'Right', BodyExpr}> when 'true' ->
        let <Body> = case call 'Data.List':'null'(Params) of
      <'true'> when 'true' -> BodyExpr
      <'false'> when 'true' -> call 'Nova.Compiler.Ast':'ExprLambda'(Params, BodyExpr)
    end
      in {'Right', ю狒翦蝾Ы俱犰物鲠蔑眇殪弪馏臾骇嗅糁狎Ж吾礤┈鲠祯濮骄嘛澌豉疱令瞌骄物翳轭绉
      end
      end
      <{'LetBindingPattern', Binder, _W0, Wh}> when 'true' ->
        case apply 'convertBinder'/1(Binder) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Pat}> when 'true' ->
        case apply 'convertExpr'/1(call 'maps':'get'('expr', Wh)) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Body}> when 'true' ->
        {'Right', ю狒翦蝾Ы拘狒鲠祯濮骄嘛澌豉疱令瞌骄物翳轭绉
      <{'Right', Body}> when 'true' ->
        {'Right', ю狒翦蝾Ы拘狒鲠祯濮骄嘛澌豉疱令瞌骄物翳轭绉
      end
      <{'Right', Pat}> when 'true' ->
        case apply 'convertExpr'/1(call 'maps':'get'('expr', Wh)) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Body}> when 'true' ->
        {'Right', ю狒翦蝾Ы拘狒鲠祯濮骄嘛澌豉疱令瞌骄物翳轭绉
      <{'Right', Body}> when 'true' ->
        {'Right', ю狒翦蝾Ы拘狒鲠祯濮骄嘛澌豉疱令瞌骄物翳轭绉
      end
      end
      <{'LetBindingError', _W0}> when 'true' ->
        {'Left', #{#<67>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<99>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<118>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<108>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<98>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<103>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']])}#}
    end

'convertDoStatement'/1 =
  fun (Stmt) ->
    case Stmt of
      <{'DoLet', _W0, Bindings}> when 'true' ->
        case apply 'convertLetBindings'/1(Bindings) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Binds}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'DoLet'(Binds)}
      <{'Right', Binds}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'DoLet'(Binds)}
      end
      <{'DoDiscard', E}> when 'true' ->
        case apply 'convertExpr'/1(E) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Expr}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'DoExpr'(Expr)}
      <{'Right', Expr}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'DoExpr'(Expr)}
      end
      <{'DoBind', Binder, _W0, E}> when 'true' ->
        case apply 'convertBinder'/1(Binder) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Pat}> when 'true' ->
        case apply 'convertExpr'/1(E) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Expr}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'DoBind'(Pat, Expr)}
      <{'Right', Expr}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'DoBind'(Pat, Expr)}
      end
      <{'Right', Pat}> when 'true' ->
        case apply 'convertExpr'/1(E) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Expr}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'DoBind'(Pat, Expr)}
      <{'Right', Expr}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'DoBind'(Pat, Expr)}
      end
      end
      <{'DoError', _W0}> when 'true' ->
        {'Left', #{#<67>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<99>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<118>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<109>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']])}#}
    end

'convertBinder'/1 =
  fun (Binder) ->
    case Binder of
      <{'BinderWildcard', _W0}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'PatWildcard'()}
      <{'BinderVar', Name}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'PatVar'(apply 'unwrapIdent'/1(call 'maps':'get'('name', Name)))}
      <{'BinderNamed', Name, _W0, Inner}> when 'true' ->
        case apply 'convertBinder'/1(Inner) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', InnerPat}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'PatAs'(apply 'unwrapIdent'/1(call 'maps':'get'('name', Name)), InnerPat)}
      <{'Right', InnerPat}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'PatAs'(apply 'unwrapIdent'/1(call 'maps':'get'('name', Name)), InnerPat)}
      end
      <{'BinderConstructor', Qn, Args}> when 'true' ->
        let <Name> = apply 'qualifiedProperName'/1(Qn)
      in case apply 'traverse'/2(fun (_Mf0) -> apply 'convertBinder'/1(_Mf0), Args) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', ArgPats}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'PatCon'(Name, ArgPats)}
      <{'Right', ArgPats}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'PatCon'(Name, ArgPats)}
      end
      <{'BinderBoolean', _W0, B}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'PatLit'(call 'Nova.Compiler.Ast':'LitBool'(B))}
      <{'BinderChar', _W0, C}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'PatLit'(call 'Nova.Compiler.Ast':'LitChar'(C))}
      <{'BinderString', _W0, S}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'PatLit'(call 'Nova.Compiler.Ast':'LitString'(S))}
      <{'BinderInt', Neg, _W0, IntVal}> when 'true' ->
        let <N> = apply 'intValueToInt'/1(IntVal)
      in let <N_> = case Neg of
      <'Nothing'> when 'true' ->
        N
      <{'Just', _W0}> when 'true' ->
        call 'erlang':'-'(N)
    end
      in {'Right', call 'Nova.Compiler.Ast':'PatLit'(call 'Nova.Compiler.Ast':'LitInt'(N_))}
      <{'BinderNumber', Neg, _W0, Num}> when 'true' ->
        let <N_> = case Neg of
      <'Nothing'> when 'true' ->
        Num
      <{'Just', _W0}> when 'true' ->
        call 'erlang':'-'(Num)
    end
      in {'Right', call 'Nova.Compiler.Ast':'PatLit'(call 'Nova.Compiler.Ast':'LitNumber'(N_))}
      <{'BinderArray', Del}> when 'true' ->
        case case call 'maps':'get'('value', Del) of
      <'Nothing'> when 'true' ->
        {'Right', []}
      <{'Just', Sep}> when 'true' ->
        let <AllItems> = [call 'maps':'get'('head', Sep) | call 'lists':'map'(fun (_L0) ->
      case {_L0} of
        <{{'Tuple', _W0, B}}> when 'true' -> B
      end, call 'maps':'get'('tail', Sep))]
      in apply 'traverse'/2(fun (_Mf0) -> apply 'convertBinder'/1(_Mf0), AllItems)
    end of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Items}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'PatList'(Items)}
      <{'Right', Items}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'PatList'(Items)}
      end
      <{'BinderRecord', Del}> when 'true' ->
        case case call 'maps':'get'('value', Del) of
      <'Nothing'> when 'true' ->
        {'Right', []}
      <{'Just', Sep}> when 'true' ->
        let <AllFields> = [call 'maps':'get'('head', Sep) | call 'lists':'map'(fun (_L0) ->
      case {_L0} of
        <{{'Tuple', _W0, F}}> when 'true' -> F
      end, call 'maps':'get'('tail', Sep))]
      in apply 'traverse'/2(fun (_Mf0) -> apply 'convertRecordBinder'/1(_Mf0), AllFields)
    end of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Fields}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'PatRecord'(Fields)}
      <{'Right', Fields}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'PatRecord'(Fields)}
      end
      <{'BinderParens', Wrapped}> when 'true' ->
        case apply 'convertBinder'/1(call 'maps':'get'('value', Wrapped)) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Inner}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'PatParens'(Inner)}
      <{'Right', Inner}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'PatParens'(Inner)}
      end
      <{'BinderTyped', Inner, _W0, _W1}> when 'true' ->
        apply 'convertBinder'/1(Inner)
      <{'BinderOp', Head, Ops}> when 'true' ->
        case apply 'convertBinder'/1(Head) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', HeadPat}> when 'true' ->
        apply 'foldBinderOps'/2(HeadPat, Ops)
      <{'Right', HeadPat}> when 'true' ->
        apply 'foldBinderOps'/2(HeadPat, Ops)
      end
      <{'BinderError', _W0}> when 'true' ->
        {'Left', #{#<67>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<99>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<118>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<98>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']])}#}
    end

'foldBinderOps'/2 =
  fun (Acc, Ops) ->
    case Ops of
      <[]> when 'true' ->
        {'Right', Acc}
      <[{'Tuple', Op, B} | Rest]> when 'true' ->
        let <OpName> = apply 'unwrapOperator'/1(call 'maps':'get'('name', Op))
      in case apply 'convertBinder'/1(B) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', BinderPat}> when 'true' ->
        case call 'erlang':'=:='(OpName, #{#<58>(8,1,'integer',['unsigned'|['big']])}#) of
      <'true'> when 'true' -> case apply 'foldBinderOps'/2(BinderPat, Rest) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', TailPat}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'PatCons'(Acc, TailPat)}
      <{'Right', TailPat}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'PatCons'(Acc, TailPat)}
      end
      <'false'> when 'true' -> let <Combined> = call 'Nova.Compiler.Ast':'PatCon'(OpName, [Acc | [BinderPat | []]])
      in apply 'foldBinderOps'/2(Combined, Rest)
    end
      <{'Right', BinderPat}> when 'true' ->
        case call 'erlang':'=:='(OpName, #{#<58>(8,1,'integer',['unsigned'|['big']])}#) of
      <'true'> when 'true' -> case apply 'foldBinderOps'/2(BinderPat, Rest) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', TailPat}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'PatCons'(Acc, TailPat)}
      <{'Right', TailPat}> when 'true' ->
        {'Right', call 'Nova.Compiler.Ast':'PatCons'(Acc, TailPat)}
      end
      <'false'> when 'true' -> let <Combined> = call 'Nova.Compiler.Ast':'PatCon'(OpName, [Acc | [BinderPat | []]])
      in apply 'foldBinderOps'/2(Combined, Rest)
    end
      end
    end

'convertRecordBinder'/1 =
  fun (Field) ->
    case Field of
      <{'RecordPun', Name}> when 'true' ->
        let <Label> = apply 'unwrapIdent'/1(call 'maps':'get'('name', Name))
      in {'Right', call 'Data.Tuple':'Tuple'(Label, call 'Nova.Compiler.Ast':'PatVar'(Label))}
      <{'RecordField', Name, _W0, Binder}> when 'true' ->
        let <Label> = apply 'unwrapLabel'/1(call 'maps':'get'('name', Name))
      in case apply 'convertBinder'/1(Binder) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Pat}> when 'true' ->
        {'Right', call 'Data.Tuple':'Tuple'(Label, Pat)}
      <{'Right', Pat}> when 'true' ->
        {'Right', call 'Data.Tuple':'Tuple'(Label, Pat)}
      end
    end

'unwrapIdent'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'unwrapIdent'/1(_A0)
      in _F0

'unwrapProper'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'unwrapProper'/1(_A0)
      in _F0

'unwrapLabel'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'unwrapLabel'/1(_A0)
      in _F0

'unwrapOperator'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'unwrapOperator'/1(_A0)
      in _F0

'unwrapModuleName'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'unwrapModuleName'/1(_A0)
      in _F0

'qualifiedProperName'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'qualifiedProperName'/1(_A0)
      in _F0

'extractTypeVar'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'extractTypeVar'/1(_A0)
      in _F0

'intValueToInt'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'intValueToInt'/1(_A0)
      in _F0

'snd'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'snd'/1(_A0)
      in _F0

'traverse'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'traverse'/2(_A0, _A1)
      in _F1
      in _F0

'traverse'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'traverse'/2(_A0, _A1)
      in _F0

'listMapWithIndex'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'listMapWithIndex'/2(_A0, _A1)
      in _F1
      in _F0

'listMapWithIndex'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'listMapWithIndex'/2(_A0, _A1)
      in _F0

'isUnderscore'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'isUnderscore'/1(_A0)
      in _F0

'operatorPrecedence'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'operatorPrecedence'/1(_A0)
      in _F0

'operatorIsRightAssoc'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'operatorIsRightAssoc'/1(_A0)
      in _F0

'convertModule'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'convertModule'/1(_A0)
      in _F0

'convertImportDecl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'convertImportDecl'/1(_A0)
      in _F0

'convertImportItems'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'convertImportItems'/1(_A0)
      in _F0

'convertImportItem'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'convertImportItem'/1(_A0)
      in _F0

'convertDataMembers'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'convertDataMembers'/1(_A0)
      in _F0

'convertDeclarations'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'convertDeclarations'/1(_A0)
      in _F0

'convertDeclaration'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'convertDeclaration'/1(_A0)
      in _F0

'convertDataType'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'convertDataType'/2(_A0, _A1)
      in _F1
      in _F0

'convertDataType'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'convertDataType'/2(_A0, _A1)
      in _F0

'convertDataCtors'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'convertDataCtors'/1(_A0)
      in _F0

'convertDataCtor'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'convertDataCtor'/1(_A0)
      in _F0

'convertTypeToField'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'convertTypeToField'/1(_A0)
      in _F0

'convertTypeAlias'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'convertTypeAlias'/2(_A0, _A1)
      in _F1
      in _F0

'convertTypeAlias'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'convertTypeAlias'/2(_A0, _A1)
      in _F0

'convertNewtype'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'convertNewtype'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'convertNewtype'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'convertNewtype'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'convertNewtype'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'convertNewtype'/3(_A0, _A1, _A2)
      in _F0

'convertTypeClass'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'convertTypeClass'/2(_A0, _A1)
      in _F1
      in _F0

'convertTypeClass'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'convertTypeClass'/2(_A0, _A1)
      in _F0

'convertMethodSig'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'convertMethodSig'/1(_A0)
      in _F0

'convertInstance'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'convertInstance'/1(_A0)
      in _F0

'convertInstanceBinding'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'convertInstanceBinding'/1(_A0)
      in _F0

'convertDeriveInstance'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'convertDeriveInstance'/1(_A0)
      in _F0

'convertFunction'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'convertFunction'/1(_A0)
      in _F0

'convertValueBinding'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'convertValueBinding'/1(_A0)
      in _F0

'convertWhereExpr'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'convertWhereExpr'/1(_A0)
      in _F0

'convertLetBindings'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'convertLetBindings'/1(_A0)
      in _F0

'convertWhereBindings'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'convertWhereBindings'/1(_A0)
      in _F0

'convertGuardedExpr'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'convertGuardedExpr'/1(_A0)
      in _F0

'convertPatternGuards'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'convertPatternGuards'/1(_A0)
      in _F0

'convertPatternGuard'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'convertPatternGuard'/1(_A0)
      in _F0

'convertTypeSignature'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'convertTypeSignature'/1(_A0)
      in _F0

'extractConstraints'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'extractConstraints'/1(_A0)
      in _F0

'convertConstraintType'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'convertConstraintType'/1(_A0)
      in _F0

'convertFixity'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'convertFixity'/1(_A0)
      in _F0

'convertForeign'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'convertForeign'/1(_A0)
      in _F0

'convertType'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'convertType'/1(_A0)
      in _F0

'foldTypeOps'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'foldTypeOps'/2(_A0, _A1)
      in _F1
      in _F0

'foldTypeOps'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'foldTypeOps'/2(_A0, _A1)
      in _F0

'convertRow'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'convertRow'/1(_A0)
      in _F0

'convertRowLabels'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'convertRowLabels'/1(_A0)
      in _F0

'convertRowLabel'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'convertRowLabel'/1(_A0)
      in _F0

'convertExpr'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'convertExpr'/1(_A0)
      in _F0

'foldBinOps'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'foldBinOps'/2(_A0, _A1)
      in _F1
      in _F0

'foldBinOps'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'foldBinOps'/2(_A0, _A1)
      in _F0

'convertOpList'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'convertOpList'/1(_A0)
      in _F0

'shuntingYard'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'shuntingYard'/2(_A0, _A1)
      in _F1
      in _F0

'shuntingYard'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'shuntingYard'/2(_A0, _A1)
      in _F0

'makeBinOpOrSection'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'makeBinOpOrSection'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'makeBinOpOrSection'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'makeBinOpOrSection'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'makeBinOpOrSection'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'makeBinOpOrSection'/3(_A0, _A1, _A2)
      in _F0

'foldInfixOps'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'foldInfixOps'/2(_A0, _A1)
      in _F1
      in _F0

'foldInfixOps'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'foldInfixOps'/2(_A0, _A1)
      in _F0

'convertRecordField'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'convertRecordField'/1(_A0)
      in _F0

'convertRecordUpdate'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'convertRecordUpdate'/1(_A0)
      in _F0

'convertCaseBranch'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'convertCaseBranch'/1(_A0)
      in _F0

'convertLetBinding'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'convertLetBinding'/1(_A0)
      in _F0

'convertDoStatement'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'convertDoStatement'/1(_A0)
      in _F0

'convertBinder'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'convertBinder'/1(_A0)
      in _F0

'foldBinderOps'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'foldBinderOps'/2(_A0, _A1)
      in _F1
      in _F0

'foldBinderOps'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'foldBinderOps'/2(_A0, _A1)
      in _F0

'convertRecordBinder'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'convertRecordBinder'/1(_A0)
      in _F0
end
