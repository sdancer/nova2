module 'Nova.Compiler.Dependencies' ['getDependencies'/1, 'getModuleDependencies'/1, 'getConstructorDeps'/1, 'getTypeExprDeps'/1, 'getExprDeps'/1, 'getLetBindsDeps'/1, 'getCaseClauseDeps'/1, 'getDoStatementsDeps'/1, 'getGuardedExprDeps'/1, 'getGuardClauseDeps'/1, 'getBoundNames'/1, 'emptyGraph'/0, 'buildDependencyGraph'/2, 'buildReverseEdges'/1, 'addToGraph'/3, 'removeFromGraph'/2, 'getDependents'/2, 'getDependenciesOf'/2, 'getAffected'/2, 'topologicalSort'/2, 'getDependencies'/0, 'getModuleDependencies'/0, 'getConstructorDeps'/0, 'getTypeExprDeps'/0, 'getExprDeps'/0, 'getLetBindsDeps'/0, 'getCaseClauseDeps'/0, 'getDoStatementsDeps'/0, 'getGuardedExprDeps'/0, 'getGuardClauseDeps'/0, 'getBoundNames'/0, 'buildDependencyGraph'/0, 'buildDependencyGraph'/1, 'buildReverseEdges'/0, 'addToGraph'/0, 'addToGraph'/1, 'addToGraph'/2, 'removeFromGraph'/0, 'removeFromGraph'/1, 'getDependents'/0, 'getDependents'/1, 'getDependenciesOf'/0, 'getDependenciesOf'/1, 'getAffected'/0, 'getAffected'/1, 'topologicalSort'/0, 'topologicalSort'/1, 'module_info'/0, 'module_info'/1]
  attributes []
'getDependencies'/1 =
  fun (Decl) ->
    case Decl of
      <{'DeclFunction', F}> when 'true' ->
        let <BodyDeps> = apply 'getExprDeps'/1(call 'maps':'get'('body', F))
      in let <GuardDeps> = call 'Data.Foldable':'foldl'(fun (Acc, G) ->
      call 'Data.Set':'union'(Acc, apply 'getGuardedExprDeps'/1(G)), call 'Data.Set':'empty'(), call 'maps':'get'('guards', F))
      in let <ParamNames> = call 'Data.Foldable':'foldl'(fun (Acc, P) ->
      call 'Data.Set':'union'(Acc, apply 'getBoundNames'/1(P)), call 'Data.Set':'empty'(), call 'maps':'get'('parameters', F))
      in call 'Data.Set':'difference'(call 'Data.Set':'union'(BodyDeps, GuardDeps), ParamNames)
      <{'DeclDataType', D}> when 'true' ->
        call 'Data.Foldable':'foldl'(fun (Acc, C) ->
      call 'Data.Set':'union'(Acc, apply 'getConstructorDeps'/1(C)), call 'Data.Set':'empty'(), call 'maps':'get'('constructors', D))
      <{'DeclTypeAlias', A}> when 'true' ->
        apply 'getTypeExprDeps'/1(call 'maps':'get'('ty', A))
      <{'DeclTypeClass', C}> when 'true' ->
        call 'Data.Foldable':'foldl'(fun (Acc, M) ->
      call 'Data.Set':'union'(Acc, apply 'getTypeExprDeps'/1(call 'maps':'get'('ty', M))), call 'Data.Set':'empty'(), call 'maps':'get'('methods', C))
      <{'DeclTypeClassInstance', I}> when 'true' ->
        let <TyDeps> = apply 'getTypeExprDeps'/1(call 'maps':'get'('ty', I))
      in let <MethodDeps> = call 'Data.Foldable':'foldl'(fun (Acc, M) ->
      call 'Data.Set':'union'(Acc, apply 'getExprDeps'/1(call 'maps':'get'('body', M))), call 'Data.Set':'empty'(), call 'maps':'get'('methods', I))
      in call 'Data.Set':'union'(TyDeps, MethodDeps)
      <{'DeclForeignImport', F}> when 'true' ->
        apply 'getTypeExprDeps'/1(call 'maps':'get'('typeSignature', F))
      <{'DeclTypeSig', S}> when 'true' ->
        apply 'getTypeExprDeps'/1(call 'maps':'get'('ty', S))
      <{'DeclType', T}> when 'true' ->
        apply 'getTypeExprDeps'/1(call 'maps':'get'('typeSignature', T))
      <{'DeclModule', M}> when 'true' ->
        apply 'getModuleDependencies'/1(call 'maps':'get'('declarations', M))
      <{'DeclImport', _W0}> when 'true' ->
        call 'Data.Set':'empty'()
      <{'DeclNewtype', N}> when 'true' ->
        apply 'getTypeExprDeps'/1(call 'maps':'get'('wrappedType', N))
      <{'DeclInfix', _W0}> when 'true' ->
        call 'Data.Set':'empty'()
    end

'getModuleDependencies'/1 =
  fun (Decls) ->
    call 'Data.Foldable':'foldl'(fun (Acc, Decl_) ->
      call 'Data.Set':'union'(Acc, apply 'getDependencies'/1(Decl_)), call 'Data.Set':'empty'(), Decls)

'getConstructorDeps'/1 =
  fun (C) ->
    call 'Data.Foldable':'foldl'(fun (Acc, F) ->
      call 'Data.Set':'union'(Acc, apply 'getTypeExprDeps'/1(call 'maps':'get'('ty', F))), call 'Data.Set':'empty'(), call 'maps':'get'('fields', C))

'getTypeExprDeps'/1 =
  fun (Ty) ->
    case Ty of
      <{'TyExprCon', Name}> when 'true' ->
        call 'Data.Set':'singleton'(Name)
      <{'TyExprVar', _W0}> when 'true' ->
        call 'Data.Set':'empty'()
      <{'TyExprApp', T1, T2}> when 'true' ->
        call 'Data.Set':'union'(apply 'getTypeExprDeps'/1(T1), apply 'getTypeExprDeps'/1(T2))
      <{'TyExprArrow', T1, T2}> when 'true' ->
        call 'Data.Set':'union'(apply 'getTypeExprDeps'/1(T1), apply 'getTypeExprDeps'/1(T2))
      <{'TyExprRecord', Fields, _W0}> when 'true' ->
        call 'Data.Foldable':'foldl'(fun (_L0, _L1) ->
      case {_L0, _L1} of
        <{Acc, {'Tuple', _W0, T}}> when 'true' -> call 'Data.Set':'union'(Acc, apply 'getTypeExprDeps'/1(T))
      end, call 'Data.Set':'empty'(), Fields)
      <{'TyExprForAll', _W0, T}> when 'true' ->
        apply 'getTypeExprDeps'/1(T)
      <{'TyExprConstrained', Cs, T}> when 'true' ->
        let <ConstraintDeps> = call 'Data.Foldable':'foldl'(fun (Acc, C) ->
      call 'Data.Set':'union'(Acc, call 'Data.Set':'singleton'(call 'maps':'get'('className', C))), call 'Data.Set':'empty'(), Cs)
      in let <TyDeps> = call 'Data.Foldable':'foldl'(fun (Acc, C) ->
      call 'Data.Set':'union'(Acc, call 'Data.Foldable':'foldl'(fun (Acc2, Ct) ->
      call 'Data.Set':'union'(Acc2, apply 'getTypeExprDeps'/1(Ct)), call 'Data.Set':'empty'(), call 'maps':'get'('types', C))), call 'Data.Set':'empty'(), Cs)
      in call 'Data.Set':'union'(ConstraintDeps, call 'Data.Set':'union'(TyDeps, apply 'getTypeExprDeps'/1(T)))
      <{'TyExprParens', T}> when 'true' ->
        apply 'getTypeExprDeps'/1(T)
      <{'TyExprTuple', Ts}> when 'true' ->
        call 'Data.Foldable':'foldl'(fun (Acc, T) ->
      call 'Data.Set':'union'(Acc, apply 'getTypeExprDeps'/1(T)), call 'Data.Set':'empty'(), Ts)
    end

'getExprDeps'/1 =
  fun (Expr) ->
    case Expr of
      <{'ExprVar', Name}> when 'true' ->
        call 'Data.Set':'singleton'(Name)
      <{'ExprQualified', Ns, Name}> when 'true' ->
        call 'Data.Set':'singleton'(call 'Nova.Prelude':'semigroupAppendImpl'(call 'Nova.Prelude':'semigroupAppendImpl'(Ns, #{#<46>(8,1,'integer',['unsigned'|['big']])}#), Name))
      <{'ExprLit', _W0}> when 'true' ->
        call 'Data.Set':'empty'()
      <{'ExprApp', E1, E2}> when 'true' ->
        call 'Data.Set':'union'(apply 'getExprDeps'/1(E1), apply 'getExprDeps'/1(E2))
      <{'ExprLambda', Pats, Body}> when 'true' ->
        let <BoundNames> = call 'Data.Foldable':'foldl'(fun (Acc, P) ->
      call 'Data.Set':'union'(Acc, apply 'getBoundNames'/1(P)), call 'Data.Set':'empty'(), Pats)
      in call 'Data.Set':'difference'(apply 'getExprDeps'/1(Body), BoundNames)
      <{'ExprLet', Binds, Body}> when 'true' ->
        let <BindDeps> = apply 'getLetBindsDeps'/1(Binds)
      in let <BoundNames> = call 'Data.Foldable':'foldl'(fun (Acc, B) ->
      call 'Data.Set':'union'(Acc, apply 'getBoundNames'/1(call 'maps':'get'('pattern', B))), call 'Data.Set':'empty'(), Binds)
      in call 'Data.Set':'difference'(call 'Data.Set':'union'(BindDeps, apply 'getExprDeps'/1(Body)), BoundNames)
      <{'ExprIf', C, T, E}> when 'true' ->
        call 'Data.Set':'union'(apply 'getExprDeps'/1(C), call 'Data.Set':'union'(apply 'getExprDeps'/1(T), apply 'getExprDeps'/1(E)))
      <{'ExprCase', E, Clauses}> when 'true' ->
        call 'Data.Set':'union'(apply 'getExprDeps'/1(E), call 'Data.Foldable':'foldl'(fun (Acc, C) ->
      call 'Data.Set':'union'(Acc, apply 'getCaseClauseDeps'/1(C)), call 'Data.Set':'empty'(), Clauses))
      <{'ExprDo', Stmts}> when 'true' ->
        apply 'getDoStatementsDeps'/1(Stmts)
      <{'ExprBinOp', Op, E1, E2}> when 'true' ->
        call 'Data.Set':'union'(call 'Data.Set':'singleton'(Op), call 'Data.Set':'union'(apply 'getExprDeps'/1(E1), apply 'getExprDeps'/1(E2)))
      <{'ExprUnaryOp', Op, E}> when 'true' ->
        call 'Data.Set':'union'(call 'Data.Set':'singleton'(Op), apply 'getExprDeps'/1(E))
      <{'ExprList', Es}> when 'true' ->
        call 'Data.Foldable':'foldl'(fun (Acc, E) ->
      call 'Data.Set':'union'(Acc, apply 'getExprDeps'/1(E)), call 'Data.Set':'empty'(), Es)
      <{'ExprTuple', Es}> when 'true' ->
        call 'Data.Foldable':'foldl'(fun (Acc, E) ->
      call 'Data.Set':'union'(Acc, apply 'getExprDeps'/1(E)), call 'Data.Set':'empty'(), Es)
      <{'ExprRecord', Fields}> when 'true' ->
        call 'Data.Foldable':'foldl'(fun (_L0, _L1) ->
      case {_L0, _L1} of
        <{Acc, {'Tuple', _W0, E}}> when 'true' -> call 'Data.Set':'union'(Acc, apply 'getExprDeps'/1(E))
      end, call 'Data.Set':'empty'(), Fields)
      <{'ExprRecordAccess', E, _W0}> when 'true' ->
        apply 'getExprDeps'/1(E)
      <{'ExprRecordUpdate', E, Fields}> when 'true' ->
        call 'Data.Set':'union'(apply 'getExprDeps'/1(E), call 'Data.Foldable':'foldl'(fun (_L0, _L1) ->
      case {_L0, _L1} of
        <{Acc, {'Tuple', _W0, V}}> when 'true' -> call 'Data.Set':'union'(Acc, apply 'getExprDeps'/1(V))
      end, call 'Data.Set':'empty'(), Fields))
      <{'ExprTyped', E, _W0}> when 'true' ->
        apply 'getExprDeps'/1(E)
      <{'ExprParens', E}> when 'true' ->
        apply 'getExprDeps'/1(E)
      <{'ExprSection', _W0}> when 'true' ->
        call 'Data.Set':'empty'()
      <{'ExprSectionLeft', E, _W0}> when 'true' ->
        apply 'getExprDeps'/1(E)
      <{'ExprSectionRight', _W0, E}> when 'true' ->
        apply 'getExprDeps'/1(E)
    end

'getLetBindsDeps'/1 =
  fun (Binds) ->
    call 'Data.Foldable':'foldl'(fun (Acc, B) ->
      call 'Data.Set':'union'(Acc, apply 'getExprDeps'/1(call 'maps':'get'('value', B))), call 'Data.Set':'empty'(), Binds)

'getCaseClauseDeps'/1 =
  fun (Clause) ->
    let <BoundNames> = apply 'getBoundNames'/1(call 'maps':'get'('pattern', Clause))
      in let <BodyDeps> = apply 'getExprDeps'/1(call 'maps':'get'('body', Clause))
      in let <GuardDeps> = case call 'maps':'get'('guard', Clause) of
      <'Nothing'> when 'true' ->
        call 'Data.Set':'empty'()
      <{'Just', G}> when 'true' ->
        apply 'getExprDeps'/1(G)
    end
      in call 'Data.Set':'difference'(call 'Data.Set':'union'(BodyDeps, GuardDeps), BoundNames)

'getDoStatementsDeps'/1 =
  fun (Stmts) ->
    letrec 'go'/2 = fun (Remaining, Bound) ->
      case Remaining of
      <[]> when 'true' ->
        call 'Data.Set':'empty'()
      <[Stmt | Rest]> when 'true' ->
        case Stmt of
      <{'DoLet', Binds}> when 'true' ->
        let <Deps> = apply 'getLetBindsDeps'/1(Binds)
      in let <NewBound> = call 'Data.Foldable':'foldl'(fun (Acc, B) ->
      call 'Data.Set':'union'(Acc, apply 'getBoundNames'/1(call 'maps':'get'('pattern', B))), Bound, Binds)
      in call 'Data.Set':'union'(call 'Data.Set':'difference'(Deps, Bound), apply 'go'/2(Rest, NewBound))
      <{'DoBind', Pat, E}> when 'true' ->
        let <Deps> = apply 'getExprDeps'/1(E)
      in let <NewBound> = call 'Data.Set':'union'(Bound, apply 'getBoundNames'/1(Pat))
      in call 'Data.Set':'union'(call 'Data.Set':'difference'(Deps, Bound), apply 'go'/2(Rest, NewBound))
      <{'DoExpr', E}> when 'true' ->
        call 'Data.Set':'union'(call 'Data.Set':'difference'(apply 'getExprDeps'/1(E), Bound), apply 'go'/2(Rest, Bound))
    end
    end
      in apply 'go'/2(Stmts, call 'Data.Set':'empty'())

'getGuardedExprDeps'/1 =
  fun (G) ->
    let <GuardDeps> = call 'Data.Foldable':'foldl'(fun (Acc, Gc) ->
      call 'Data.Set':'union'(Acc, apply 'getGuardClauseDeps'/1(Gc)), call 'Data.Set':'empty'(), call 'maps':'get'('guards', G))
      in let <BodyDeps> = apply 'getExprDeps'/1(call 'maps':'get'('body', G))
      in call 'Data.Set':'union'(GuardDeps, BodyDeps)

'getGuardClauseDeps'/1 =
  fun (Gc) ->
    case Gc of
      <{'GuardExpr', E}> when 'true' ->
        apply 'getExprDeps'/1(E)
      <{'GuardPat', Pat, E}> when 'true' ->
        let <BoundNames> = apply 'getBoundNames'/1(Pat)
      in call 'Data.Set':'difference'(apply 'getExprDeps'/1(E), BoundNames)
    end

'getBoundNames'/1 =
  fun (Pat) ->
    case Pat of
      <{'PatVar', Name}> when 'true' ->
        call 'Data.Set':'singleton'(Name)
      <'PatWildcard'> when 'true' ->
        call 'Data.Set':'empty'()
      <{'PatLit', _W0}> when 'true' ->
        call 'Data.Set':'empty'()
      <{'PatCon', _W0, Pats}> when 'true' ->
        call 'Data.Foldable':'foldl'(fun (Acc, P) ->
      call 'Data.Set':'union'(Acc, apply 'getBoundNames'/1(P)), call 'Data.Set':'empty'(), Pats)
      <{'PatRecord', Fields}> when 'true' ->
        call 'Data.Foldable':'foldl'(fun (_L0, _L1) ->
      case {_L0, _L1} of
        <{Acc, {'Tuple', _W0, P}}> when 'true' -> call 'Data.Set':'union'(Acc, apply 'getBoundNames'/1(P))
      end, call 'Data.Set':'empty'(), Fields)
      <{'PatList', Pats}> when 'true' ->
        call 'Data.Foldable':'foldl'(fun (Acc, P) ->
      call 'Data.Set':'union'(Acc, apply 'getBoundNames'/1(P)), call 'Data.Set':'empty'(), Pats)
      <{'PatCons', P1, P2}> when 'true' ->
        call 'Data.Set':'union'(apply 'getBoundNames'/1(P1), apply 'getBoundNames'/1(P2))
      <{'PatAs', Name, P}> when 'true' ->
        call 'Data.Set':'insert'(Name, apply 'getBoundNames'/1(P))
      <{'PatParens', P}> when 'true' ->
        apply 'getBoundNames'/1(P)
    end

'emptyGraph'/0 =
  fun () ->
    ф矧麽蜾Ы俱犰尼翎歪皈骇屙痿Ж┈蝈鲥蝮濮骄汜祆尼翎歪皈骇屙痿Жр蹰熹腻疱钿孱泫球狃瑙骢腻沆蟋义箫祧逦犴濠戾忌潴汜祆尼翎歪皈骇脲螫腻沆螬轭戾计矧麽蜾汜祆尼翎骑熹徕戾Шф镬潇Ж骢零悻射汜箦汜祆尼翎歪皈骇祜镫躔Ж射腻沆螬镦姬物翳轭绉麒孱趄蹂零见术篝К弯麒孱趄蹂戾寄屦缶狃痨х弭腻疱钿孱汩弩Н报汜祆ы狃螫骇珏臾ě溴沆К弯┅轭戾家弩镬鲥淠屦缶汜祆尼翎渝臾骇磲鹜狴忮Ж骢ㄎ犴濠狃痨义箫祧逦犴濞汜祆ы狃螫骇珏臾ě钺礤箴徙濮汜祆ы狃螫骇珏臾ě礤翎К弯┅吾礤┈腻痼轭汜祆尼翎歪皈骇轭箦螋Ж射义箫祧邃腻痼零悌孱洮汜祆尼翎歪皈骇屙痿Ж┈射螬轭戾家弼弪箦狃痨р蹰熹义鲥蝮迮溏弩Н报骑蝼狎洎轭ф矧麽蜾Ы酒矧麽蜾蝈鲥蝮濮骄骢ㄟ墟癌汜祆ъ轶趔Ш蝈鲥蝮濮ㄟ墟癌р蹰熹义鲥蝮迮溏弩Н骢ㄆ矧麽蜾戾寂铘蜷弩汜祆尼翎歪皈骇麸疹骘熹徕戾Ж骑蝼狎洎轭汜祆尼翎骑熹徕戾Шф镬潇Ж骢ㄟ贪咛暴汜箦咛艾咛饼镦见零悻г躔戾К乞镯射腻痼麒孱趄蹂戾寄屦罅蝌狴汜祆尼翎渝臾骇麸疹骘熹徕戾Ж腻痼轭汜祆尼翎骑熹徕戾Шф镬潇Ж骢零悴燥射戾寂轶糸铉汜箦汜祆尼翎歪皈骇祜镫躔Ж燥射零悴镦姬物翳轭绉麒孱趄蹂汜祆尼翎渝臾骇屙痿Ж见术篝К育麒孱趄蹂孱轭汜祆尼翎歪皈骇轭箦螋Ж燥射汜祆尼翎渝臾骇轭箦螋Ж乞镯射砒轶糸铉┈零悴┈零悻腻痼硫蜥孱洮汜祆尼翎歪皈骇屙痿Ж┈蓬趄殄螬п滗燥球狃瑙骢腻沆射腻痼球狃瑭戾计矧麽蜾汜祆尼翎歪皈骇轭箦螋Ж腻沆射腻痼汜祆ы狃螫骇珏臾ě骘蝼狎洄球狃瑭轭戾寄屦罅蝌狴汜祆尼翎渝臾骇麸疹骘熹徕戾Ж腻痼轭戾家弼弪箦汜祆尼翎骑熹徕戾Шф镬潇Ж骢零悻腻鹕洎戾寂轶糸铉汜箦汜祆尼翎歪皈骇祜镫躔Ж腻鹕洮零悌镦姬物翳轭绉麒孱趄蹂汜祆尼翎渝臾骇屙痿Ж见术篝К育麒孱趄蹂孱轭汜祆尼翎歪皈骇轭箦螋Ж腻鹕洮汜祆尼翎渝臾骇轭箦螋Ж腻沆射砒轶糸铉┈零悌汜祆ы狃螫骇珏臾ě蝈鲥蝮濮球狃瑭腻痼硫蜥轭ф矧麽蜾Ы酒矧麽蜾蝈鲥蝮濮骄骢ㄟ墟癌汜祆ъ轶趔Ш蝈鲥蝮濮ㄟ墟癌蝈盹鲥乞镯球狃瑙骢腻沆射球狃瑭戾寄屦缶汜箦汜祆尼翎歪皈骇祜镫躔Ж腻沆射汜祆ы狃螫骇珏臾ě骘蝼狎洄球狃瑭镦姬物翳轭绉麒孱趄蹂汜祆尼翎渝臾骇屙痿Ж见术篝К育麒孱趄蹂孱轭戾计矧麽蜾汜祆尼翎歪皈骇溴戾翦Ж腻沆射汜祆ы狃螫骇珏臾ě骘蝼狎洄球狃瑭轭戾寄屦罅蝌狴汜祆尼翎渝臾骇麸疹骘熹徕戾Ж腻痼轭戾家弼弪箦汜祆尼翎骑熹徕戾Шф镬潇Ж骢零悻腻鹕洎汜箦汜祆尼翎歪皈骇祜镫躔Ж腻鹕洮零悌镦姬物翳轭绉麒孱趄蹂零见术篝К腻疱钿孱趔麒孱趄蹂汜祆尼翎歪皈骇轭箦螋Ж腻鹕洮汜祆尼翎渝臾骇溴戾翦Ж腻沆射腻疱钿孱趔┈零悌孱洮汜祆ы狃螫骇珏臾ě蝈鲥蝮濮球狃瑭腻痼硫蜥轭戾家弼弪箦呔汜祆尼翎歪皈骇溴戾翦Ж腻沆射骢ㄟ墟癌汜祆ъ轶趔Ш蝈鲥蝮濮ㄟ墟癌轭ф矧麽蜾Ы酒矧麽蜾蝈鲥蝮濮骄义鲥蝮暹х弭腻疱钿孱趔Н骢ㄇ蜥痂腻沆射汜箦汜祆尼翎歪皈骇祜镫躔Ж腻沆射汜祆ы狃螫骇珏臾ě蝈鲥蝮濮球狃瑭镦姬物翳轭绉麒孱趄蹂汜祆尼翎渝臾骇屙痿Ж见术篝К育麒孱趄蹂孱х弭腻疱钿孱汩弩湘Н骢ㄇ蜥痂腻沆射汜箦汜祆尼翎歪皈骇祜镫躔Ж腻沆射汜祆ы狃螫骇珏臾ě骘蝼狎洄球狃瑭镦姬物翳轭绉麒孱趄蹂汜祆尼翎渝臾骇屙痿Ж见术篝К育麒孱趄蹂孱х弭伶驽泗邃Н骢ㄇ蜥痂腻沆射戾趄邈х铵骢ㄔ镄蝻沐篌珠箝翦洎汜箦汜祆尼翎渝臾骇骈钿烷瞌ㄔ镄蝻沐篌镦姬物翳轭绉麒孱趄蹂珠箝翦见术篝К射麒孱趄蹂汜箦汜祆尼翎渝臾骇礤礅弪Ж射珠箝翦洎镦姬趄蹂Ь麒孱趄蹂狃痨х铵波汜祆尼翎渝臾骇溴戾翦Ж射燥序镢弩螬珠箝翦洎姬驷祗濮麒孱趄蹂戾寄屦孱溴铘缶狃痨х弭腻疱钿孱趔Н波球狃璎射轭戾嘉鬻燥序镢弩缶汜祆尼翎渝臾骇躅轱瞌ㄣ犰尼翎渝臾骇溴戾翦Ж射燥序镢弩螬汜祆尼翎渝臾骇溟骀弪孱沐Ж腻疱钿孱趔珠箝翦洎轭狃痨х铵波五髟镄蝻沐篌汜祆尼翎渝臾骇轭箦螋Ж射珠箝翦洎孱孱轭狃痨х铵波汜祆尼翎渝臾骇箝铉戾麸瞌腻沆射┈汜祆尼翎渝臾骇屙痿Ж┅麸痫祜玳汜煊矧臾骢ㄇ蜥痂射螬戾忌铋糸犰深腻珧邋汜祆尼翎骑熹徕戾Шф镬潇Ж骢零悻射戾寄屦缶狃痨х弭腻疱钿孱汩弩湘Н波球狃璎射轭戾家屐弼犷裟屦缶汜祆尼翎渝臾骇箝濮ㄣ犰尼翎渝臾骇轭翦蝮邈糸镱Ж腻痼汜祆尼翎渝臾骇骝镯骑熹徕戾Ж射螬┅轭汜祆尼翎歪皈骇轭箦螋Ж射义戾鲠铘腻痼零悌汜祆尼翎歪皈骇屙痿Ж┈射螬轭戾忌铋糸犰氧艴寰汜祆尼翎硫蜥Шф殪翦颛ㄦ躅ㄉ洎汜箦汜祆尼翎歪皈骇祜镫躔Ж射深轸獒焐钅彗蝈濠镦姬物翳轭绉麒孱趄蹂ф犰箦见术篝К锡麒孱趄蹂汜祆у蜢犷绉骇胶涧ㄎ癌孱洮射螬轭戾趄邈х铵骢ㄉ钅彗蝈瀣义篚祠氧艴濠汜箦汜祆尼翎硫蜥Ш躅泔铙Ж氧艴濠镦姬物翳轭绉麒孱趄蹂义篚祠见术篝Кц遽洄航射翎殪Ш揭弩粞蹂蹂> when 'true' ->
        let <AllDependents> = call 'Data.Set':'toUnfoldable'(apply 'getDependents'/2(Graph, Id))
      in let <Dependents> = call 'Data.Array':'filter'(fun (D) ->
      call 'Data.Array':'elem'(D, Ids), AllDependents)
      in let <NewInDegree> = call 'Data.Foldable':'foldl'(fun (Acc, Dep) ->
      case call 'Data.Map':'lookup'(Dep, Acc) of
      <'Nothing'> when 'true' ->
        Acc
      <{'Just', N}> when 'true' ->
        call 'Data.Map':'insert'(Dep, call 'erlang':'-'(N, 1), Acc)
    end, InDegree, Dependents)
      in let <NewQueue> = call 'Nova.Prelude':'semigroupAppendImpl'(RestQueue, call 'Data.Array':'filter'(fun (D) ->
      case call 'Data.Map':'lookup'(D, NewInDegree) of
      <'Nothing'> when 'true' ->
        'false'
      <{'Just', N}> when 'true' ->
        case case call 'erlang':'=:='(N, 0) of <'true'> when 'true' -> call 'erlang':'not'(call 'Data.Array':'elem'(D, Result)) <_> when 'true' -> 'false' end of <'true'> when 'true' -> call 'erlang':'not'(call 'Data.Array':'elem'(D, Queue)) <_> when 'true' -> 'false' end
    end, Dependents))
      in apply 'go'/3(NewInDegree, call 'Data.Array':'snoc'(Result, Id), NewQueue)
    end
      in apply 'go'/3(InitialInDegree, [], InitialQueue)

'getDependencies'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'getDependencies'/1(_A0)
      in _F0

'getModuleDependencies'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'getModuleDependencies'/1(_A0)
      in _F0

'getConstructorDeps'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'getConstructorDeps'/1(_A0)
      in _F0

'getTypeExprDeps'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'getTypeExprDeps'/1(_A0)
      in _F0

'getExprDeps'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'getExprDeps'/1(_A0)
      in _F0

'getLetBindsDeps'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'getLetBindsDeps'/1(_A0)
      in _F0

'getCaseClauseDeps'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'getCaseClauseDeps'/1(_A0)
      in _F0

'getDoStatementsDeps'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'getDoStatementsDeps'/1(_A0)
      in _F0

'getGuardedExprDeps'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'getGuardedExprDeps'/1(_A0)
      in _F0

'getGuardClauseDeps'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'getGuardClauseDeps'/1(_A0)
      in _F0

'getBoundNames'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'getBoundNames'/1(_A0)
      in _F0

'buildDependencyGraph'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'buildDependencyGraph'/2(_A0, _A1)
      in _F1
      in _F0

'buildDependencyGraph'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'buildDependencyGraph'/2(_A0, _A1)
      in _F0

'buildReverseEdges'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'buildReverseEdges'/1(_A0)
      in _F0

'addToGraph'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'addToGraph'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'addToGraph'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'addToGraph'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'addToGraph'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'addToGraph'/3(_A0, _A1, _A2)
      in _F0

'removeFromGraph'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'removeFromGraph'/2(_A0, _A1)
      in _F1
      in _F0

'removeFromGraph'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'removeFromGraph'/2(_A0, _A1)
      in _F0

'getDependents'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'getDependents'/2(_A0, _A1)
      in _F1
      in _F0

'getDependents'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'getDependents'/2(_A0, _A1)
      in _F0

'getDependenciesOf'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'getDependenciesOf'/2(_A0, _A1)
      in _F1
      in _F0

'getDependenciesOf'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'getDependenciesOf'/2(_A0, _A1)
      in _F0

'getAffected'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'getAffected'/2(_A0, _A1)
      in _F1
      in _F0

'getAffected'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'getAffected'/2(_A0, _A1)
      in _F0

'topologicalSort'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'topologicalSort'/2(_A0, _A1)
      in _F1
      in _F0

'topologicalSort'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'topologicalSort'/2(_A0, _A1)
      in _F0

'module_info'/0 = fun () -> call 'erlang':'get_module_info'('Nova.Compiler.Dependencies')

'module_info'/1 = fun (_0) -> call 'erlang':'get_module_info'('Nova.Compiler.Dependencies', _0)
end
