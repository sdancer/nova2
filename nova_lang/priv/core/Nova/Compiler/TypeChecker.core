module 'Nova.Compiler.TypeChecker' ['intToString'/0, 'collectParamTypeAliases'/1, 'collectTypeAliases'/1, 'collectTypeApp'/1, 'collectTypeExprNames'/1, 'collectTypeNames'/1, 'expandModuleAliases'/1, 'exprToPattern'/1, 'extractExports'/1, 'getExportedNames'/1, 'getImportItemName'/1, 'guardClauseToCondExpr'/1, 'guardedExprsToIf'/1, 'guardsToCondition'/1, 'inferLit'/1, 'isRecordType'/1, 'mergeMultiClauseFunctions'/1, 'showExprShort'/1, 'unifyEnv'/1, 'addErrorContext'/2, 'addFunctionPlaceholders'/2, 'buildPatternGuardCases'/2, 'checkDataType'/2, 'checkDecl'/2, 'checkFunction'/2, 'checkFunctionBodies'/2, 'checkFunctionBodiesGo'/2, 'checkModuleSimple'/2, 'checkTypeAlias'/2, 'checkTypeClass'/2, 'collectImportedAliases'/2, 'collectResolvedImports'/2, 'extractExportsWithRegistry'/2, 'generalize'/2, 'infer'/2, 'inferBinds'/2, 'inferDo'/2, 'inferFields'/2, 'inferGuard'/2, 'inferGuardExpr'/2, 'inferMany'/2, 'instantiate'/2, 'listMapWithIndex'/2, 'mergeExportsWithTypeAliases'/2, 'mkInstResult'/2, 'processInfixDeclarations'/2, 'processNonFunctions'/2, 'typeExprToType'/2, 'withContext'/2, 'wrapWithPatternGuards'/2, 'addFunctionPlaceholdersWithAliases'/3, 'addValuesToExports'/3, 'buildConstructorType'/3, 'buildConstructorTypeGo'/3, 'checkDataTypeWithAliases'/3, 'checkModule'/3, 'checkNewtypeWithAliases'/3, 'collectFromImportDecl'/3, 'collectTypeAliasesWithBase'/3, 'importItem'/3, 'inferElems'/3, 'inferListPat'/3, 'inferPat'/3, 'inferRecordPat'/3, 'inferRecordUpdate'/3, 'inferUnaryOp'/3, 'processImportDecl'/3, 'processImports'/3, 'processNonFunctionsWithAliases'/3, 'typeCheckModule'/3, 'typeExprToTypeWithAliases'/3, 'buildConstructorTypeWithAliases'/4, 'buildConstructorTypeWithAliasesGo'/4, 'checkDataTypeWithAllAliases'/4, 'checkNewtypeWithAllAliases'/4, 'inferConPats'/4, 'inferConsPat'/4, 'inferElemsGo'/4, 'inferFieldsGo'/4, 'inferManyGo'/4, 'instantiateGo'/4, 'substituteTypeExpr'/4, 'typeExprToTypeWithAllAliases'/4, 'buildConstructorTypeWithAllAliases'/5, 'buildConstructorTypeWithAllAliasesGo'/5, 'inferClauses'/5, 'inferClausesGo'/5, 'inferConPatsGo'/5, 'inferRecordPatGo'/5, 'typeExprToTypeWithEnv'/5, 'UnifyErr'/1, 'UnifyErrWithContext'/2, 'UnboundVariable'/1, 'UndefinedQualifiedImport'/2, 'NotImplemented'/1, 'collectParamTypeAliases'/0, 'collectTypeAliases'/0, 'collectTypeApp'/0, 'collectTypeExprNames'/0, 'collectTypeNames'/0, 'expandModuleAliases'/0, 'exprToPattern'/0, 'extractExports'/0, 'getExportedNames'/0, 'getImportItemName'/0, 'guardClauseToCondExpr'/0, 'guardedExprsToIf'/0, 'guardsToCondition'/0, 'inferLit'/0, 'isRecordType'/0, 'mergeMultiClauseFunctions'/0, 'showExprShort'/0, 'unifyEnv'/0, 'addErrorContext'/0, 'addErrorContext'/1, 'addFunctionPlaceholders'/0, 'addFunctionPlaceholders'/1, 'buildPatternGuardCases'/0, 'buildPatternGuardCases'/1, 'checkDataType'/0, 'checkDataType'/1, 'checkDecl'/0, 'checkDecl'/1, 'checkFunction'/0, 'checkFunction'/1, 'checkFunctionBodies'/0, 'checkFunctionBodies'/1, 'checkFunctionBodiesGo'/0, 'checkFunctionBodiesGo'/1, 'checkModuleSimple'/0, 'checkModuleSimple'/1, 'checkTypeAlias'/0, 'checkTypeAlias'/1, 'checkTypeClass'/0, 'checkTypeClass'/1, 'collectImportedAliases'/0, 'collectImportedAliases'/1, 'collectResolvedImports'/0, 'collectResolvedImports'/1, 'extractExportsWithRegistry'/0, 'extractExportsWithRegistry'/1, 'generalize'/0, 'generalize'/1, 'infer'/0, 'infer'/1, 'inferBinds'/0, 'inferBinds'/1, 'inferDo'/0, 'inferDo'/1, 'inferFields'/0, 'inferFields'/1, 'inferGuard'/0, 'inferGuard'/1, 'inferGuardExpr'/0, 'inferGuardExpr'/1, 'inferMany'/0, 'inferMany'/1, 'instantiate'/0, 'instantiate'/1, 'listMapWithIndex'/0, 'listMapWithIndex'/1, 'mergeExportsWithTypeAliases'/0, 'mergeExportsWithTypeAliases'/1, 'mkInstResult'/0, 'mkInstResult'/1, 'processInfixDeclarations'/0, 'processInfixDeclarations'/1, 'processNonFunctions'/0, 'processNonFunctions'/1, 'typeExprToType'/0, 'typeExprToType'/1, 'withContext'/0, 'withContext'/1, 'wrapWithPatternGuards'/0, 'wrapWithPatternGuards'/1, 'addFunctionPlaceholdersWithAliases'/0, 'addFunctionPlaceholdersWithAliases'/1, 'addFunctionPlaceholdersWithAliases'/2, 'addValuesToExports'/0, 'addValuesToExports'/1, 'addValuesToExports'/2, 'buildConstructorType'/0, 'buildConstructorType'/1, 'buildConstructorType'/2, 'buildConstructorTypeGo'/0, 'buildConstructorTypeGo'/1, 'buildConstructorTypeGo'/2, 'checkDataTypeWithAliases'/0, 'checkDataTypeWithAliases'/1, 'checkDataTypeWithAliases'/2, 'checkModule'/0, 'checkModule'/1, 'checkModule'/2, 'checkNewtypeWithAliases'/0, 'checkNewtypeWithAliases'/1, 'checkNewtypeWithAliases'/2, 'collectFromImportDecl'/0, 'collectFromImportDecl'/1, 'collectFromImportDecl'/2, 'collectTypeAliasesWithBase'/0, 'collectTypeAliasesWithBase'/1, 'collectTypeAliasesWithBase'/2, 'importItem'/0, 'importItem'/1, 'importItem'/2, 'inferElems'/0, 'inferElems'/1, 'inferElems'/2, 'inferListPat'/0, 'inferListPat'/1, 'inferListPat'/2, 'inferPat'/0, 'inferPat'/1, 'inferPat'/2, 'inferRecordPat'/0, 'inferRecordPat'/1, 'inferRecordPat'/2, 'inferRecordUpdate'/0, 'inferRecordUpdate'/1, 'inferRecordUpdate'/2, 'inferUnaryOp'/0, 'inferUnaryOp'/1, 'inferUnaryOp'/2, 'processImportDecl'/0, 'processImportDecl'/1, 'processImportDecl'/2, 'processImports'/0, 'processImports'/1, 'processImports'/2, 'processNonFunctionsWithAliases'/0, 'processNonFunctionsWithAliases'/1, 'processNonFunctionsWithAliases'/2, 'typeCheckModule'/0, 'typeCheckModule'/1, 'typeCheckModule'/2, 'typeExprToTypeWithAliases'/0, 'typeExprToTypeWithAliases'/1, 'typeExprToTypeWithAliases'/2, 'buildConstructorTypeWithAliases'/0, 'buildConstructorTypeWithAliases'/1, 'buildConstructorTypeWithAliases'/2, 'buildConstructorTypeWithAliases'/3, 'buildConstructorTypeWithAliasesGo'/0, 'buildConstructorTypeWithAliasesGo'/1, 'buildConstructorTypeWithAliasesGo'/2, 'buildConstructorTypeWithAliasesGo'/3, 'checkDataTypeWithAllAliases'/0, 'checkDataTypeWithAllAliases'/1, 'checkDataTypeWithAllAliases'/2, 'checkDataTypeWithAllAliases'/3, 'checkNewtypeWithAllAliases'/0, 'checkNewtypeWithAllAliases'/1, 'checkNewtypeWithAllAliases'/2, 'checkNewtypeWithAllAliases'/3, 'inferConPats'/0, 'inferConPats'/1, 'inferConPats'/2, 'inferConPats'/3, 'inferConsPat'/0, 'inferConsPat'/1, 'inferConsPat'/2, 'inferConsPat'/3, 'inferElemsGo'/0, 'inferElemsGo'/1, 'inferElemsGo'/2, 'inferElemsGo'/3, 'inferFieldsGo'/0, 'inferFieldsGo'/1, 'inferFieldsGo'/2, 'inferFieldsGo'/3, 'inferManyGo'/0, 'inferManyGo'/1, 'inferManyGo'/2, 'inferManyGo'/3, 'instantiateGo'/0, 'instantiateGo'/1, 'instantiateGo'/2, 'instantiateGo'/3, 'substituteTypeExpr'/0, 'substituteTypeExpr'/1, 'substituteTypeExpr'/2, 'substituteTypeExpr'/3, 'typeExprToTypeWithAllAliases'/0, 'typeExprToTypeWithAllAliases'/1, 'typeExprToTypeWithAllAliases'/2, 'typeExprToTypeWithAllAliases'/3, 'buildConstructorTypeWithAllAliases'/0, 'buildConstructorTypeWithAllAliases'/1, 'buildConstructorTypeWithAllAliases'/2, 'buildConstructorTypeWithAllAliases'/3, 'buildConstructorTypeWithAllAliases'/4, 'buildConstructorTypeWithAllAliasesGo'/0, 'buildConstructorTypeWithAllAliasesGo'/1, 'buildConstructorTypeWithAllAliasesGo'/2, 'buildConstructorTypeWithAllAliasesGo'/3, 'buildConstructorTypeWithAllAliasesGo'/4, 'inferClauses'/0, 'inferClauses'/1, 'inferClauses'/2, 'inferClauses'/3, 'inferClauses'/4, 'inferClausesGo'/0, 'inferClausesGo'/1, 'inferClausesGo'/2, 'inferClausesGo'/3, 'inferClausesGo'/4, 'inferConPatsGo'/0, 'inferConPatsGo'/1, 'inferConPatsGo'/2, 'inferConPatsGo'/3, 'inferConPatsGo'/4, 'inferRecordPatGo'/0, 'inferRecordPatGo'/1, 'inferRecordPatGo'/2, 'inferRecordPatGo'/3, 'inferRecordPatGo'/4, 'typeExprToTypeWithEnv'/0, 'typeExprToTypeWithEnv'/1, 'typeExprToTypeWithEnv'/2, 'typeExprToTypeWithEnv'/3, 'typeExprToTypeWithEnv'/4, 'UnifyErr'/0, 'UnifyErrWithContext'/0, 'UnifyErrWithContext'/1, 'UnboundVariable'/0, 'UndefinedQualifiedImport'/0, 'UndefinedQualifiedImport'/1, 'NotImplemented'/0, 'module_info'/0, 'module_info'/1]
  attributes []
% Data type: TCError
% Constructors: UnifyErr, UnifyErrWithContext, UnboundVariable, UndefinedQualifiedImport, NotImplemented

'UnifyErr'/1 =
  fun (V0) ->
    {'UnifyErr', V0}

'UnifyErrWithContext'/2 =
  fun (V0, V1) ->
    {'UnifyErrWithContext', V0, V1}

'UnboundVariable'/1 =
  fun (V0) ->
    {'UnboundVariable', V0}

'UndefinedQualifiedImport'/2 =
  fun (V0, V1) ->
    {'UndefinedQualifiedImport', V0, V1}

'NotImplemented'/1 =
  fun (V0) ->
    {'NotImplemented', V0}

'intToString'/0 =
  fun () ->
    fun (_Pf0) -> call 'erlang':'integer_to_list'(_Pf0)

'collectParamTypeAliases'/1 =
  fun (Decls) ->
    letrec 'collect'/2 = fun (_L0, _L1) ->
      case {_L0, _L1} of
        <{M, {'DeclTypeAlias', Ta}}> when 'true' -> call 'Data.Map':'insert'(call 'maps':'get'('name', Ta), ю狎犴螫骄汜祆尼翎硫蜥Шф蝻砥镬溽忪濮ㄣ犰ы狃螫骇珏臾ě豉疱轴蝮К葬┅р镤Ы俱犰ы狃螫骇珏臾ě豉К葬桐见同咦褒麒孱趄蹂孱轭汜祆尼翎硫蜥Шф镬潇Ж骢ㄟ玩艾咄姹狃痨с镬戾泗Н波咄姘咄姹┈汜祆尼翎歪皈骇屙痿Ж┈腻沆螬с镬戾泗赠疱领獒箦螫骢腻沆螬狃痨с镬戾泗赠疱领獒箦笞轸杪狍濮敞汜祆尼翎歪皈骇屙痿Ж┈狃痨с镬戾泗嗅蜥碓疱领獒箦螫报腻沆螬腻沆螬с镬戾泗赠疱琉皈骢ㄟ邪汜箦咝褒镦见г砒痱蔑瞌吾礤麒孱趄蹂汜祆尼翎怎痨濮骇怎痨濮ㄎ犴瀣圯见г砒痱琉皈片硫琮麒孱趄蹂戾歼体舭狃痨с镬戾泗赠疱琉皈报譬轭汜箦咛弭镦见г躔戾К吾礤硫珞麒孱趄蹂汜祆尼翎怎痨濮骇怎痨濮ㄎ犴瀣汜祆尼翎硫蜥Ш箢镢Ж硫珞硫绌孱见咦褒麒孱趄蹂汜祆尼翎怎痨濮骇怎痨濮ǎ，圯孱с镬戾泗赠疱砒痱吾礤螫骢ㄟ邪汜箦咝褒镦见г砒痱轴颛咦褒麒孱趄蹂汜祆尼翎渝臾骇屙痿Ж见г砒痱蔑瞌吾礤麒孱趄蹂汜祆尼翎渝臾骇箝铉戾麸瞌ㄎ犴濠见г砒痱琉皈片硫琮麒孱趄蹂汜祆尼翎渝臾骇躅轱瞌ㄡ痧禊с镬戾泗赠疱砒痱吾礤螫报譬狃痨с镬戾泗赠疱砒痱吾礤螫报硫绌见г砒痱硫蝻鳔连慢麒孱趄蹂汜祆尼翎渝臾骇躅轱瞌ㄡ痧禊с镬戾泗赠疱砒痱吾礤螫报俩狃痨с镬戾泗赠疱砒痱吾礤螫报漏见г砒痱义泔蜾К崎屐潴咦褒麒孱趄蹂汜祆尼翎硫蜥Шф镬潇Ж骢ㄟ贪咛暴汜箦咛艾咛饼镦见蝇г躔戾К咦艾札麒孱趄蹂汜祆尼翎渝臾骇躅轱瞌ㄓ狃痨с镬戾泗赠疱砒痱吾礤螫报冤孱洮汜祆尼翎渝臾骇屙痿Ж┈汜祆尼翎硫蜥Шф蝻砥镬溽忪濮ㄆ殄熹螬见г砒痱骑蛄祆К咦艾札麒孱趄蹂狃痨с镬戾泗赠疱砒痱吾礤螫报冤见г砒痱蔑铙趄衢铄洄咦艾札麒孱趄蹂狃痨с镬戾泗赠疱砒痱吾礤螫报冤见г砒痱嗅蝈铙К札麒孱趄蹂狃痨с镬戾泗赠疱砒痱吾礤螫报冤见г砒痱怎痨濮泽麒孱趄蹂汜祆尼翎涕篝Шф镬潇Ж骢ㄓ冤汜祆尼翎渝臾骇躅轱瞌ㄓ狃痨с镬戾泗赠疱砒痱吾礤螫报冤┈汜祆尼翎渝臾骇屙痿Ж┈泽孱с镬戾泗赠疱吾礤螫骢ㄟ邪汜箦咝褒镦见г轴颛咦褒麒孱趄蹂汜祆尼翎渝臾骇屙痿Ж见г蔑瞌糟麒孱趄蹂戾剂蜱笪犴弩汜祆尼翎硫蜥Шф镬潇Ж骢ㄓ冤汜祆尼翎渝臾骇躅轱瞌ㄓ狃痨с镬戾泗赠疱吾礤螫报冤┈汜祆尼翎渝臾骇屙痿Ж┈汜祆ы狃螫骇珏臾ě狎珞К糟┅轭汜祆尼翎渝臾骇轭箦螋Ж汜祆ы狃螫骇珏臾ě钺礤К糟┈硫珞吾礤螬见г义泔蜾К引麒孱趄蹂戾计殄熹吾礤缶汜祆尼翎歪皈骇鲠祯弩Ж汜祆ы狃螫骇珏臾ě骈屐潴К药轭戾计殄熹笥弭汜祆尼翎硫蜥Шф镬潇Ж骢ㄓ冤汜祆尼翎渝臾骇躅轱瞌ㄓ狃痨с镬戾泗赠疱吾礤螫报冤┈汜祆尼翎渝臾骇屙痿Ж┈汜祆尼翎硫蜥Шф蝻砥镬溽忪濮ㄆ殄熹吾礤螬轭崎屐潴渝见г琉皈片硫琮麒孱趄蹂汜祆尼翎渝臾骇躅轱瞌ㄡ痧禊с镬戾泗赠疱吾礤螫报譬狃痨с镬戾泗赠疱吾礤螫报硫绌孱у疳钿惋漉戾领獒箦螫骢领獒笊铈矬戾忌铋糸犰汜祆尼翎歪皈骇磲鹜狴忮Ж骢ㄉ铈铹汜箦汜祆尼翎硫蜥Шь蹯歆ㄣ犰物鲠蔑眇殪弪赠疱螫骇珏袅扉狍深骘嗅蜥眢Ж深骘┅镦姬趄蹂Ь麒孱趄蹂术篝К狃痨豉疱砒痱燥赠疱Н波汜祆尼翎歪皈骇屙痿Ж┈汜祆物鲠蔑眇殪弪赠疱螫骇珏袅扉狍深骘嘛澌Ж深骘┅姬驷祗濮麒孱趄蹂物翳轭绉孱洮领獒笊铈矬轭戾夹狍蟛汜祆尼翎歪皈骇磲鹜狴忮Ж骢ㄉ铈铹汜箦汜祆尼翎硫蜥Шь蹯歆ㄣ犰物鲠蔑眇殪弪赠疱螫骇珏袅扉狍深骘嗅蜥眢Ж深骘┅镦姬趄蹂Ь麒孱趄蹂术篝К狃痨豉疱砒痱燥赠疱组翳领炝扉狍弩Н川深轸獒飕领獒笊铈矬汜祆尼翎歪皈骇屙痿Ж┈汜祆物鲠蔑眇殪弪赠疱螫骇珏袅扉狍深骘嘛澌Ж深骘┅姬驷祗濮麒孱趄蹂物翳轭绉孱洮领獒笊铈矬轭戾夹狍蟪汜祆尼翎歪皈骇磲鹜狴忮Ж骢ㄉ铈铹汜箦汜祆尼翎硫蜥Шь蹯歆ㄣ犰物鲠蔑眇殪弪赠疱螫骇珏袅扉狍深骘嗅蜥眢Ж深骘┅镦姬趄蹂Ь麒孱趄蹂术篝К狃痨豉疱砒痱燥赠疱组翳领炝扉狍弩Н川嗅篌铂领獒笊铈矬汜祆尼翎歪皈骇屙痿Ж┈汜祆物鲠蔑眇殪弪赠疱螫骇珏袅扉狍深骘嘛澌Ж深骘┅姬驷祗濮麒孱趄蹂物翳轭绉孱洮领獒笊铈矬轭嗅篌у痱燥嗅趑弪瞌骢ㄟ邪汜箦咝褒镦见砒痱轴颛吾礤麒孱趄蹂嗅糁狎К吾礤见砒痱琉皈砒痱轴颛蔑铨硫琮麒孱趄蹂嗅裘镱К蔑瞵坩痧禊у痱燥嗅趑弪瞌报硫绌圯蔟见砒痱琉皈砒痱琉皈砒痱轴颛蔑铨硫绫硫绮麒孱趄蹂嗅裘镱К蔑瞵坩痧禊у痱燥嗅趑弪瞌报硫绫坩痧禊у痱燥嗅趑弪瞌报硫绮圯葺见砒痱涕臾涕酏麒孱趄蹂嗅籼轸К涕酏见砒痱嗅蝈铙К琵麒孱趄蹂狃痨у痱燥嗅趑弪瞌报农见咦褒麒孱趄蹂嗅糇殪溷狎洄孱у趄徙襞痫螋螫骢腻沆螬狃痨у趄徙襞痫螋笞轸枰彗轶趄Н波汜祆物鲠蔑眇殪弪赠疱螫骇溴驷蹯粢彗轶趄Ж┈腻沆螬х弭砒痫螋邃吾礤螫骢ㄅ痫螋螬戾贾犰蹂吾礤缶汜祆ъ轶趔Шы狃Ж骢ㄟ贪汜箦咛褒镦见г躔戾К爽咦褒麒孱趄蹂孱洮汜祆尼翎歪皈骇麸疹骘熹徕戾Ж汜祆ы狃螫骇珏臾ě鲠祯弩К砒痫螋螬┅轭戾济麸蛭犴弩汜祆ъ轶趔Шы狃Ж骢ㄟ贪汜箦咛褒镦见г躔戾К爽咦褒麒孱趄蹂孱洮汜祆尼翎歪皈骇麸疹骘熹徕戾Ж汜祆ы狃螫骇珏臾ě泔铙趄蹉麸蝮К砒痫螋螬┅轭汜祆物鲠序屐蹁濮骇箦黹珧秕鹆痧孱渖眇歆ㄖ犰蹂吾礤蟋敏矧吾礤螬х弭身痫螋婶屙吾礤Н骢ㄟ邪汜箦咝褒镦见身痫螋轴祯濮吾礤麒孱趄蹂吾礤见身痫螋赠疱К吾礤咦褒麒孱趄蹂吾礤孱х踽蜾渺狨箦燥蔑钿砒痱Н骢ㄟ邪汜箦咝褒镦见酋狎渑痱К琵麒孱趄蹂见酋狎湫狒К咦艾咦饼麒孱趄蹂砒痱轴颛｛＜北毒ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北淳ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北肪ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺｝孱х踽蜾邃砒痱笤锷妲骢ㄟ邪汜箦咝褒镦见圯麒孱趄蹂砒痱轴颛｛＜北肪ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北熬ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑熬ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑簿ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑稻ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北熬ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑熬ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺｝见矍妩圯蔟麒孱趄蹂狃痨黩狃组翳嗅趑弪钋踽蜾螫波汜祆ы狃螫骇珏臾ě珲狎潴К清┈汜祆ы狃螫骇珏臾ě怙澌К清┅见矍妩义篝蔟麒孱趄蹂戾寂祗迮痱狃痨х踽蜾邃砒痱笤锷妲报义篝轭戾荚桢盥镤狃痨黩狃组翳嗅趑弪钋踽蜾螫波汜祆ы狃螫骇珏臾ě珲狎潴К清┈汜祆ы狃螫骇珏臾ě怙澌К清┅轭戾济镱渚狃痨х踽蜾笤锩镱溟糸镱Н报汜祆ы狃螫骇珏臾ě珲狎潴К清┅轭砒痱涉К蔑钿澡孱嘛澌澎箦砒痱孱х踽蜾笤锩镱溟糸镱Н骢ㄟ邪汜箦咝褒镦见圯麒孱趄蹂砒痱轴颛｛＜北毒ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北淳ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北肪ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺｝见矍泓圯蔟麒孱趄蹂狃痨х踽蜾渺狨箦燥蔑钿砒痱Н报倾见矍泓义篝蔟麒孱趄蹂砒痱麻钕皈｛＜掣鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜掣鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺，狃痨х踽蜾渺狨箦燥蔑钿砒痱Н报倾┈狃痨х踽蜾笤锩镱溟糸镱Н报义篝孱ч铈弪涕臾骢ㄟ邪汜箦咝褒镦见涕羯铘К咦褒麒孱趄蹂汜祆物鲠蔑眇殪弪赠疱螫骇羯铘Ж见涕粑蹴忮颛咦褒麒孱趄蹂г蔑瞌戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇黼悦镱Ж｛＜犯鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北肪ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑咕ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜垢鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北淳ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺）轭狃痨呦岚ㄛ荸见涕粲趄轭绉咦褒麒孱趄蹂汜祆物鲠蔑眇殪弪赠疱螫骇粲趄轭绉ī见涕裘栳颛咦褒麒孱趄蹂汜祆物鲠蔑眇殪弪赠疱螫骇裘栳颛ī见涕袈镲歆咦褒麒孱趄蹂汜祆物鲠蔑眇殪弪赠疱螫骇袈镲歆ī孱ч笠邈矧湓疱Н骢ㄟ邪汜箦咝褒镦见г义泔蜾К咦褒麒孱趄蹂趄蹂见咦褒麒孱趄蹂ф犰箦孱ы弪珏王祠槊灬躞迤躅泗轱铙Н骢腻沆螬戾趄邈с灬躞逶锩狍迕灬躞濮骢ㄟ装契钽汜箦汜祆尼翎涕篝Шц遽洄ㄣ犰ы狃螫骇珏臾ě疳蜥礤翦蝮К契钽┅镦姬物翳轭绉麒孱趄蹂物翳轭绉见术篝К嗅酏麒孱趄蹂术篝Кю狒翦蝾Ы拘狒р镤Ы俱犰ы狃螫骇珏臾ě怙澌К契钽┈х踽蜾Ы晶物翳轭绉
    end
       'clauseToTupleCase'/2 = fun (_W0, Func) ->
      let <N> = call 'Data.List':'length'(call 'maps':'get'('parameters', Func))
      in let <TupName> = case call 'erlang':'=:='(N, 2) of
      <'true'> when 'true' -> #{#<84>(8,1,'integer',['unsigned'|['big']]),#<117>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']]),#<108>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']])}#
      <'false'> when 'true' -> call 'Nova.Prelude':'semigroupAppendImpl'(#{#<84>(8,1,'integer',['unsigned'|['big']]),#<117>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']]),#<108>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']])}#, let <_Fn0> = apply 'intToString'/0()
      in apply _Fn0(N))
    end
      in case call 'erlang':'>'(N, 1) of
      <'true'> when 'true' -> {'Just', ю狒翦蝾Ы钧嗅裘镱К怎鹞犴瀣汜祆ы狃螫骇珏臾ě疳蜥礤翦蝮К契钽р镤Ы俱犰ы狃螫骇珏臾ě怙澌К契钽┈х踽蜾Ы晶物翳轭绉
      <'false'> when 'true' -> apply 'clauseToCaseClause'/2([], Func)
    end
       'collectSameName'/3 = fun (Name, Ds, Acc) ->
      case call 'Data.Array':'uncons'(Ds) of
      <'Nothing'> when 'true' ->
        筢礤吾礤Ы玖沣蝈磲轭轭绉骄圯见术篝Кц遽洄航腻沆契钽糸镱К讫翎殪Ш揭弩酏> when 'true' ->
        case call 'erlang':'=:='(call 'maps':'get'('name', F), Name) of
      <'true'> when 'true' -> apply 'collectSameName'/3(Name, Rest, call 'Data.Array':'snoc'(Acc, F))
      <'false'> when 'true' -> 筢礤吾礤Ы玖沣蝈磲轭轭绉骄捏孱见术篝К咦褒麒孱趄蹂筢礤吾礤Ы玖沣蝈磲轭轭绉骄捏孱х锿弪珏Н骢捏零悌汜箦汜祆尼翎硫蜥Ш躅泔铙Ж捏镦姬物翳轭绉麒孱趄蹂汜祆尼翎硫蜥Ш蝈鲥蝮濮零悌见术篝Кц遽洄航默翎殪Ш揭弩酏> when 'true' ->
        case D of
      <{'DeclFunction', Func}> when 'true' ->
        let <_Let0> = apply 'collectSameName'/3(call 'maps':'get'('name', Func), Rest, [])
      in case _Let0 of
        <筢礤吾礤Ш接犴逦犴瀣蝈磲轭轭绉航义磲轭轭琮麒孱趄蹂戾剂祆渺狨箦缶汜祆尼翎硫蜥Шс镱螫ㄆ躅悻俞礤吾礤轭汜箦汜祆у蜢犷绉骇晶ㄣ犰尼翎硫蜥Шъ孱玺瑙领烀灬躞弩┈暴镦姬趄蹂Ь麒孱趄蹂狃痨х锿弪珏Н波义磲轭轭绗汜祆尼翎硫蜥Шс镱螫腻沆契钽糸镱К狃痨ы弪珏渺狨箦笊铘锵铄Н报领烀灬躞弩零悌姬驷祗濮麒孱趄蹂狃痨х锿弪珏Н波义篝汜祆尼翎硫蜥Шс镱螫默零悌孱孱歼装麒孱趄蹂狃痨х锿弪珏Н波义篝汜祆尼翎硫蜥Шс镱螫默零悌孱孱ы弪珏渺狨箦笊铘锵铄Н骢渺狨箦螬汜箦汜祆尼翎硫蜥Шц遽洄渺狨箦螬镦姬物翳轭绉麒孱趄蹂ь犴濮骄｛，ю狎犴弭弪螫骄圯р镤Ы钧砒痱轴颛｛＜卑本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北淳ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北淳ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北淳ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺｝х踽蜾螫骄圯豉疱娱珙狒躜濮骄物翳轭绉见术篝К崎蝮酏麒孱趄蹂戾嘉犴寰汜祆ы狃螫骇珏臾ě钺礤К崎蝮舂轭戾嘉蹴嗅蜥眢汜祆尼翎涕篝Шъ孱玺瑙ㄣ犰ы狃螫骇珏臾ě疳蜥礤翦蝮К崎蝮舂轭戾济灬躞弩涕篝汜祆尼翎涕篝Шф蝻砥镬溽忪濮渺狨箦螬轭戾夹狎犴吾礤缶汜祆ъ轶趔Шы狃Ж骢ㄉ汜祆物鲠序屐蹁濮骇箦黹珧秕鹆痧孱渖眇歆ǎ＜沟鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜沟鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜狗鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北淳ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑尘ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺，戾歼祁熬狃痨ч铘燥郁蜷铉Н皑轭狃痨咂畎ㄉ┅汜祆尼翎涕篝Ш蜥铉濮ò汜祆у蜢犷绉骇Ж熙硇狎犴蟋暴┅轭戾夹狎犴嗅趔汜祆ъ轶趔Шы狃Ж骢ㄎ嗅糁狎К锡嗅蜥砦犴弩轭戾夹狎犴轴蝮汜祆ъ轶趔Шы狃Ж骢ㄎ砒痱轴颛锡嗅蜥砦犴弩轭戾济狍迕灬躞弩汜祆尼翎涕篝Шы狃歪忮Ж骢ㄟ秀癌狃痨с灬躞逶锩狍迕灬躞濮波嗅蜥碇狎蟋咝惆┈渺狨箦筇轶舂轭戾济狍迮痱汜箦熙硇狎犴镦及麒孱趄蹂汜祆ы狃螫骇珏臾ě怙澌К崎蝮舂急麒孱趄蹂汜箦汜祆尼翎涕篝Шц遽洄ㄐ狎犴轴蝮镦见术篝К铸麒孱趄蹂砒痱冕箦К脂冕箦渺狨箦簖姬物翳轭绉麒孱趄蹂汜祆ы狃螫骇珏臾ě怙澌К崎蝮舂孱歼装麒孱趄蹂砒痱冕箦К砒痱怎痨濮嗅蜥碇狎簖汜祆尼翎涕篝Шы狃歪忮Ж骢ㄟ秀癌狃痨с灬躞逶镌躔戾冕箦Н波嗅蜥碇狎蟋咝惆┈渺狨箦筇轶舂孱轭ь犴濮骄吾礤ю狎犴弭弪螫骄嗅蜥硇狒蟋р镤Ы久狍迮痱х踽蜾螫骄圯豉疱娱珙狒躜濮骄汜祆ы狃螫骇珏臾ě豉疱娱珙狒躜濮崎蝮舂孱轭狃痨х锿弪珏Н波腻沆蟋圯箬秣砒痱予矧臾骢ㄟ邪汜箦咝褒镦见砒痱轴颛锡麒孱趄蹂见砒痱氧犰殒殄洄同锡麒孱趄蹂汜祆物鲠序屐蹁濮骇箦黹珧秕鹆痧孱渖眇歆ㄣ犰物鲠序屐蹁濮骇箦黹珧秕鹆痧孱渖眇歆ㄍ｛＜炊鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺）惟见砒痱涕臾涕羯铘К锡麒孱趄蹂汜祆у蜢犷绉骇轭翦珏蜻麸哽轶臾ㄎ见砒痱涕臾涕粲趄轭绉育麒孱趄蹂汜祆物鲠序屐蹁濮骇箦黹珧秕鹆痧孱渖眇歆ㄣ犰物鲠序屐蹁濮骇箦黹珧秕鹆痧孱渖眇歆ǎ＜炒鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺，汜祆尼翎郁蜷铉Ш翎脲Ж舶萤┈｛＜炒鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺）见砒痱涕臾涕袈镲歆慢麒孱趄蹂汜箦镦姬趄蹂Ь麒孱趄蹂｛＜北毒ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北淳ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北肪ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺姬驷祗濮麒孱趄蹂｛＜卑簿ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜狗鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑妇ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北稻ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺孱见砒痱涕臾咦褒麒孱趄蹂｛＜栋鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑妇ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑稻ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北毒ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜恫鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺见砒痱琉皈片笼麒孱趄蹂汜祆物鲠序屐蹁濮骇箦黹珧秕鹆痧孱渖眇歆ㄣ犰物鲠序屐蹁濮骇箦黹珧秕鹆痧孱渖眇歆ㄣ犰物鲠序屐蹁濮骇箦黹珧秕鹆痧孱渖眇歆ㄣ犰物鲠序屐蹁濮骇箦黹珧秕鹆痧孱渖眇歆ǎ＜窗鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺，狃痨箬秣砒痱予矧臾报譬┈｛＜巢鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺）狃痨箬秣砒痱予矧臾报俩┈｛＜幢鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺）见砒痱提礅溽К咦艾咦饼麒孱趄蹂｛＜栋鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑妇ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜狗鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑咕ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜垢鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑熬ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜狗鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜恫鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺见砒痱体臾咦艾咦饼麒孱趄蹂｛＜栋鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑妇ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北毒ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜恫鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺见砒痱涉К咦艾咦爆咦昌麒孱趄蹂｛＜栋鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑稻ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑簿ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜恫鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺见砒痱冕箦К咦艾咦饼麒孱趄蹂｛＜栋鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜构鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜狗鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北稻ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜恫鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺见砒痱麻钕皈橡咦艾咦饼麒孱趄蹂汜祆物鲠序屐蹁濮骇箦黹珧秕鹆痧孱渖眇歆ㄣ犰物鲠序屐蹁濮骇箦黹珧秕鹆痧孱渖眇歆ǎ＜栋鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜垢鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑稻ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北熬ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北簿ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜巢鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺，橡┈｛＜恫鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺）见砒痱义泔蜾К咦褒麒孱趄蹂｛＜栋鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北淳ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜构鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北淳ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑熬ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜恫鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺见砒痱义泔蜾零沐篌К努讫麒孱趄蹂汜祆物鲠序屐蹁濮骇箦黹珧秕鹆痧孱渖眇歆ㄣ犰物鲠序屐蹁濮骇箦黹珧秕鹆痧孱渖眇歆ㄡ痧禊箬秣砒痱予矧臾报农｛＜炊鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺）譬见砒痱义泔蜾震溽翦К咦艾咦饼麒孱趄蹂｛＜栋鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北淳ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜构鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北淳ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑熬ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜吹鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北肪ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北簿ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑熬ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜狗鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北毒ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜恫鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺见砒痱涕篝К咦褒麒孱趄蹂｛＜栋鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑妇ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑稻ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北稻ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北毒ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜恫鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺见砒痱娘К咦褒麒孱趄蹂｛＜栋鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑熬ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜恫鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺见砒痱嗅蝈铙К琵麒孱趄蹂狃痨箬秣砒痱予矧臾报农见砒痱赠疱洄努咦褒麒孱趄蹂狃痨箬秣砒痱予矧臾报农见砒痱疹狎橡К橡咦褒麒孱趄蹂汜祆物鲠序屐蹁濮骇箦黹珧秕鹆痧孱渖眇歆ㄣ犰物鲠序屐蹁濮骇箦黹珧秕鹆痧孱渖眇歆ǎ＜栋鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北肪ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北熬ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜狗鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北淳ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜辈本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜巢鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺，橡┈｛＜恫鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺）见砒痱怎痨濮咦褒麒孱趄蹂｛＜栋鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北毒ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北肪ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北簿ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑妇ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜恫鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺见砒痱渝泗轱瞌育麒孱趄蹂汜祆物鲠序屐蹁濮骇箦黹珧秕鹆痧孱渖眇歆ㄣ犰物鲠序屐蹁濮骇箦黹珧秕鹆痧孱渖眇歆ǎ＜窗鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺，萤｛＜幢鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺）见砒痱渝泗轱钐彐臾努橡麒孱趄蹂汜祆物鲠序屐蹁濮骇箦黹珧秕鹆痧孱渖眇歆ㄣ犰物鲠序屐蹁濮骇箦黹珧秕鹆痧孱渖眇歆ㄣ犰物鲠序屐蹁濮骇箦黹珧秕鹆痧孱渖眇歆ㄣ犰物鲠序屐蹁濮骇箦黹珧秕鹆痧孱渖眇歆ǎ＜窗鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺，狃痨箬秣砒痱予矧臾报农┈｛＜巢鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺）橡┈｛＜幢鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺）见砒痱渝泗轱钜殓梏К橡琵麒孱趄蹂汜祆物鲠序屐蹁濮骇箦黹珧秕鹆痧孱渖眇歆ㄣ犰物鲠序屐蹁濮骇箦黹珧秕鹆痧孱渖眇歆ㄣ犰物鲠序屐蹁濮骇箦黹珧秕鹆痧孱渖眇歆ㄣ犰物鲠序屐蹁濮骇箦黹珧秕鹆痧孱渖眇歆ǎ＜窗鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺，橡┈｛＜巢鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺）狃痨箬秣砒痱予矧臾报农┈｛＜幢鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺）孱躅殒蓬雩骢ㄅ铞汜祆物鲠蔑眇殪弪疹殒Ш躅殒组翳领獒箦螫ㄣ犰ы狃螫骇珏臾ě豉疱领獒箦螫蓬雯п滗膨蝻蛎镱翦臾骢ㄟ邪咝暴汜箦咝艾咝饼镦见敏д铋纟膨颛琵麒孱趄蹂狃痨д铋纟膨蜃轸杳镱翦臾波努敏见敏д铋纟膨蜃轸杳镱翦臾努响涿豇麒孱趄蹂狃痨д铋纟膨蜃轸杳镱翦臾波努汜祆物鲠序屐蹁濮骇箦黹珧秕鹆痧孱渖眇歆ㄣ犰物鲠序屐蹁濮骇箦黹珧秕鹆痧孱渖眇歆ㄏ熹敏｛＜巢鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜吹鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜恫鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜巢鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺）敏┅见咦艾膨螨麒孱趄蹂膨孱п滗契钽糸镱徐徙彖镬溴蝮Н骢ㄅ铞腻沆螬狃痨п滗契钽糸镱徐徙彖镬溴蝮组翳领獒箦螫敞汜祆尼翎歪皈骇屙痿Ж┈蓬霈腻沆螬р蹰熹嗅趑弪钋踽蜾冕箦螫骢ㄟ邪咝暴汜箦咝艾咝饼镦见圯嘛澌麒孱趄蹂嘛澌见埯酋狎湫狒К嗅衄鱼蝓糸铄妪义篝莠嘛澌麒孱趄蹂砒痱冕箦К鱼蝓糸铄瀣埝ю狒翦蝾Ы拘狒р镤Ы踞痧禊р蹰熹嗅趑弪钋踽蜾冕箦螫波义篝嘛澌┈х踽蜾Ы晶物翳轭绉圯蔟见圻装义篝莠嘛澌麒孱趄蹂狃痨р蹰熹嗅趑弪钋踽蜾冕箦螫波义篝嘛澌孱с桢汶尼翎赠疱Н骢ㄅ铞聂狃痨с桢汶尼翎赠疱组翳领炝扉狍弩Н川汜祆尼翎歪皈骇屙痿Ж┈汜祆尼翎歪皈骇屙痿Ж┈蓬霈聂с桢汶腻沆Н骢ㄟ邪咝暴汜箦咝艾咝饼镦见蓬霈腻沆契钽糸镱К契钽麒孱趄蹂汜箦狃痨с桢汶契钽糸镱Н波蓬霈契钽镦见体骠К琵麒孱趄蹂体骠К琵见б殓梏К引麒孱趄蹂б殓梏К汜祆ы狃螫骇珏臾ě孱雩药孱见蓬霈腻沆赠疱娱绉咦褒麒孱趄蹂б殓梏К蓬鳊见蓬霈腻沆尼翎赠疱К聂麒孱趄蹂б殓梏К狃痨с桢汶尼翎赠疱Н波蓬霈聂见蓬霈腻沆赠疱领獒螫葬麒孱趄蹂б殓梏К狃痨с桢汶赠疱领獒螫波蓬霈葬见蓬霈腻沆赠疱渺狍螫糟麒孱趄蹂б殓梏К狃痨с桢汶赠疱渺狍螫波蓬霈糟见蓬霈腻沆深骈К深纨麒孱趄蹂汜箦戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇祜镫躔蓬雩ㄅ铞轭狃痨呦岚ㄣ犰ы狃螫骇珏臾ě骢钽糸镱吾礤К深姗镦见术篝К鱼桢礤麒孱趄蹂б殓梏К戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇屮翦钿蓬雩ㄅ铞轭狃痨狃痨呦岚ㄣ犰ы狃螫骇珏臾ě镳弪狒矧К深姗┄鱼桢礤姬物翳轭绉麒孱趄蹂б殓梏К蓬鳊孱见蓬霈咦褒麒孱趄蹂б殓梏К蓬鳊孱с桢汶契钽糸镱Н骢ㄅ铞契钽戾趄邈ч笮灬沐栾熹弪Н骢ㄟ贪汜箦咛褒镦见г轴颛增麒孱趄蹂汜箦汜祆у蜢犷绉骇窘Ж汜祆ы狃螫骇珏臾ě殇К增┈癌镦姬趄蹂Ь麒孱趄蹂汜祆у蜢犷绉骇胶涧ㄣ犰尼翎郁蜷铉Ш翎脲Ж超汜祆ы狃螫骇珏臾ě钺礤К增┅｛＜卑簿ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北熬ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜沟鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺）歼麒孱趄蹂ф犰箦孱见咦褒麒孱趄蹂ф犰箦孱轭戾歼体舭戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇骝弩柚狎Ж蓬雯轭狃痨呦岚ㄣ犰物鲠序屐蹁濮骇箦黹珧秕鹆痧孱渖眇歆ǎ＜卑簿ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北熬ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜沟鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺，汜祆ы狃螫骇珏臾ě钺礤К契钽┅轭汜箦咛弭镦见г躔戾К契钽增蓬霰麒孱趄蹂戾计躅阍г轴颛契钽增轭戾悸镤汜箦汜祆ы狃螫骇珏臾ě珲狎潴К契钽镦价菥麒孱趄蹂汜祆ы狃螫骇珏臾ě怙澌К契钽歼装麒孱趄蹂狃痨х踽蜾邃砒痱笤锷妲报汜祆ы狃螫骇珏臾ě珲狎潴К契钽┅孱轭戾荚屙鹩汨屙寰戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇黼鱼桢礤Ж圯轭狃痨呦岚ㄆ躅阍轭戾寂痱汜箦汜祆ы狃螫骇珏臾ě疳蜥礤翦蝮К契钽镦价菥麒孱趄蹂嘛澌歼装麒孱趄蹂砒痱提礅溽К汜祆ы狃螫骇珏臾ě疳蜥礤翦蝮К契钽┈嘛澌孱轭戾寂铞组翳契钽戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇屮翦钿蓬雩ㄅ铞暴轭狃痨狃痨呦岚ㄣ犰ы狃螫骇珏臾ě钺礤К契钽┅ㄔ屙鹩汨屙濠轭汜箦狃痨ч铈弪Н波蓬鲎轸杵躅悻砒痱镦见体骠К琵麒孱趄蹂体骠К琵见б殓梏К义簖麒孱趄蹂汜箦戾歼厢熬狃痨躅殒蓬雩报汜祆ы狃螫骇珏臾ě孱雩义螬轭狃痨狃痨呦岚戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇狃痨吁怏臾ㄣ犰ы狃螫骇珏臾ě篚猝义螬轭狃痨呦岚ㄆ躅阍┅ㄣ犰ы狃螫骇珏臾ě豉К义螬镦见体骠К斟麒孱趄蹂体骠К狃痨д铋纟膨颛报斟见б殓梏К育麒孱趄蹂戾计轭犰吁饩戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇泔眇矬逵踱篝Ж萤轭狃痨呦岚ㄣ犰ы狃螫骇珏臾ě篚猝义螬轭戾加殓鱼桢礤戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇祜镫躔蓬雩ㄅ铞轭狃痨呦岚ㄣ犰ы狃螫骇珏臾ě钺礤К契钽┅轭戾计轭犰赠戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇狃痨吁怏臾ㄆ轭犰吁猢轭狃痨呦岚ㄣ犰ы狃螫骇珏臾ě豉К义螬轭戾加汨屙寰汜箦娱缬汨屙镦见术篝К娱琮麒孱趄蹂汜箦汜祆у蜢犷绉骇铒臾ㄡ痧禊ч笮灬沐栾熹弪Н报汜祆ы狃螫骇珏臾ě豉К娱绌┅镦姬趄蹂Ь麒孱趄蹂娱歼麒孱趄蹂狃痨х孱弪犰辁濮波汜祆ы狃螫骇珏臾ě孱雩义螬崎钺煸孱歼装麒孱趄蹂狃痨х孱弪犰辁濮波汜祆ы狃螫骇珏臾ě孱雩义螬崎钺煸孱轭б殓梏К筱桢礤Ы居汨屙瀣у铞Ы眷弭歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇屮翦钿蓬雩ㄣ犰ы狃螫骇珏臾ě孱雩义螬轭狃痨狃痨呦岚ㄣ犰ы狃螫骇珏臾ě钺礤К契钽┅ㄓ汨屙濠
    end
    end
      end

'checkFunctionBodies'/2 =
  fun (Env, Decls) ->
    let <MergedDecls> = apply 'mergeMultiClauseFunctions'/1(Decls)
      in apply 'checkFunctionBodiesGo'/2(Env, MergedDecls)

'checkFunctionBodiesGo'/2 =
  fun (E, Ds) ->
    case call 'Data.Array':'uncons'(Ds) of
      <'Nothing'> when 'true' ->
        {'Right', E}
      <{'Just', ц遽洄航腻沆契钽糸镱К契钽翎殪Ш揭弩酏> when 'true' ->
        case apply 'checkFunction'/2(E, Func) of
      <{'Left', Err}> when 'true' ->
        {'Left', apply 'addErrorContext'/2(call 'Nova.Prelude':'semigroupAppendImpl'(call 'Nova.Prelude':'semigroupAppendImpl'(#{#<102>(8,1,'integer',['unsigned'|['big']]),#<117>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<99>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<39>(8,1,'integer',['unsigned'|['big']])}#, call 'maps':'get'('name', Func)), #{#<39>(8,1,'integer',['unsigned'|['big']])}#), Err)}
      <{'Right', R}> when 'true' ->
        apply 'checkFunctionBodiesGo'/2(call 'maps':'get'('env', R), Rest)
    end
      <{'Just', ц遽洄航咦艾翎殪Ш揭弩酏> when 'true' ->
        apply 'checkFunctionBodiesGo'/2(E, Rest)
    end

'checkModuleSimple'/2 =
  fun (Env, Decls) ->
    apply 'checkModule'/3(call 'Nova.Compiler.Types':'defaultRegistry'(), Env, Decls)

'checkTypeAlias'/2 =
  fun (Env, Ta) ->
    let <Ty> = apply 'typeExprToTypeWithEnv'/5(Env, call 'Data.Map':'empty'(), call 'Data.Map':'empty'(), call 'Data.Map':'empty'(), call 'maps':'get'('ty', Ta))
      in let <Scheme> = let <_Oa0> = call 'Nova.Compiler.Types':'mkScheme'([])
      in apply _Oa0(Ty)
      in let <Env_> = let <_Oa0> = call 'Nova.Compiler.Types':'extendEnv'(Env)
      in apply apply _Oa0(call 'maps':'get'('name', Ta))(Scheme)
      in call 'Nova.Compiler.Types':'extendTypeAlias'(Env_, call 'maps':'get'('name', Ta), Ty)

'checkTypeClass'/2 =
  fun (Env, Tc) ->
    letrec 'addMethod'/2 = fun (E, Sig) ->
      let <VarPairs> = call 'Data.Array':'mapWithIndex'(fun (I, V) ->
      call 'Data.Tuple':'Tuple'(V, let <_Oa0> = call 'Nova.Compiler.Types':'mkTVar'(call 'erlang':'+'(call 'maps':'get'('counter', E), I))
      in apply _Oa0(V)), call 'Data.Array':'fromFoldable'(call 'maps':'get'('typeVars', Tc)))
      in let <VarMap> = call 'Data.Map':'fromFoldable'(VarPairs)
      in let <MethodType> = apply 'typeExprToType'/2(VarMap, call 'maps':'get'('ty', Sig))
      in let <Scheme> = let <_Oa0> = call 'Nova.Compiler.Types':'mkScheme'(call 'lists':'map'(call 'Data.Tuple':'snd'(), VarPairs))
      in apply _Oa0(MethodType)
      in let <_Oa0> = call 'Nova.Compiler.Types':'extendEnv'(E)
      in apply apply _Oa0(call 'maps':'get'('name', Sig))(Scheme)
      in call 'Data.Array':'foldl'(fun (_Mf0, _Mf1) -> apply 'addMethod'/2(_Mf0, _Mf1), Env, call 'Data.Array':'fromFoldable'(call 'maps':'get'('methods', Tc)))

'collectImportedAliases'/2 =
  fun (Registry, Decls) ->
    letrec 'collectFromImport'/2 = fun (_L0, _L1) ->
      case {_L0, _L1} of
        <{Acc, {'DeclImport', Imp}}> when 'true' -> case let <_Oa0> = call 'Nova.Compiler.Types':'lookupModule'(Registry)
      in apply _Oa0(call 'maps':'get'('moduleName', Imp)) of
      <'Nothing'> when 'true' ->
        Acc
      <{'Just', Exports}> when 'true' ->
        let <Aliases> = call 'maps':'get'('typeAliases', Exports)
      in let <Prefix> = case call 'maps':'get'('alias', Imp) of
      <{'Just', Alias}> when 'true' ->
        Alias
      <'Nothing'> when 'true' ->
        case call 'Data.String':'lastIndexOf'(call 'Data.String':'Pattern'(#{#<46>(8,1,'integer',['unsigned'|['big']])}#), call 'maps':'get'('moduleName', Imp)) of
      <'Nothing'> when 'true' ->
        call 'maps':'get'('moduleName', Imp)
      <{'Just', Idx}> when 'true' ->
        call 'Data.String':'drop'(call 'erlang':'+'(Idx, 1), call 'maps':'get'('moduleName', Imp))
    end
    end
      in let <Acc1> = call 'Data.Map':'union'(Acc, Aliases)
      in letrec 'addWithPrefix'/2 = fun (_L0, _L1) ->
      case {_L0, _L1} of
        <{M, {'Tuple', Name, Info}}> when 'true' -> call 'Data.Map':'insert'(call 'Nova.Prelude':'semigroupAppendImpl'(call 'Nova.Prelude':'semigroupAppendImpl'(Prefix, #{#<46>(8,1,'integer',['unsigned'|['big']])}#), Name), Info, M)
      end
      in let <Acc2> = call 'Data.Array':'foldl'(fun (_Mf0, _Mf1) -> apply 'addWithPrefix'/2(_Mf0, _Mf1), Acc1, call 'Data.Map':'toUnfoldable'(Aliases))
      in Acc2
    end
        <{Acc, _W0}> when 'true' -> Acc
      end
      in call 'Data.Array':'foldl'(fun (_Mf0, _Mf1) -> apply 'collectFromImport'/2(_Mf0, _Mf1), call 'Data.Map':'empty'(), Decls)

'collectResolvedImports'/2 =
  fun (Registry, Decls) ->
    letrec 'collectFromDecl'/2 = fun (_L0, _L1) ->
      case {_L0, _L1} of
        <{Acc, {'DeclImport', Imp}}> when 'true' -> apply 'collectFromImportDecl'/3(Registry, Acc, Imp)
        <{Acc, _W0}> when 'true' -> Acc
      end
      in call 'Data.Array':'foldl'(fun (_Mf0, _Mf1) -> apply 'collectFromDecl'/2(_Mf0, _Mf1), call 'Data.Map':'empty'(), Decls)

'extractExportsWithRegistry'/2 =
  fun (Registry, Decls) ->
    let <LocalAliasMap> = apply 'collectTypeAliases'/1(Decls)
      in let <LocalParamAliasMap> = apply 'collectParamTypeAliases'/1(Decls)
      in let <ImportedAliases> = apply 'collectImportedAliases'/2(Registry, Decls)
      in let <AliasMap> = LocalAliasMap
      in let <ParamAliasMap> = call 'Data.Map':'union'(LocalParamAliasMap, ImportedAliases)
      in letrec 'addConstructorPlaceholder'/3 = fun (Dt, Exp, Ctor) ->
      let <TypeVarPairs> = call 'Data.Array':'mapWithIndex'(fun (I, V) ->
      call 'Data.Tuple':'Tuple'(V, let <_Oa0> = call 'Nova.Compiler.Types':'mkTVar'(call 'erlang':'-'(call 'erlang':'+'(I, 1)))
      in apply _Oa0(V)), call 'Data.Array':'fromFoldable'(call 'maps':'get'('typeVars', Dt)))
      in let <TypeVarMap> = call 'Data.Map':'fromFoldable'(TypeVarPairs)
      in let <ResultType> = case call 'Data.List':'null'(call 'maps':'get'('typeVars', Dt)) of
      <'true'> when 'true' -> {'TyCon', let <_Oa0> = call 'Nova.Compiler.Types':'mkTCon'(call 'maps':'get'('name', Dt))
      in apply _Oa0([])}
      <'false'> when 'true' -> {'TyCon', let <_Oa0> = call 'Nova.Compiler.Types':'mkTCon'(call 'maps':'get'('name', Dt))
      in apply _Oa0(call 'lists':'map'(fun (_L0) ->
      case {_L0} of
        <{{'Tuple', _W0, Tv}}> when 'true' -> {'TyVar', Tv}
      end, TypeVarPairs))}
    end
      in let <CtorType> = apply 'buildConstructorTypeWithAllAliases'/5(AliasMap, ParamAliasMap, TypeVarMap, call 'maps':'get'('fields', Ctor), ResultType)
      in let <Scheme> = let <_Oa0> = call 'Nova.Compiler.Types':'mkScheme'(call 'lists':'map'(call 'Data.Tuple':'snd'(), TypeVarPairs))
      in apply _Oa0(CtorType)
      in call 'maps':'merge'(Exp, с镱篝蝓泗矧螫骄汜祆尼翎歪皈骇轭箦螋Ж汜祆ы狃螫骇珏臾ě钺礤К敏矧┈鱼桢礤汜祆ы狃螫骇珏臾ě泔铙趄蹉麸蝮К砒皓с镬戾泗砒痫螋Н骢ㄟ贪咛暴汜箦咛艾咛饼镦见砒瓞腻沆尼翎赠疱К聂麒孱趄蹂戾荚疱深骘п蜷豉Ы俱犰尼翎涕篝Шъ孱玺瑙ㄣ犰ы狃螫骇珏臾ě豉疱轴蝮К聂┅с镱篝蝓泗矧螫骄汜祆尼翎硫蜥Шф蝻砥镬溽忪濮ㄣ犰ъ轶趔Шы狃Ж骢ㄟ裔汜祆ы狃螫骇珏臾ě钺礤К咭岍汜祆ы狃螫骇珏臾ě泔铙趄蹉麸蝮К聂┅轭戾寂鸨汜祆ы狃螫骇礤蜱濮ㄅ瓞豉疱螫骄汜祆尼翎歪皈骇轭箦螋Ж汜祆ы狃螫骇珏臾ě钺礤К聂┈赠疱深骘汜祆ы狃螫骇珏臾ě豉疱螫砒皓轭汜祆尼翎硫蜥Шф镬潇Ж骢ㄟ秀艾咝惚狃痨п滗蔑铙趄蹉麸蛐灬沐栾熹弪Н敞聂咝惆咝惚┈砒鸨汜祆尼翎硫蜥Шф蝻砥镬溽忪濮ㄣ犰ы狃螫骇珏臾ě泔铙趄蹉麸蝮К聂┅见砒瓞腻沆赠疱领獒螫葬麒孱趄蹂汜祆ы狃螫骇礤蜱濮ㄅ瓞豉疱领獒箦螫骄汜祆尼翎歪皈骇轭箦螋Ж汜祆ы狃螫骇珏臾ě钺礤К葬┈ю狎犴螫骄汜祆尼翎硫蜥Шф蝻砥镬溽忪濮ㄣ犰ы狃螫骇珏臾ě豉疱轴蝮К葬┅р镤Ы俱犰ы狃螫骇珏臾ě豉К葬汜祆ы狃螫骇珏臾ě豉疱领獒箦螫砒皓见砒瓞腻沆五黥疱К昔麒孱趄蹂戾荚疱深骘п蜷豉Ы俱犰尼翎涕篝Шъ孱玺瑙ㄣ犰ы狃螫骇珏臾ě豉疱轴蝮К昔┅с镱篝蝓泗矧螫骄坫犰ы狃螫骇珏臾ě泔铙趄蹉麸颛昔┹轭戾荚疱轴蛐衢蝮汜祆尼翎硫蜥Шы狃组翳深溴Ж骢ㄉ蜘汜祆尼翎怎痨濮骇怎痨濮ㄖ戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇黼灾狎Ж汜祆у蜢犷绉骇Ж汜祆у蜢犷绉骇Ж涩暴┅轭狃痨呦岚ㄖ┅汜祆尼翎硫蜥Шф蝻砥镬溽忪濮ㄣ犰ы狃螫骇珏臾ě豉疱轴蝮К昔┅轭戾寂鸨汜祆ы狃螫骇礤蜱濮ㄅ瓞豉疱螫骄汜祆尼翎歪皈骇轭箦螋Ж汜祆ы狃螫骇珏臾ě钺礤К昔┈赠疱深骘汜祆ы狃螫骇珏臾ě豉疱螫砒皓轭戾荚疱轴蛲狃汜祆尼翎歪皈骇骝镯骑熹徕戾Ж赠疱轴蛐衢蝮轭戾家弩蹯粼疱汜箦汜祆尼翎涕篝Шь蹯歆ㄣ犰ы狃螫骇珏臾ě豉疱轴蝮К昔┅镦姬趄蹂Ь麒孱趄蹂г蔑瞌戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇黼悦镱Ж汜祆ы狃螫骇珏臾ě钺礤К昔┅轭狃痨呦岚ㄛ荸姬驷祗濮麒孱趄蹂г蔑瞌戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇黼悦镱Ж汜祆ы狃螫骇珏臾ě钺礤К昔┅轭狃痨呦岚ㄣ犰ъ轶趔Шы狃Ж骢ㄟ贪汜箦咛褒镦见г躔戾К咦艾增麒孱趄蹂г轴颛增孱洮赠疱轴蛐衢蝮┅孱轭戾甲蜥痧邃赠狃痨豉疱砒痱燥赠疱组翳领炝扉狍弩Н川领獒笸狃嗅蜥砹扉狍歪瓞赠疱轴蛲狃汜祆ы狃螫骇珏臾ě黩狃疱湓疱К昔┅轭戾济麸蛟疱戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇袅蝌秣Ж昨狃疱湓轭狃痨呦岚ㄒ弩蹯粼疱轭戾加汨屙寰戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇黼鱼桢礤Ж汜祆ъ轶趔Шы狃Ж汜祆尼翎怎痨濮骇箢洄ī赠疱轴蛐衢蝮┅轭狃痨呦岚敏矧赠疱轭汜祆ы狃螫骇礤蜱濮ㄅ鸨с镱篝蝓泗矧螫骄汜祆尼翎歪皈骇轭箦螋Ж汜祆ы狃螫骇珏臾ě泔铙趄蹉麸颛昔┈鱼桢礤汜祆ы狃螫骇珏臾ě泔铙趄蹉麸蝮К砒鸨┅见砒瓞腻沆契钽糸镱К契钽麒孱趄蹂砒见砒瓞腻沆骑蝈殓钌眇矧臾崎麒孱趄蹂戾荚狃痨豉疱砒痱燥赠疱Н波汜祆尼翎歪皈骇屙痿Ж┈汜祆ы狃螫骇珏臾ě豉疱娱珙狒躜濮崎┅轭戾计蝈逯狎缶汜祆尼翎硫蜥Шф蝻砥镬溽忪濮ㄣ犰尼翎渝臾骇麸疹骘熹徕戾Ж汜祆物鲠蔑眇殪弪赠疱螫骇骝邋赠疱轴蝮Ж赠┅轭戾忌湫衢蝮汜祆尼翎硫蜥Шы狃组翳深溴Ж骢ㄉ澍响渖洎汜祆尼翎怎痨濮骇怎痨濮ㄏ熹射汜祆у蜢犷绉骇Ж汜祆у蜢犷绉骇Ж射暴┅乞邋轴蝮轭戾家屙狃吁饩汜祆尼翎歪皈骇骝镯骑熹徕戾Ж汜祆ъ轶趔Шы狃Ж骢ㄟ贪汜箦咛褒镦见г躔戾К响渖洮五魃潺麒孱趄蹂汜祆尼翎怎痨濮骇怎痨濮ㄏ熹射г轴颛ч洄骄五魃洮ь犴濮骄汜祆物鲠序屐蹁濮骇箦黹珧秕鹆痧孱渖眇歆ǎ＜狗鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺，戾歼祁熬狃痨ч铘燥郁蜷铉Н皑轭狃痨咂畎ㄣ犰у蜢犷绉骇Ж五魃洎┅)
      end, IdPairs))
      in let <Tvars> = call 'lists':'map'(fun (_L0) ->
      case {_L0} of
        <{{'Tuple', _W0, NewId}}> when 'true' -> ч洄骄五魃洮ь犴濮骄汜祆物鲠序屐蹁濮骇箦黹珧秕鹆痧孱渖眇歆ǎ＜狗鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺，戾歼祁熬狃痨ч铘燥郁蜷铉Н皑轭狃痨咂畎ㄣ犰у蜢犷绉骇Ж五魃洎┅孱洮射嗅轵螬轭戾家屙狃疱湓戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇狃痨吁怏臾ㄒ屙狃吁猢轭狃痨呦岚ㄔ轭戾加汨屙寰戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇黼鱼桢礤Ж增狎螬轭狃痨呦岚ㄒ屙狃疱湓轭汜祆ы狃螫骇礤蜱濮ㄅ瓞鲠祯弩Ы俱犰尼翎歪皈骇轭箦螋Ж汜祆ы狃螫骇珏臾ě骢钽糸镱吾礤К崎┈鱼桢礤汜祆ы狃螫骇珏臾ě鲠祯弩К砒皓见砒瓞腻沆赠疱渺狍螫糟麒孱趄蹂戾趄邈п滗湾翳镤Н骢ㄅ娱绌戾贾狎嗅轵缶汜祆尼翎硫蜥Шы狃组翳深溴Ж骢ㄉ蜘汜祆尼翎怎痨濮骇怎痨濮ㄖ戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇黼灾狎Ж汜祆у蜢犷绉骇Ж汜祆у蜢犷绉骇Ж涩暴┅轭狃痨呦岚ㄖ┅汜祆尼翎硫蜥Шф蝻砥镬溽忪濮ㄣ犰ы狃螫骇珏臾ě豉疱轴蝮К糟┅轭戾贾狎歪鹁汜祆尼翎歪皈骇骝镯骑熹徕戾Ж轴蛐衢蝮轭戾纪弭栾湓疱狃痨豉疱砒痱燥赠疱Н波轴蛲狃汜祆ы狃螫骇珏臾ě豉К娱绌轭戾加汨屙寰戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇黼鱼桢礤Ж汜祆ъ轶趔Шы狃Ж汜祆尼翎怎痨濮骇箢洄ī轴蛐衢蝮┅轭狃痨呦岚ㄍ弭栾湓疱轭汜祆ы狃螫骇礤蜱濮ㄅ鲠祯弩Ы俱犰尼翎歪皈骇轭箦螋Ж汜祆ы狃螫骇珏臾ě钺礤К娱绌鱼桢礤汜祆ы狃螫骇珏臾ě鲠祯弩К农轭汜祆尼翎硫蜥Шф镬潇Ж骢ㄟ玩艾咄姹狃痨п滗湾翳镤Н波咄姘咄姹┈砒瓞汜祆尼翎硫蜥Шф蝻砥镬溽忪濮ㄣ犰ы狃螫骇珏臾ě礤翳镤螫糟┅见砒瓞咦褒麒孱趄蹂砒孱轭汜祆尼翎硫蜥Шф镬潇Ж骢ㄟ玩艾咄姹狃痨с镬戾泗砒痫螋Н波咄姘咄姹┈汜祆物鲠蔑眇殪弪赠疱螫骇屙痿砒痫螋螫ī腻沆螬х孱弪犰辁濮骢ㄅ铞赠戾寂铞乞邋汜祆物鲠蔑眇殪弪赠疱螫骇骝邋赠疱轴蝮蓬雩ㄅ铞轭戾荚乞邋汜祆物鲠蔑眇殪弪赠疱螫骇骝邋赠疱轴蝮Ж赠轭戾计蝈迳潴汜祆尼翎渝臾骇麸疹骘熹徕戾Ж汜祆尼翎渝臾骇溟骀弪孱沐Ж赠乞邋蓬銎蝈濠轭戾忌湫衢蝮汜祆尼翎硫蜥Шы狃组翳深溴Ж骢ㄉ澍响渖洎汜祆尼翎怎痨濮骇怎痨濮ㄏ熹射汜祆у蜢犷绉骇Ж汜祆у蜢犷绉骇Ж射暴┅乞邋射螬轭戾家屙狃吁饩汜祆尼翎歪皈骇骝镯骑熹徕戾Ж汜祆ъ轶趔Шы狃Ж骢ㄟ贪汜箦咛褒镦见г躔戾К响渖洮五魃潺麒孱趄蹂汜祆尼翎怎痨濮骇怎痨濮ㄏ熹射г轴颛戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇黼灾狎Ж五魃洎轭狃痨呦岚ㄣ犰物鲠序屐蹁濮骇箦黹珧秕鹆痧孱渖眇歆ǎ＜北毒ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺，戾歼祁熬狃痨ч铘燥郁蜷铉Н皑轭狃痨咂畎ㄣ犰у蜢犷绉骇Ж五魃洎┅孱洮射嗅轵螬轭戾贾狎缶汜祆ъ轶趔Шы狃Ж骢ㄟ贪汜箦咛褒镦见г躔戾К咦艾五魃潺麒孱趄蹂戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇黼灾狎Ж五魃洎轭狃痨呦岚ㄣ犰物鲠序屐蹁濮骇箦黹珧秕鹆痧孱渖眇歆ǎ＜北毒ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺，戾歼祁熬狃痨ч铘燥郁蜷铉Н皑轭狃痨咂畎ㄣ犰у蜢犷绉骇Ж五魃洎┅孱洮射嗅轵螬轭戾家屙狃疱湓戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇狃痨吁怏臾ㄒ屙狃吁猢轭狃痨呦岚ㄔ轭戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇黼鱼桢礤Ж轴蝮轭狃痨呦岚ㄒ屙狃疱湓ч铈弪Н骢ㄟ邪咝暴汜箦咝艾咝饼镦见蓬霈砒痱涕臾涕酏麒孱趄蹂б殓梏К豉Ы踞痧禊ч铈弪涕臾报涕舂篚猝骄汜祆物鲠蔑眇殪弪赠疱螫骇屙痿吁怏臾īу铞Ы九铞
      <{Env, {'ExprVar', Name}}> when 'true' ->
        case let <_Oa0> = call 'Nova.Compiler.Types':'lookupEnv'(Env)
      in apply _Oa0(Name) of
      <'Nothing'> when 'true' ->
        {'Left', apply 'UnboundVariable'/1(Name)}
      <{'Just', Scheme}> when 'true' ->
        let <R> = apply 'instantiate'/2(Env, Scheme)
      in {'Right', 豉Ы俱犰ы狃螫骇珏臾ě豉К药篚猝骄汜祆物鲠蔑眇殪弪赠疱螫骇屙痿吁怏臾īу铞Ы俱犰ы狃螫骇珏臾ě孱雩药
    end
      <{Env, {'ExprQualified', M, Name}}> when 'true' ->
        let <FullName> = call 'Nova.Prelude':'semigroupAppendImpl'(call 'Nova.Prelude':'semigroupAppendImpl'(M, #{#<46>(8,1,'integer',['unsigned'|['big']])}#), Name)
      in case let <_Oa0> = call 'Nova.Compiler.Types':'lookupEnv'(Env)
      in apply _Oa0(FullName) of
      <{'Just', Scheme}> when 'true' ->
        let <R> = apply 'instantiate'/2(Env, Scheme)
      in {'Right', 豉Ы俱犰ы狃螫骇珏臾ě豉К药篚猝骄汜祆物鲠蔑眇殪弪赠疱螫骇屙痿吁怏臾īу铞Ы俱犰ы狃螫骇珏臾ě孱雩药
      <'Nothing'> when 'true' ->
        case let <_Oa0> = call 'Nova.Compiler.Types':'lookupEnv'(Env)
      in apply _Oa0(Name) of
      <{'Just', Scheme}> when 'true' ->
        let <R> = apply 'instantiate'/2(Env, Scheme)
      in {'Right', 豉Ы俱犰ы狃螫骇珏臾ě豉К药篚猝骄汜祆物鲠蔑眇殪弪赠疱螫骇屙痿吁怏臾īу铞Ы俱犰ы狃螫骇珏臾ě孱雩药
      <'Nothing'> when 'true' ->
        {'Left', apply 'UndefinedQualifiedImport'/2(M, Name)}
    end
    end
      <{Env, {'ExprApp', F, Arg}}> when 'true' ->
        letrec 'inferApp'/3 = fun (E, Func, A) ->
      case apply 'infer'/2(E, Func) of
      <{'Left', Err}> when 'true' ->
        {'Left', Err}
      <{'Right', R1}> when 'true' ->
        case apply 'infer'/2(call 'maps':'get'('env', R1), A) of
      <{'Left', Err}> when 'true' ->
        {'Left', Err}
      <{'Right', R2}> when 'true' ->
        let <_Let0> = let <_Oa0> = call 'Nova.Compiler.Types':'freshVar'(call 'maps':'get'('env', R2))
      in apply _Oa0(#{#<114>(8,1,'integer',['unsigned'|['big']])}#)
      in case _Let0 of
        <{'Tuple', Tv, Env3}> when 'true' -> let <ResultTy> = {'TyVar', Tv}
      in let <FuncTy> = let <_Oa0> = call 'Nova.Compiler.Types':'applySubst'(call 'maps':'get'('sub', R2))
      in apply _Oa0(call 'maps':'get'('ty', R1))
      in let <ExpectedTy> = let <_Oa0> = call 'Nova.Compiler.Types':'tArrow'(call 'maps':'get'('ty', R2))
      in apply _Oa0(ResultTy)
      in case let <_Oa0> = apply 'unifyEnv'/1(Env3)
      in apply apply _Oa0(FuncTy)(ExpectedTy) of
      <{'Left', Ue}> when 'true' ->
        {'Left', apply 'UnifyErrWithContext'/2(Ue, call 'Nova.Prelude':'semigroupAppendImpl'(call 'Nova.Prelude':'semigroupAppendImpl'(call 'Nova.Prelude':'semigroupAppendImpl'(#{#<97>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']]),#<58>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']])}#, apply 'showExprShort'/1(Func)), #{#<32>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']]),#<108>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']])}#), apply 'showExprShort'/1(A)))}
      <{'Right', S3}> when 'true' ->
        let <Sub> = let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(S3)
      in apply _Oa0(let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(call 'maps':'get'('sub', R2))
      in apply _Oa0(call 'maps':'get'('sub', R1)))
      in {'Right', 豉Ы眷弭歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇狃痨吁怏臾ㄓ畅轭狃痨呦岚ㄒ弩蹯粼┈篚猝骄吁猬у铞Ы九铞除
    end
      end
    end
    end
      in case F of
      <{'ExprVar', #{#<45>(8,1,'integer',['unsigned'|['big']])}#}> when 'true' ->
        case Arg of
      <{'ExprLit', {'LitInt', _W0}}> when 'true' ->
        {'Right', 豉Ы俱犰物鲠蔑眇殪弪赠疱螫骇羯铘Ж┈篚猝骄汜祆物鲠蔑眇殪弪赠疱螫骇屙痿吁怏臾īу铞Ы九铞
      <{'ExprLit', {'LitNumber', _W0}}> when 'true' ->
        {'Right', 豉Ы钧г蔑瞌戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇黼悦镱Ж｛＜犯鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北肪ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑咕ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜垢鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北淳ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺）轭狃痨呦岚ㄛ荸篚猝骄汜祆物鲠蔑眇殪弪赠疱螫骇屙痿吁怏臾īу铞Ы九铞
      <{'ExprParens', {'ExprLit', {'LitInt', _W0}}}> when 'true' ->
        {'Right', 豉Ы俱犰物鲠蔑眇殪弪赠疱螫骇羯铘Ж┈篚猝骄汜祆物鲠蔑眇殪弪赠疱螫骇屙痿吁怏臾īу铞Ы九铞
      <_W0> when 'true' ->
        apply 'inferApp'/3(Env, F, Arg)
    end
      <_W0> when 'true' ->
        apply 'inferApp'/3(Env, F, Arg)
    end
      <{Env, {'ExprLambda', Pats, Body}}> when 'true' ->
        case call 'Data.List':'uncons'(Pats) of
      <'Nothing'> when 'true' ->
        apply 'infer'/2(Env, Body)
      <{'Just', ц遽洄航嗅衄翎殪Ш揭弩粜狒簖> when 'true' ->
        let <_Let0> = let <_Oa0> = call 'Nova.Compiler.Types':'freshVar'(Env)
      in apply _Oa0(#{#<97>(8,1,'integer',['unsigned'|['big']])}#)
      in case _Let0 of
        <{'Tuple', ArgTv, Env1}> when 'true' -> let <ArgTy> = {'TyVar', ArgTv}
      in case apply 'inferPat'/3(Env1, Pat, ArgTy) of
      <{'Left', E}> when 'true' ->
        {'Left', E}
      <{'Right', PatRes}> when 'true' ->
        let <InnerExpr> = case call 'Data.List':'null'(RestPats) of
      <'true'> when 'true' -> Body
      <'false'> when 'true' -> {'ExprLambda', RestPats, Body}
    end
      in case apply 'infer'/2(call 'maps':'get'('env', PatRes), InnerExpr) of
      <{'Left', E}> when 'true' ->
        {'Left', E}
      <{'Right', BodyRes}> when 'true' ->
        let <Sub> = let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(call 'maps':'get'('sub', BodyRes))
      in apply _Oa0(call 'maps':'get'('sub', PatRes))
      in let <ResultTy> = let <_Oa0> = call 'Nova.Compiler.Types':'tArrow'(let <_Oa0> = call 'Nova.Compiler.Types':'applySubst'(Sub)
      in apply _Oa0(ArgTy))
      in apply _Oa0(call 'maps':'get'('ty', BodyRes))
      in {'Right', 豉Ы疽弩蹯粼篚猝骄吁猬у铞Ы俱犰ы狃螫骇珏臾ě孱雩嘛澌义螬
    end
    end
      end
    end
      <{Env, {'ExprLet', Binds, Body}}> when 'true' ->
        case apply 'inferBinds'/2(Env, Binds) of
      <{'Left', E}> when 'true' ->
        {'Left', E}
      <{'Right', LetRes}> when 'true' ->
        case apply 'infer'/2(call 'maps':'get'('env', LetRes), Body) of
      <{'Left', E}> when 'true' ->
        {'Left', E}
      <{'Right', BodyRes}> when 'true' ->
        {'Right', 豉Ы俱犰ы狃螫骇珏臾ě豉К嘛澌义螬篚猝骄戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇泔眇矬逵踱篝Ж汜祆ы狃螫骇珏臾ě篚猝嘛澌义螬轭狃痨呦岚ㄣ犰ы狃螫骇珏臾ě篚猝体粢弩┅у铞Ы俱犰ы狃螫骇珏臾ě孱雩嘛澌义螬
    end
    end
      <{Env, {'ExprIf', Cond, Then_, Else_}}> when 'true' ->
        case apply 'infer'/2(Env, Cond) of
      <{'Left', E}> when 'true' ->
        {'Left', E}
      <{'Right', CondRes}> when 'true' ->
        case let <_Oa0> = apply 'unifyEnv'/1(call 'maps':'get'('env', CondRes))
      in apply apply _Oa0(call 'maps':'get'('ty', CondRes))(call 'Nova.Compiler.Types':'tBool'()) of
      <{'Left', Ue}> when 'true' ->
        {'Left', apply 'UnifyErr'/1(Ue)}
      <{'Right', _W0}> when 'true' ->
        case apply 'infer'/2(call 'maps':'get'('env', CondRes), Then_) of
      <{'Left', E}> when 'true' ->
        {'Left', E}
      <{'Right', ThenRes}> when 'true' ->
        case apply 'infer'/2(call 'maps':'get'('env', ThenRes), Else_) of
      <{'Left', E}> when 'true' ->
        {'Left', E}
      <{'Right', ElseRes}> when 'true' ->
        case let <_Oa0> = apply 'unifyEnv'/1(call 'maps':'get'('env', ElseRes))
      in apply apply _Oa0(let <_Oa0> = call 'Nova.Compiler.Types':'applySubst'(call 'maps':'get'('sub', ElseRes))
      in apply _Oa0(call 'maps':'get'('ty', ThenRes)))(call 'maps':'get'('ty', ElseRes)) of
      <{'Left', Ue}> when 'true' ->
        {'Left', apply 'UnifyErr'/1(Ue)}
      <{'Right', S}> when 'true' ->
        {'Right', 豉Ы眷弭歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇狃痨吁怏臾ㄓ轭狃痨呦岚ㄣ犰ы狃螫骇珏臾ě豉К澎箦义螬┈篚猝骄戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇泔眇矬逵踱篝Ж萤轭狃痨呦岚ㄣ犰ы狃螫骇珏臾ě篚猝澎箦义螬┈у铞Ы俱犰ы狃螫骇珏臾ě孱雩澎箦义螬
    end
    end
    end
    end
    end
      <{Env, {'ExprCase', Scrutinee, Clauses}}> when 'true' ->
        case apply 'infer'/2(Env, Scrutinee) of
      <{'Left', E}> when 'true' ->
        {'Left', E}
      <{'Right', ScrutRes}> when 'true' ->
        let <_Let0> = let <_Oa0> = call 'Nova.Compiler.Types':'freshVar'(call 'maps':'get'('env', ScrutRes))
      in apply _Oa0(#{#<99>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']])}#)
      in case _Let0 of
        <{'Tuple', ResultTv, Env2}> when 'true' -> let <ResultTy> = {'TyVar', ResultTv}
      in case apply 'inferClauses'/5(Env2, call 'maps':'get'('ty', ScrutRes), ResultTy, Clauses, call 'maps':'get'('sub', ScrutRes)) of
      <{'Left', E}> when 'true' ->
        {'Left', E}
      <{'Right', ClauseRes}> when 'true' ->
        {'Right', 豉Ы眷弭歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇狃痨吁怏臾ㄣ犰ы狃螫骇珏臾ě篚猝渺狨箦义螬轭狃痨呦岚ㄒ弩蹯粼┈篚猝骄汜祆ы狃螫骇珏臾ě篚猝渺狨箦义螬у铞Ы俱犰ы狃螫骇珏臾ě孱雩渺狨箦义螬
    end
      end
    end
      <{Env, {'ExprBinOp', Op, L, R}}> when 'true' ->
        case L of
      <{'ExprSection', #{#<95>(8,1,'integer',['unsigned'|['big']])}#}> when 'true' ->
        apply 'infer'/2(Env, {'ExprLambda', [{'PatVar', #{#<95>(8,1,'integer',['unsigned'|['big']]),#<120>(8,1,'integer',['unsigned'|['big']])}#}|[]], {'ExprBinOp', Op, {'ExprVar', #{#<95>(8,1,'integer',['unsigned'|['big']]),#<120>(8,1,'integer',['unsigned'|['big']])}#}, R}})
      <_W0> when 'true' ->
        case R of
      <{'ExprSection', #{#<95>(8,1,'integer',['unsigned'|['big']])}#}> when 'true' ->
        apply 'infer'/2(Env, {'ExprLambda', [{'PatVar', #{#<95>(8,1,'integer',['unsigned'|['big']]),#<120>(8,1,'integer',['unsigned'|['big']])}#}|[]], {'ExprBinOp', Op, L, {'ExprVar', #{#<95>(8,1,'integer',['unsigned'|['big']]),#<120>(8,1,'integer',['unsigned'|['big']])}#}}})
      <_W0> when 'true' ->
        let <MkError> = case call 'Data.String':'lastIndexOf'(call 'Data.String':'Pattern'(#{#<46>(8,1,'integer',['unsigned'|['big']])}#), Op) of
      <{'Just', Idx}> when 'true' ->
        apply 'UndefinedQualifiedImport'/2(call 'Data.String':'take'(Idx, Op), call 'Data.String':'drop'(call 'erlang':'+'(Idx, 1), Op))
      <'Nothing'> when 'true' ->
        apply 'UnboundVariable'/1(Op)
    end
      in case let <_Oa0> = call 'Nova.Compiler.Types':'lookupEnv'(Env)
      in apply _Oa0(Op) of
      <'Nothing'> when 'true' ->
        {'Left', MkError}
      <{'Just', Scheme}> when 'true' ->
        let <OpInst> = apply 'instantiate'/2(Env, Scheme)
      in case apply 'infer'/2(call 'maps':'get'('env', OpInst), L) of
      <{'Left', E}> when 'true' ->
        {'Left', E}
      <{'Right', LRes}> when 'true' ->
        case apply 'infer'/2(call 'maps':'get'('env', LRes), R) of
      <{'Left', E}> when 'true' ->
        {'Left', E}
      <{'Right', RRes}> when 'true' ->
        let <_Let0> = let <_Oa0> = call 'Nova.Compiler.Types':'freshVar'(call 'maps':'get'('env', RRes))
      in apply _Oa0(#{#<98>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']])}#)
      in case _Let0 of
        <{'Tuple', ResTv, Env4}> when 'true' -> case let <_Oa0> = apply 'unifyEnv'/1(Env4)
      in apply apply _Oa0(let <_Oa0> = call 'Nova.Compiler.Types':'applySubst'(let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(call 'maps':'get'('sub', RRes))
      in apply _Oa0(call 'maps':'get'('sub', LRes)))
      in apply _Oa0(call 'maps':'get'('ty', OpInst)))(let <_Oa0> = call 'Nova.Compiler.Types':'tArrow'(call 'maps':'get'('ty', LRes))
      in apply _Oa0(let <_Oa0> = call 'Nova.Compiler.Types':'tArrow'(call 'maps':'get'('ty', RRes))
      in apply _Oa0({'TyVar', ResTv}))) of
      <{'Left', Ue}> when 'true' ->
        {'Left', apply 'UnifyErr'/1(Ue)}
      <{'Right', S4}> when 'true' ->
        let <Sub> = let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(S4)
      in apply _Oa0(let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(call 'maps':'get'('sub', RRes))
      in apply _Oa0(call 'maps':'get'('sub', LRes)))
      in {'Right', 豉Ы眷弭歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇狃痨吁怏臾ㄓ穿轭狃痨呦岚г轴颛义笤鳊┈篚猝骄吁猬у铞Ы九铞待
    end
      end
    end
    end
    end
    end
    end
      <{Env, {'ExprList', Elems}}> when 'true' ->
        let <_Let0> = let <_Oa0> = call 'Nova.Compiler.Types':'freshVar'(Env)
      in apply _Oa0(#{#<101>(8,1,'integer',['unsigned'|['big']]),#<108>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<109>(8,1,'integer',['unsigned'|['big']])}#)
      in case _Let0 of
        <{'Tuple', ElemTv, Env1}> when 'true' -> let <ElemTy> = {'TyVar', ElemTv}
      in case apply 'inferElems'/3(Env1, ElemTy, Elems) of
      <{'Left', E}> when 'true' ->
        {'Left', E}
      <{'Right', Res}> when 'true' ->
        {'Right', 豉Ы钧г蔑瞌戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇黼悦镱Ж｛＜兜鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北淳ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北淳ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜狗鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜辈本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺）轭狃痨呦岚ㄛ戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇狃痨吁怏臾ㄣ犰ы狃螫骇珏臾ě篚猝义螬轭狃痨呦岚ㄅ戾碓┹篚猝骄汜祆ы狃螫骇珏臾ě篚猝义螬у铞Ы俱犰ы狃螫骇珏臾ě孱雩义螬
    end
      end
      <{Env, {'ExprTuple', Elems}}> when 'true' ->
        case apply 'inferMany'/2(Env, Elems) of
      <{'Left', E}> when 'true' ->
        {'Left', E}
      <{'Right', Res}> when 'true' ->
        {'Right', 豉Ы俱犰物鲠蔑眇殪弪赠疱螫骇粼躔戾Ж汜祆ы狃螫骇珏臾ě豉螫义螬┈篚猝骄汜祆ы狃螫骇珏臾ě篚猝义螬у铞Ы俱犰ы狃螫骇珏臾ě孱雩义螬
    end
      <{Env, {'ExprRecord', Fields}}> when 'true' ->
        case apply 'inferFields'/2(Env, Fields) of
      <{'Left', E}> when 'true' ->
        {'Left', E}
      <{'Right', Res}> when 'true' ->
        {'Right', 豉Ы钧г义泔蜾Кф殄熹螫骄汜祆尼翎歪皈骇骝镯骑熹徕戾Ж汜祆ы狃螫骇珏臾ě豉螫义螬┈蝻鳔骄物翳轭绉,'sub'=>call 'maps':'get'('sub', Res),'env'=>call 'maps':'get'('env', Res)}}
    end
      <{Env, {'ExprRecordAccess', Rec, Field}}> when 'true' ->
        case apply 'infer'/2(Env, Rec) of
      <{'Left', E}> when 'true' ->
        {'Left', E}
      <{'Right', RecRes}> when 'true' ->
        let <_Let0> = let <_Oa0> = call 'Nova.Compiler.Types':'freshVar'(call 'maps':'get'('env', RecRes))
      in apply _Oa0(#{#<102>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<108>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']])}#)
      in case _Let0 of
        <{'Tuple', ResultTv, Env2}> when 'true' -> let <_Let1> = let <_Oa0> = call 'Nova.Compiler.Types':'freshVar'(Env2)
      in apply _Oa0(#{#<114>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<119>(8,1,'integer',['unsigned'|['big']])}#)
      in case _Let1 of
        <{'Tuple', RowTv, Env3}> when 'true' -> let <ExpectedRec> = {'TyRecord', ф殄熹螫骄汜祆尼翎歪皈骇箝铉戾麸瞌ㄆ殄熹г轴颛义篚祠增┈蝻鳔骄术篝К绎髟鳊
      in case let <_Oa0> = apply 'unifyEnv'/1(Env3)
      in apply apply _Oa0(call 'maps':'get'('ty', RecRes))(ExpectedRec) of
      <{'Left', Ue}> when 'true' ->
        {'Left', apply 'UnifyErrWithContext'/2(Ue, call 'Nova.Prelude':'semigroupAppendImpl'(call 'Nova.Prelude':'semigroupAppendImpl'(call 'Nova.Prelude':'semigroupAppendImpl'(#{#<102>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<108>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<99>(8,1,'integer',['unsigned'|['big']]),#<99>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<58>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']])}#, apply 'showExprShort'/1(Rec)), #{#<46>(8,1,'integer',['unsigned'|['big']])}#), Field))}
      <{'Right', S2}> when 'true' ->
        let <Sub> = let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(S2)
      in apply _Oa0(call 'maps':'get'('sub', RecRes))
      in {'Right', 豉Ы眷弭歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇狃痨吁怏臾ㄓ踱轭狃痨呦岚г轴颛义篚祠增┈篚猝骄吁猬у铞Ы九铞除
    end
      end
      end
    end
      <{Env, {'ExprParens', E}}> when 'true' ->
        apply 'infer'/2(Env, E)
      <{Env, {'ExprTyped', E, _W0}}> when 'true' ->
        apply 'infer'/2(Env, E)
      <{Env, {'ExprRecordUpdate', Rec, Updates}}> when 'true' ->
        apply 'inferRecordUpdate'/3(Env, Rec, call 'Data.Array':'fromFoldable'(Updates))
      <{Env, {'ExprUnaryOp', Op, E}}> when 'true' ->
        apply 'inferUnaryOp'/3(Env, Op, E)
      <{Env, {'ExprDo', Stmts}}> when 'true' ->
        apply 'inferDo'/2(Env, call 'Data.Array':'fromFoldable'(Stmts))
      <{Env, {'ExprSection', Name}}> when 'true' ->
        case call 'erlang':'=:='(call 'Data.String':'take'(1, Name), #{#<46>(8,1,'integer',['unsigned'|['big']])}#) of
      <'true'> when 'true' -> let <Field> = call 'Data.String':'drop'(1, Name)
      in let <_Let0> = let <_Oa0> = call 'Nova.Compiler.Types':'freshVar'(Env)
      in apply _Oa0(#{#<102>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<108>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']])}#)
      in case _Let0 of
        <{'Tuple', ResultTv, Env1}> when 'true' -> let <_Let1> = let <_Oa0> = call 'Nova.Compiler.Types':'freshVar'(Env1)
      in apply _Oa0(#{#<114>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<119>(8,1,'integer',['unsigned'|['big']])}#)
      in case _Let1 of
        <{'Tuple', RowTv, Env2}> when 'true' -> let <ResultType> = {'TyVar', ResultTv}
      in let <InputType> = {'TyRecord', ф殄熹螫骄汜祆尼翎歪皈骇箝铉戾麸瞌ㄆ殄熹г轴颛义篚祠增┈蝻鳔骄术篝К绎髟鳊
      in let <SectionType> = let <_Oa0> = call 'Nova.Compiler.Types':'tArrow'(InputType)
      in apply _Oa0(ResultType)
      in {'Right', 豉Ы居邈糸镱赠疱篚猝骄汜祆尼翎歪皈骇屙痿Ж┈у铞Ы九铞昌
      end
      end
      <'false'> when 'true' -> case call 'Data.Map':'lookup'(Name, call 'maps':'get'('bindings', Env)) of
      <'Nothing'> when 'true' ->
        {'Left', apply 'UnboundVariable'/1(Name)}
      <{'Just', Scheme}> when 'true' ->
        let <_Let0> = apply 'instantiate'/2(Env, Scheme)
      in case _Let0 of
        <豉Ш皆у铞Ш脚铞昌麒孱趄蹂б殓梏К豉Ы驹篚猝骄汜祆尼翎歪皈骇屙痿Ж┈у铞Ы九铞昌
      end
    end
    end
      <{Env, {'ExprSectionLeft', Expr, Op}}> when 'true' ->
        case call 'Data.Map':'lookup'(Op, call 'maps':'get'('bindings', Env)) of
      <'Nothing'> when 'true' ->
        {'Left', apply 'UnboundVariable'/1(Op)}
      <{'Just', OpScheme}> when 'true' ->
        let <_Let0> = apply 'instantiate'/2(Env, OpScheme)
      in case _Let0 of
        <豉Ш较鹪у铞Ш脚铞饼麒孱趄蹂汜箦狃痨ч铈弪Н波蓬霰砒痱镦见体骠К琵麒孱趄蹂体骠К琵见б殓梏К砒痱义簖麒孱趄蹂戾歼体舭戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇骝弩柚狎Ж汜祆ы狃螫骇珏臾ě孱雩砒痱义螬轭狃痨呦岚ǎ＜北稻ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜构鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北淳ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北稻ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺）轭汜箦咛弭镦见г躔戾К义笤霈蓬霾麒孱趄蹂戾歼体舯戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇骝弩柚狎Ж蓬霾轭狃痨呦岚ǎ＜北稻ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜构鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北淳ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑稻ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑尘ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑淳ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北毒ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺）轭汜箦咛弭镦见г躔戾К议玷粼霈蓬龀麒孱趄蹂戾寂疱泗邃橡赠戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇袅蝌秣Ж汜祆ы狃螫骇珏臾ě豉К砒痱义螬轭狃痨呦岚戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇袅蝌秣Жг轴颛议玷粼鳊轭狃痨呦岚г轴颛义笤鳊┅轭汜箦戾歼厢熬狃痨躅殒蓬雩报蓬龀轭狃痨狃痨呦岚ㄏ鹪┄砒疱泗邃橡赠镦见体骠К斟麒孱趄蹂体骠К狃痨д铋纟膨颛报斟见б殓梏К育麒孱趄蹂戾加踱戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇泔眇矬逵踱篝Ж萤轭狃痨呦岚ㄣ犰ы狃螫骇珏臾ě篚猝砒痱义螬轭戾家弩蹯粼戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇袅蝌秣Ж戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇狃痨吁怏臾ㄓ踱轭狃痨呦岚г轴颛议玷粼鳊┅轭狃痨呦岚戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇狃痨吁怏臾ㄓ踱轭狃痨呦岚г轴颛义笤鳊┅轭б殓梏К豉Ы疽弩蹯粼篚猝骄吁猬у铞Ы九铞除
    end
      end
      end
    end
      end
    end
      <{Env, {'ExprSectionRight', Op, Expr}}> when 'true' ->
        case call 'Data.Map':'lookup'(Op, call 'maps':'get'('bindings', Env)) of
      <'Nothing'> when 'true' ->
        {'Left', apply 'UnboundVariable'/1(Op)}
      <{'Just', OpScheme}> when 'true' ->
        let <_Let0> = apply 'instantiate'/2(Env, OpScheme)
      in case _Let0 of
        <豉Ш较鹪у铞Ш脚铞饼麒孱趄蹂汜箦狃痨ч铈弪Н波蓬霰砒痱镦见体骠К琵麒孱趄蹂体骠К琵见б殓梏К砒痱义簖麒孱趄蹂戾歼体舭戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇骝弩柚狎Ж汜祆ы狃螫骇珏臾ě孱雩砒痱义螬轭狃痨呦岚ǎ＜北稻ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜构鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北淳ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北稻ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺）轭汜箦咛弭镦见г躔戾К义笤霈蓬霾麒孱趄蹂戾歼体舯戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇骝弩柚狎Ж蓬霾轭狃痨呦岚ǎ＜北稻ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜构鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑妇ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑簿ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北毒ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺）轭汜箦咛弭镦见г躔戾К体骠增蓬龀麒孱趄蹂戾寂疱泗邃橡赠戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇袅蝌秣Жг轴颛体骠增轭狃痨呦岚戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇袅蝌秣Ж汜祆ы狃螫骇珏臾ě豉К砒痱义螬轭狃痨呦岚г轴颛义笤鳊┅轭汜箦戾歼厢熬狃痨躅殒蓬雩报蓬龀轭狃痨狃痨呦岚ㄏ鹪┄砒疱泗邃橡赠镦见体骠К斟麒孱趄蹂体骠К狃痨д铋纟膨颛报斟见б殓梏К育麒孱趄蹂戾加踱戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇泔眇矬逵踱篝Ж萤轭狃痨呦岚ㄣ犰ы狃螫骇珏臾ě篚猝砒痱义螬轭戾家弩蹯粼戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇袅蝌秣Ж戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇狃痨吁怏臾ㄓ踱轭狃痨呦岚г轴颛体骠增┅轭狃痨呦岚戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇狃痨吁怏臾ㄓ踱轭狃痨呦岚г轴颛义笤鳊┅轭б殓梏К豉Ы疽弩蹯粼篚猝骄吁猬у铞Ы九铞除
    end
      end
      end
    end
      end
    end
      <{_W0, _W1}> when 'true' ->
        {'Left', apply 'NotImplemented'/1(#{#<101>(8,1,'integer',['unsigned'|['big']]),#<120>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<102>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<109>(8,1,'integer',['unsigned'|['big']])}#)}
    end

'inferBinds'/2 =
  fun (Env, Binds) ->
    letrec 'addBindPlaceholders'/2 = fun (E, Bs) ->
      call 'Data.Foldable':'foldl'(fun (_Mf0, _Mf1) -> apply 'addOne'/2(_Mf0, _Mf1), E, Bs)
       'addOne'/2 = fun (E, Bind) ->
      case call 'maps':'get'('pattern', Bind) of
      <{'PatVar', Name}> when 'true' ->
        case call 'maps':'get'('typeAnn', Bind) of
      <{'Just', TyExpr}> when 'true' ->
        let <AnnotatedTy> = apply 'typeExprToType'/2(call 'Data.Map':'empty'(), TyExpr)
      in let <Scheme> = let <_Oa0> = call 'Nova.Compiler.Types':'mkScheme'([])
      in apply _Oa0(AnnotatedTy)
      in let <_Oa0> = call 'Nova.Compiler.Types':'extendEnv'(E)
      in apply apply _Oa0(Name)(Scheme)
      <'Nothing'> when 'true' ->
        let <_Let0> = let <_Oa0> = call 'Nova.Compiler.Types':'freshVar'(E)
      in apply _Oa0(call 'Nova.Prelude':'semigroupAppendImpl'(#{#<108>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<95>(8,1,'integer',['unsigned'|['big']])}#, Name))
      in case _Let0 of
        <{'Tuple', Tv, E_}> when 'true' -> let <_Oa0> = call 'Nova.Compiler.Types':'extendEnv'(E_)
      in apply apply _Oa0(Name)(let <_Oa0> = call 'Nova.Compiler.Types':'mkScheme'([])
      in apply _Oa0({'TyVar', Tv}))
      end
    end
      <_W0> when 'true' ->
        E
    end
       'inferBindsPass2'/3 = fun (_L0, _L1, _L2) ->
      case {_L0, _L1, _L2} of
        <{E, [], Sub}> when 'true' -> {'Right', у铞Ы九篚猝骄吁恺
        <{E, [Bind|Rest], Sub}> when 'true' -> case apply 'infer'/2(E, call 'maps':'get'('value', Bind)) of
      <{'Left', Err}> when 'true' ->
        {'Left', Err}
      <{'Right', ValRes}> when 'true' ->
        case apply 'inferPat'/3(call 'maps':'get'('env', ValRes), call 'maps':'get'('pattern', Bind), call 'maps':'get'('ty', ValRes)) of
      <{'Left', Err}> when 'true' ->
        {'Left', Err}
      <{'Right', PatRes}> when 'true' ->
        let <Scheme> = apply 'generalize'/2(E, let <_Oa0> = call 'Nova.Compiler.Types':'applySubst'(let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(call 'maps':'get'('sub', PatRes))
      in apply _Oa0(call 'maps':'get'('sub', ValRes)))
      in apply _Oa0(call 'maps':'get'('ty', ValRes)))
      in let <Env3> = case call 'maps':'get'('pattern', Bind) of
      <{'PatVar', Name}> when 'true' ->
        let <_Oa0> = call 'Nova.Compiler.Types':'extendEnv'(call 'maps':'merge'(E, с秕铘弪Ы俱犰ы狃螫骇珏臾ě泔躅翦颛汜祆ы狃螫骇珏臾ě孱雩嗅粢弩┅┅轭狃痨狃痨呦岚ㄎ犴濠ㄓ汨屙濠歼装麒孱趄蹂戾夹狒蓬鼍戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇狃痨吁怏粼锱铞Ж戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇泔眇矬逵踱篝Ж汜祆ы狃螫骇珏臾ě篚猝嗅粢弩┅轭狃痨呦岚ㄣ犰ы狃螫骇珏臾ě篚猝轴煲弩┅轭狃痨呦岚ㄣ犰ы狃螫骇珏臾ě孱雩嗅粢弩┅轭汜祆ы狃螫骇礤蜱濮ㄐ狒蓬霈р轭溟铉螫骄汜祆尼翎歪皈骇躅轱瞌ㄣ犰ы狃螫骇珏臾ě忾钿轭珞К嗅襞铞┈汜祆ы狃螫骇珏臾ě忾钿轭珞К农孱轭狃痨ч铈弪麻钿笮狍蟛Н敞蓬龀义篝戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇泔眇矬逵踱篝Ж汜祆ы狃螫骇珏臾ě篚猝嗅粢弩┅轭狃痨呦岚戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇泔眇矬逵踱篝Ж汜祆ы狃螫骇珏臾ě篚猝轴煲弩┅轭狃痨呦岚ㄓ踱┅孱孱孱轭戾寂铞组翳徐徙彖镬溴蝮狃痨п滗麻钿徐徙彖镬溴蝮Н波蓬霈麻钿螬轭狃痨ч铈弪麻钿笮狍蟛Н敞蓬鲎轸栊灬沐栾熹弪蟋麻钿蟋汜祆物鲠蔑眇殪弪赠疱螫骇屙痿吁怏臾īч铈弪娘Н骢ㄅ铞郁眙螬汜箦汜祆尼翎硫蜥Ш躅泔铙Ж郁眙螬镦姬物翳轭绉麒孱趄蹂体骠К狃痨物羯眇戾礤铘邃Н报｛＜卑本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑咕ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北簿ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北毒ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜辈本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜巢鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑熬ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜巢鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜垢鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑妇ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜构鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑肪ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺）见术篝Кц遽洄航郁眙翎殪Ш揭弩酏> when 'true' ->
        case Stmt of
      <{'DoExpr', E}> when 'true' ->
        case call 'Data.Array':'null'(Rest) of
      <'true'> when 'true' -> apply 'infer'/2(Env, E)
      <'false'> when 'true' -> case apply 'infer'/2(Env, E) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Res1}> when 'true' ->
        case apply 'inferDo'/2(call 'maps':'get'('env', Res1), Rest) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', RestRes}> when 'true' ->
        {'Right', 豉Ы俱犰ы狃螫骇珏臾ě豉К义篝义螬篚猝骄戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇泔眇矬逵踱篝Ж汜祆ы狃螫骇珏臾ě篚猝义篝义螬轭狃痨呦岚ㄣ犰ы狃螫骇珏臾ě篚猝义蟊┅у铞Ы俱犰ы狃螫骇珏臾ě孱雩义篝义螬
      <{'Right', RestRes}> when 'true' ->
        {'Right', 豉Ы俱犰ы狃螫骇珏臾ě豉К义篝义螬篚猝骄戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇泔眇矬逵踱篝Ж汜祆ы狃螫骇珏臾ě篚猝义篝义螬轭狃痨呦岚ㄣ犰ы狃螫骇珏臾ě篚猝义蟊┅у铞Ы俱犰ы狃螫骇珏臾ě孱雩义篝义螬
      end
      <{'Right', Res1}> when 'true' ->
        case apply 'inferDo'/2(call 'maps':'get'('env', Res1), Rest) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', RestRes}> when 'true' ->
        {'Right', 豉Ы俱犰ы狃螫骇珏臾ě豉К义篝义螬篚猝骄戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇泔眇矬逵踱篝Ж汜祆ы狃螫骇珏臾ě篚猝义篝义螬轭狃痨呦岚ㄣ犰ы狃螫骇珏臾ě篚猝义蟊┅у铞Ы俱犰ы狃螫骇珏臾ě孱雩义篝义螬
      <{'Right', RestRes}> when 'true' ->
        {'Right', 豉Ы俱犰ы狃螫骇珏臾ě豉К义篝义螬篚猝骄戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇泔眇矬逵踱篝Ж汜祆ы狃螫骇珏臾ě篚猝义篝义螬轭狃痨呦岚ㄣ犰ы狃螫骇珏臾ě篚猝义蟊┅у铞Ы俱犰ы狃螫骇珏臾ě孱雩义篝义螬
      end
      end
    end
      <{'DoBind', Pat, E}> when 'true' ->
        case apply 'infer'/2(Env, E) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Res1}> when 'true' ->
        let <_DLet0> = let <_Oa0> = call 'Nova.Compiler.Types':'freshVar'(call 'maps':'get'('env', Res1))
      in apply _Oa0(#{#<105>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']])}#)
      in case _DLet0 of
        <{'Tuple', InnerTv, Env1}> when 'true' -> let <InnerTy> = {'TyVar', InnerTv}
      in case apply 'inferPat'/3(Env1, Pat, InnerTy) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', PatRes}> when 'true' ->
        case apply 'inferDo'/2(call 'maps':'get'('env', PatRes), Rest) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', RestRes}> when 'true' ->
        let <Sub> = let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(call 'maps':'get'('sub', RestRes))
      in apply _Oa0(let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(call 'maps':'get'('sub', PatRes))
      in apply _Oa0(call 'maps':'get'('sub', Res1)))
      in {'Right', 豉Ы俱犰ы狃螫骇珏臾ě豉К义篝义螬篚猝骄吁猬у铞Ы俱犰ы狃螫骇珏臾ě孱雩义篝义螬
      <{'Right', RestRes}> when 'true' ->
        let <Sub> = let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(call 'maps':'get'('sub', RestRes))
      in apply _Oa0(let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(call 'maps':'get'('sub', PatRes))
      in apply _Oa0(call 'maps':'get'('sub', Res1)))
      in {'Right', 豉Ы俱犰ы狃螫骇珏臾ě豉К义篝义螬篚猝骄吁猬у铞Ы俱犰ы狃螫骇珏臾ě孱雩义篝义螬
      end
      <{'Right', PatRes}> when 'true' ->
        case apply 'inferDo'/2(call 'maps':'get'('env', PatRes), Rest) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', RestRes}> when 'true' ->
        let <Sub> = let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(call 'maps':'get'('sub', RestRes))
      in apply _Oa0(let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(call 'maps':'get'('sub', PatRes))
      in apply _Oa0(call 'maps':'get'('sub', Res1)))
      in {'Right', 豉Ы俱犰ы狃螫骇珏臾ě豉К义篝义螬篚猝骄吁猬у铞Ы俱犰ы狃螫骇珏臾ě孱雩义篝义螬
      <{'Right', RestRes}> when 'true' ->
        let <Sub> = let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(call 'maps':'get'('sub', RestRes))
      in apply _Oa0(let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(call 'maps':'get'('sub', PatRes))
      in apply _Oa0(call 'maps':'get'('sub', Res1)))
      in {'Right', 豉Ы俱犰ы狃螫骇珏臾ě豉К义篝义螬篚猝骄吁猬у铞Ы俱犰ы狃螫骇珏臾ě孱雩义篝义螬
      end
      end
      end
      <{'Right', Res1}> when 'true' ->
        let <_DLet0> = let <_Oa0> = call 'Nova.Compiler.Types':'freshVar'(call 'maps':'get'('env', Res1))
      in apply _Oa0(#{#<105>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']])}#)
      in case _DLet0 of
        <{'Tuple', InnerTv, Env1}> when 'true' -> let <InnerTy> = {'TyVar', InnerTv}
      in case apply 'inferPat'/3(Env1, Pat, InnerTy) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', PatRes}> when 'true' ->
        case apply 'inferDo'/2(call 'maps':'get'('env', PatRes), Rest) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', RestRes}> when 'true' ->
        let <Sub> = let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(call 'maps':'get'('sub', RestRes))
      in apply _Oa0(let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(call 'maps':'get'('sub', PatRes))
      in apply _Oa0(call 'maps':'get'('sub', Res1)))
      in {'Right', 豉Ы俱犰ы狃螫骇珏臾ě豉К义篝义螬篚猝骄吁猬у铞Ы俱犰ы狃螫骇珏臾ě孱雩义篝义螬
      <{'Right', RestRes}> when 'true' ->
        let <Sub> = let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(call 'maps':'get'('sub', RestRes))
      in apply _Oa0(let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(call 'maps':'get'('sub', PatRes))
      in apply _Oa0(call 'maps':'get'('sub', Res1)))
      in {'Right', 豉Ы俱犰ы狃螫骇珏臾ě豉К义篝义螬篚猝骄吁猬у铞Ы俱犰ы狃螫骇珏臾ě孱雩义篝义螬
      end
      <{'Right', PatRes}> when 'true' ->
        case apply 'inferDo'/2(call 'maps':'get'('env', PatRes), Rest) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', RestRes}> when 'true' ->
        let <Sub> = let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(call 'maps':'get'('sub', RestRes))
      in apply _Oa0(let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(call 'maps':'get'('sub', PatRes))
      in apply _Oa0(call 'maps':'get'('sub', Res1)))
      in {'Right', 豉Ы俱犰ы狃螫骇珏臾ě豉К义篝义螬篚猝骄吁猬у铞Ы俱犰ы狃螫骇珏臾ě孱雩义篝义螬
      <{'Right', RestRes}> when 'true' ->
        let <Sub> = let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(call 'maps':'get'('sub', RestRes))
      in apply _Oa0(let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(call 'maps':'get'('sub', PatRes))
      in apply _Oa0(call 'maps':'get'('sub', Res1)))
      in {'Right', 豉Ы俱犰ы狃螫骇珏臾ě豉К义篝义螬篚猝骄吁猬у铞Ы俱犰ы狃螫骇珏臾ě孱雩义篝义螬
      end
      end
      end
      end
      <{'DoLet', Binds}> when 'true' ->
        case apply 'inferBinds'/2(Env, Binds) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', LetRes}> when 'true' ->
        apply 'inferDo'/2(call 'maps':'get'('env', LetRes), Rest)
      <{'Right', LetRes}> when 'true' ->
        apply 'inferDo'/2(call 'maps':'get'('env', LetRes), Rest)
      end
    end
    end

'inferFields'/2 =
  fun (Env, Fields) ->
    apply 'inferFieldsGo'/4(Env, Fields, [], call 'Nova.Compiler.Types':'emptySubst'())

'inferGuard'/2 =
  fun (_P0, _P1) ->
    case {_P0, _P1} of
      <{E, 'Nothing'}> when 'true' ->
        {'Right', у铞Ы九篚猝骄汜祆物鲠蔑眇殪弪赠疱螫骇屙痿吁怏臾ī
      <{E, {'Just', GuardExpr}}> when 'true' ->
        apply 'inferGuardExpr'/2(E, GuardExpr)
    end

'inferGuardExpr'/2 =
  fun (_P0, _P1) ->
    case {_P0, _P1} of
      <{E, {'ExprBinOp', #{#<38>(8,1,'integer',['unsigned'|['big']]),#<38>(8,1,'integer',['unsigned'|['big']])}#, Left, Right}}> when 'true' ->
        case apply 'inferGuardExpr'/2(E, Left) of
      <{'Left', Err}> when 'true' ->
        {'Left', Err}
      <{'Right', LeftRes}> when 'true' ->
        case apply 'inferGuardExpr'/2(call 'maps':'get'('env', LeftRes), Right) of
      <{'Left', Err}> when 'true' ->
        {'Left', Err}
      <{'Right', RightRes}> when 'true' ->
        {'Right', у铞Ы俱犰ы狃螫骇珏臾ě孱雩议玷粢弩┈篚猝骄戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇泔眇矬逵踱篝Ж汜祆ы狃螫骇珏臾ě篚猝议玷粢弩┅轭狃痨呦岚ㄣ犰ы狃螫骇珏臾ě篚猝体骠义螬
    end
    end
      <{E, {'ExprBinOp', #{#<60>(8,1,'integer',['unsigned'|['big']]),#<45>(8,1,'integer',['unsigned'|['big']])}#, PatExpr, ValExpr}}> when 'true' ->
        case apply 'infer'/2(E, ValExpr) of
      <{'Left', Err}> when 'true' ->
        {'Left', Err}
      <{'Right', ValRes}> when 'true' ->
        let <Pat> = apply 'exprToPattern'/1(PatExpr)
      in case apply 'inferPat'/3(call 'maps':'get'('env', ValRes), Pat, call 'maps':'get'('ty', ValRes)) of
      <{'Left', Err}> when 'true' ->
        {'Left', Err}
      <{'Right', PatRes}> when 'true' ->
        {'Right', у铞Ы俱犰ы狃螫骇珏臾ě孱雩嗅粢弩┈篚猝骄戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇泔眇矬逵踱篝Ж汜祆ы狃螫骇珏臾ě篚猝嗅粢弩┅轭狃痨呦岚ㄣ犰ы狃螫骇珏臾ě篚猝轴煲弩┅
    end
    end
      <{E, {'ExprBinOp', #{#<44>(8,1,'integer',['unsigned'|['big']])}#, Left, Right}}> when 'true' ->
        apply 'inferGuardExpr'/2(E, {'ExprBinOp', #{#<38>(8,1,'integer',['unsigned'|['big']]),#<38>(8,1,'integer',['unsigned'|['big']])}#, Left, Right})
      <{E, Expr}> when 'true' ->
        case apply 'infer'/2(E, Expr) of
      <{'Left', Err}> when 'true' ->
        {'Left', Err}
      <{'Right', Res}> when 'true' ->
        {'Right', у铞Ы俱犰ы狃螫骇珏臾ě孱雩义螬篚猝骄汜祆ы狃螫骇珏臾ě篚猝义螬
    end
    end

'inferMany'/2 =
  fun (Env, Exprs) ->
    apply 'inferManyGo'/4(Env, Exprs, [], call 'Nova.Compiler.Types':'emptySubst'())

'instantiate'/2 =
  fun (Env, Scheme) ->
    let <_Let0> = Scheme
      in case _Let0 of
        <豉Ш接汨屙逶鲠蝮Ш接汨屙逯狎簖麒孱趄蹂狃痨ч铙翎铘獒翦秋Н川鱼桢礤赠蓬霈汜祆尼翎涕篝Шф蝻砥镬溽忪濮ㄓ汨屙逯狎螬汜祆尼翎歪皈骇屙痿Ж┅孱ъ轶敉狃组翳深溴Н骢ㄆ涕篝戾趄邈х铵骢ㄟ贪咛暴汜箦咛艾咛饼镦见咦艾圯麒孱趄蹂圯见涩圬伢蔟麒孱趄蹂坩痧禊屁涩丞狃痨х铵波汜祆у蜢犷绉骇Ж涩暴伢┹孱轭狃痨х铵波艾涕篝ы弪珏砒痫螋笞轸柙疱领獒箦螫骢ㄅ铞砒痫螋螬戾寂铞本汜祆物鲠蔑眇殪弪赠疱螫骇礤蜱迮痫螋笤锱铞Ж蓬霈砒痫螋螬轭戾纪镤蹯辶扉狍弩汜箦汜祆尼翎歪皈骇轶彭痿Ж汜祆ы狃螫骇珏臾ě屮疳钿邃赠疱领獒箦螫砒痫螋螬镦姬趄蹂Ь麒孱趄蹂狃痨у疳钿惋漉戾领獒箦螫报汜祆ы狃螫骇珏臾ě豉疱领獒箦螫砒痫螋螬姬驷祗濮麒孱趄蹂汜祆ы狃螫骇珏臾ě屮疳钿邃赠疱领獒箦螫砒痫螋螬孱轭戾趄邈п滗涉义泔蜾领獒螫骢ㄟ贪咛暴汜箦咛艾咛饼镦见努г躔戾К吾礤赠麒孱趄蹂汜箦狃痨ч笠邈矧湓疱Н报赠镦姬趄蹂Ь麒孱趄蹂戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇屮翦钿赠疱领獒螫ㄅ轭狃痨狃痨呦岚ㄎ犴濠ㄔ姬驷祗濮麒孱趄蹂孱孱轭戾寂铞簿汜祆尼翎硫蜥Шф镬潇Ж骢ㄟ玩艾咄姹狃痨п滗涉义泔蜾领獒螫波咄姘咄姹┈蓬霰汜祆尼翎歪皈骇麸疹骘熹徕戾Ж惋漉戾领獒箦螬轭蓬霾ы肷铙粢弩蹯臾骢ㄔ农豉Ы驹у铞Ы九ю蝻沐篌深骈腻沆狎狒轱铙Н骢ㄅ铞腻沆螬戾趄邈ю蝻沐篌深骈Н骢ㄟ贪咛暴汜箦咛艾咛饼镦见努腻沆深骈К深纨麒孱趄蹂汜箦戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇祜镫躔蓬雩ㄅ轭狃痨呦岚ㄣ犰ы狃螫骇珏臾ě骢钽糸镱吾礤К深姗镦见术篝К鱼桢礤麒孱趄蹂戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇屮翦钿蓬雩ㄅ轭狃痨狃痨呦岚ㄣ犰ы狃螫骇珏臾ě镳弪狒矧К深姗┄鱼桢礤姬物翳轭绉麒孱趄蹂孱见努咦褒麒孱趄蹂孱轭汜祆尼翎硫蜥Шф镬潇Ж骢ㄟ玩艾咄姹狃痨ю蝻沐篌深骈Н波咄姘咄姹┈蓬霈腻沆螬ю蝻沐篌物钇躅泗轱铙Н骢ㄅ铞腻沆螬狃痨ю蝻沐篌物钇躅泗轱铙组翳领獒箦螫敞汜祆尼翎歪皈骇屙痿Ж┈蓬霈腻沆螬豉疱砒痱燥赠疱Н骢ㄟ邪咝暴汜箦咝艾咝饼镦见轴蛲狃г砒痱轴颛吾礤麒孱趄蹂汜箦汜祆尼翎歪皈骇祜镫躔Ж吾礤轴蛲狃镦见术篝К增麒孱趄蹂г轴颛增姬物翳轭绉麒孱趄蹂г蔑瞌戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇黼悦镱Ж吾礤轭狃痨呦岚ㄛ荸孱见轴蛲狃г砒痱蔑瞌吾礤麒孱趄蹂汜箦吾礤镦迹＜沟鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺＞麒孱趄蹂г轴颛戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇黼灾狎Ж汜祆у蜢犷绉骇Ж构供轭狃痨呦岚ǎ＜沟鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺）迹＜抖鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑妇ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜狗鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北熬ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺＞麒孱趄蹂汜祆物鲠蔑眇殪弪赠疱螫骇袈镲歆ī歼装麒孱趄蹂г蔑瞌戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇黼悦镱Ж吾礤轭狃痨呦岚ㄛ荸孱见轴蛲狃г砒痱琉皈片硫琮麒孱趄蹂戾剂蜱赠狃痨豉疱砒痱燥赠疱Н波轴蛲狃硫绌轭汜箦狃痨豉疱砒痱燥赠疱Н波轴蛲狃譬镦见г蔑瞌糟麒孱趄蹂г蔑瞌ь犴濮骄汜祆ы狃螫骇珏臾ě钺礤К糟┈п蜱螫骄汜祆尼翎硫蜥Ш箢镢Ж汜祆ы狃螫骇珏臾ě狎珞К糟┈硫缭
      <Other> when 'true' ->
        call 'Nova.Compiler.Types':'mkTyApp'(Other, ArgTy)
    end
      <{VarMap, {'TyExprArrow', A, B}}> when 'true' ->
        let <_Oa0> = call 'Nova.Compiler.Types':'tArrow'(apply 'typeExprToType'/2(VarMap, A))
      in apply _Oa0(apply 'typeExprToType'/2(VarMap, B))
      <{VarMap, {'TyExprRecord', Fields, MaybeRow}}> when 'true' ->
        let <FieldMap> = call 'Data.Map':'fromFoldable'(call 'lists':'map'(fun (_L0) ->
      case {_L0} of
        <{{'Tuple', L, T}}> when 'true' -> call 'Data.Tuple':'Tuple'(L, apply 'typeExprToType'/2(VarMap, T))
      end, Fields))
      in let <Row> = case MaybeRow of
      <{'Just', R}> when 'true' ->
        case call 'Data.Map':'lookup'(R, VarMap) of
      <{'Just', Tv}> when 'true' ->
        {'Just', Tv}
      <'Nothing'> when 'true' ->
        'Nothing'
    end
      <'Nothing'> when 'true' ->
        'Nothing'
    end
      in {'TyRecord', ф殄熹螫骄崎屐渫狃蝻鳔骄绎鼾
      <{VarMap, {'TyExprForAll', Vars, T}}> when 'true' ->
        let <VarList> = apply 'listMapWithIndex'/2(fun (I, Name) ->
      call 'Data.Tuple':'Tuple'(Name, let <_Oa0> = call 'Nova.Compiler.Types':'mkTVar'(call 'erlang':'-'(call 'erlang':'+'(I, 1)))
      in apply _Oa0(Name)), Vars)
      in let <NewVarMap> = call 'Data.Map':'union'(call 'Data.Map':'fromFoldable'(VarList), VarMap)
      in apply 'typeExprToType'/2(NewVarMap, T)
      <{VarMap, {'TyExprConstrained', _W0, T}}> when 'true' ->
        apply 'typeExprToType'/2(VarMap, T)
      <{VarMap, {'TyExprParens', T}}> when 'true' ->
        apply 'typeExprToType'/2(VarMap, T)
      <{VarMap, {'TyExprTuple', Ts}}> when 'true' ->
        call 'Nova.Compiler.Types':'tTuple'(call 'Data.Array':'fromFoldable'(call 'lists':'map'(fun (_Pc0) -> apply 'typeExprToType'/2(VarMap, _Pc0), Ts)))
    end

'withContext'/2 =
  fun (_P0, _P1) ->
    case {_P0, _P1} of
      <{Ctx, {'Left', Err}}> when 'true' ->
        {'Left', apply 'addErrorContext'/2(Ctx, Err)}
      <{_W0, {'Right', X}}> when 'true' ->
        {'Right', X}
    end

'wrapWithPatternGuards'/2 =
  fun (Guards, Body) ->
    letrec 'isPatternGuard'/1 = fun (_L0) ->
      case {_L0} of
        <{{'GuardPat', _W0, _W1}}> when 'true' -> 'true'
        <{_W0}> when 'true' -> 'false'
      end
      in let <PatternGuards> = call 'Data.List':'filter'(fun (_Mf0) -> apply 'isPatternGuard'/1(_Mf0), Guards)
      in apply 'buildPatternGuardCases'/2(PatternGuards, Body)

'addFunctionPlaceholdersWithAliases'/3 =
  fun (ImportedAliases, Env, Decls) ->
    let <LocalParamAliasMap> = apply 'collectParamTypeAliases'/1(Decls)
      in let <ImportedSimpleAliases> = call 'Data.Map':'mapMaybe'(fun (Info) ->
      case call 'Data.Array':'null'(call 'Nova.Compiler.Types':'getAliasInfoParams'(Info)) of
      <'true'> when 'true' -> {'Just', apply 'typeExprToType'/2(call 'Data.Map':'empty'(), call 'Nova.Compiler.Types':'getAliasInfoBody'(Info))}
      <'false'> when 'true' -> 'Nothing'
    end, ImportedAliases)
      in let <ParamAliasMap> = call 'Data.Map':'union'(LocalParamAliasMap, ImportedAliases)
      in let <LocalAliasMap> = apply 'collectTypeAliasesWithBase'/3(ImportedSimpleAliases, ParamAliasMap, Decls)
      in let <AliasMap> = LocalAliasMap
      in letrec 'addPlaceholder'/2 = fun (E, Decl) ->
      case Decl of
      <{'DeclFunction', Func}> when 'true' ->
        case call 'maps':'get'('typeSignature', Func) of
      <{'Just', Sig}> when 'true' ->
        let <Ty> = apply 'typeExprToTypeWithAllAliases'/4(AliasMap, ParamAliasMap, call 'Data.Map':'empty'(), call 'maps':'get'('ty', Sig))
      in let <FreeVarIds> = call 'Data.Array':'fromFoldable'(call 'Data.Set':'toUnfoldable'(call 'Nova.Compiler.Types':'freeTypeVars'(Ty)))
      in let <ForallVars> = call 'Data.Array':'filter'(fun (Id) ->
      call 'erlang':'<'(Id, 0), FreeVarIds)
      in let <Tvars> = call 'lists':'map'(fun (Id) ->
      ч洄骄射ь犴濮骄汜祆物鲠序屐蹁濮骇箦黹珧秕鹆痧孱渖眇歆ǎ＜北毒ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺，戾歼祁熬狃痨ч铘燥郁蜷铉Н皑轭狃痨咂畎ㄣ犰у蜢犷绉骇Ж射┅骑蜥祆轴蝮轭戾加汨屙寰戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇黼鱼桢礤Ж增狎螬轭狃痨呦岚ㄔ轭戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇屮翦钿蓬雩ㄅ轭狃痨狃痨呦岚ㄣ犰ы狃螫骇珏臾ě钺礤К契钽┅ㄓ汨屙濠姬物翳轭绉麒孱趄蹂汜箦汜祆尼翎歪皈骇祜镫躔Ж汜祆ы狃螫骇珏臾ě钺礤К契钽┈狃痨箝缤狃Н皑┅镦见术篝К赠砒痱麒孱趄蹂戾荚狃痨豉疱砒痱燥赠疱组翳领炝扉狍弩Н川领獒笸狃嗅蜥砹扉狍歪瓞汜祆尼翎歪皈骇屙痿Ж┈赠砒痱轭戾计蝈逯狎射缶汜祆尼翎硫蜥Шф蝻砥镬溽忪濮ㄣ犰尼翎渝臾骇麸疹骘熹徕戾Ж汜祆物鲠蔑眇殪弪赠疱螫骇骝邋赠疱轴蝮Ж赠┅轭戾计矧犰熘狎缶汜祆尼翎硫蜥Шф殪翦颛ㄦ躅ㄉ洎汜祆у蜢犷绉骇姬ㄉ洮癌乞邋轴蛏潴轭戾荚鲠蝮汜祆ъ轶趔Шы狃Ж骢ㄉ洎ч洄骄射ь犴濮骄汜祆物鲠序屐蹁濮骇箦黹珧秕鹆痧孱渖眇歆ǎ＜北毒ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺，戾歼祁熬狃痨ч铘燥郁蜷铉Н皑轭狃痨咂畎ㄣ犰у蜢犷绉骇Ж射┅骑蜥祆轴蝮轭戾加汨屙寰戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇黼鱼桢礤Ж增狎螬轭狃痨呦岚ㄔ轭戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇屮翦钿蓬雩ㄅ轭狃痨狃痨呦岚ㄣ犰ы狃螫骇珏臾ě钺礤К契钽┅ㄓ汨屙濠姬物翳轭绉麒孱趄蹂戾歼体舭戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇骝弩柚狎Ж农轭狃痨呦岚ㄣ犰物鲠序屐蹁濮骇箦黹珧秕鹆痧孱渖眇歆ǎ＜卑簿ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北熬ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜沟鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺，汜祆ы狃螫骇珏臾ě钺礤К契钽┅轭汜箦咛弭镦见г躔戾К增胚麒孱趄蹂戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇屮翦钿蓬雩ㄅ擤轭狃痨狃痨呦岚ㄣ犰ы狃螫骇珏臾ě钺礤К契钽┅戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇黼鱼桢礤Ж圯轭狃痨呦岚г轴颛增┅孱孱孱见腻沆骑蝈殓钌眇矧臾崎麒孱趄蹂戾荚狃痨豉疱砒痱燥赠疱组翳领炝扉狍弩Н川领獒笸狃嗅蜥砹扉狍歪瓞汜祆尼翎歪皈骇屙痿Ж┈汜祆ы狃螫骇珏臾ě豉疱娱珙狒躜濮崎┅轭戾计蝈逯狎缶汜祆尼翎硫蜥Шф蝻砥镬溽忪濮ㄣ犰尼翎渝臾骇麸疹骘熹徕戾Ж汜祆物鲠蔑眇殪弪赠疱螫骇骝邋赠疱轴蝮Ж赠┅轭戾荚鲠蝮汜祆ъ轶趔Шы狃Ж骢ㄉ洎ч洄骄射ь犴濮骄汜祆物鲠序屐蹁濮骇箦黹珧秕鹆痧孱渖眇歆ǎ＜狗鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺，戾歼祁熬狃痨ч铘燥郁蜷铉Н皑轭狃痨咂畎ㄉ洎乞邋轴蝮轭戾加汨屙寰戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇黼鱼桢礤Ж增狎螬轭狃痨呦岚ㄔ轭戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇屮翦钿蓬雩ㄅ轭狃痨狃痨呦岚ㄣ犰ы狃螫骇珏臾ě骢钽糸镱吾礤К崎┅ㄓ汨屙濠歼装麒孱趄蹂孱с镬戾泗娱绉骢ㄍ腻沆汜箦腻沆镦见腻沆赠疱娱绉娱琮麒孱趄蹂汜祆尼翎歪皈骇轭箦螋Ж汜祆ы狃螫骇珏臾ě钺礤К娱绌汜祆ы狃螫骇珏臾ě豉К娱绌桐歼装麒孱趄蹂孱箝缤狃Н骢ī汜祆尼翎硫蜥Шф镬潇Ж骢ㄟ玩艾咄姹狃痨с镬戾泗娱绉波咄姘咄姹┈汜祆尼翎歪皈骇屙痿Ж┈腻沆螬轭汜祆尼翎硫蜥Шф镬潇Ж骢ㄟ玩艾咄姹狃痨п滗徐徙彖镬溴颛波咄姘咄姹┈蓬霈腻沆螬п滗轴祯弩燥砒痫螋螫骢ㄅ痫螋蟋蓬霈腻沆螬戾趄邈п滗轴祯濮骢ㄟ贪咛暴汜箦咛艾咛饼镦见砒瓞腻沆契钽糸镱К契钽麒孱趄蹂汜箦汜祆尼翎歪皈骇祜镫躔Ж汜祆ы狃螫骇珏臾ě钺礤К契钽┈汜祆ы狃螫骇珏臾ě忾钿轭珞К蓬雯镦见术篝К鱼桢礤麒孱趄蹂汜祆ы狃螫骇礤蜱濮ㄅ瓞鲠祯弩Ы俱犰尼翎歪皈骇轭箦螋Ж汜祆ы狃螫骇珏臾ě钺礤К契钽┈鱼桢礤汜祆ы狃螫骇珏臾ě鲠祯弩К砒皓姬物翳轭绉麒孱趄蹂砒孱见砒瓞咦褒麒孱趄蹂砒孱轭戾甲轸柚犰蹂缶汜祆尼翎硫蜥Шф镬潇Ж骢ㄟ玩艾咄姹狃痨п滗轴祯濮波咄姘咄姹┈砒痫螋蟋腻沆螬轭戾寂疳钿邃领獒箦缶狃痨с镬戾泗赠疱领獒箦螫报腻沆螬轭汜祆ы狃螫骇礤蜱濮ㄗ轸柚犰蹂蟋у疳钿邃赠疱领獒箦螫骄砒疳钿邃领獒箦簖р蹰熹蔑铙趄蹉麸蛟疱Н骢ㄖ狎歪瓞崎屐潴义篚祠赠疱狃痨р蹰熹蔑铙趄蹉麸蛟疱秋Н敞轴蛲狃义篚祠赠疱崎屐潴р蹰熹蔑铙趄蹉麸蛟疱秋Н骢ㄟ邪咝爆咝博汜箦咝艾咝爆咝昌镦见咦艾义篚祠赠疱圯麒孱趄蹂义篚祠赠疱见轴蛲狃义篚祠赠疱燮殄熹义篝蔟麒孱趄蹂戾计殄熹赠狃痨豉疱砒痱燥赠疱Н波轴蛲狃汜祆ы狃螫骇珏臾ě豉К崎屐洎轭戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇袅蝌秣Ж崎屐湓轭狃痨呦岚ㄡ痧禊р蹰熹蔑铙趄蹉麸蛟疱秋Н敞轴蛲狃义篚祠赠疱义篝┅孱с桢汶尼翎赠疱组翳领獒箦螫骢领獒笸狃蓬霈聂狃痨с桢汶尼翎赠疱组翳领炝扉狍弩Н川领獒笸狃汜祆尼翎歪皈骇屙痿Ж┈蓬霈聂с桢汶惋漉戾Н骢ㄒ彗轶趄蓬霈腻沆螬戾忌眇矧翦淞扉狍弩狃痨с镬戾泗身痫螋邃领獒箦螫波义玳篝蝙腻沆螬轭戾寂铞本汜祆物鲠蔑眇殪弪身痫螋序镢弩箫颛骇痱镢弩笊眇矧趔Ж义玳篝蝙蓬霈腻沆螬轭戾寂铞簿狃痨ю蝻沐篌物钇躅泗轱铙组翳领獒箦螫敞身痫螋邃领獒箦蟋蓬霰腻沆螬轭戾寂铞尘狃痨п滗契钽糸镱徐徙彖镬溴蝮组翳领獒箦螫敞身痫螋邃领獒箦蟋蓬霾腻沆螬轭戾寂铞淳狃痨ю蝻沐篌深骈腻沆狎狒轱铙Н波蓬龀腻沆螬轭狃痨鏖翳蔑铘屮臾波｛＜构鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑淳ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜构鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑肪ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜钒鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北肪ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北熬ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜构鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北毒ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑稻ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北熬ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜抖鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑熬ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑稻ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北稻ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺，狃痨с桢汶契钽糸镱嘛溟弩Н波蓬龃腻沆螬с桢汶五黥疱组翳领獒箦螫骢领獒笸狃蓬霈昔狃痨с桢汶五黥疱组翳领炝扉狍弩Н川领獒笸狃汜祆尼翎歪皈骇屙痿Ж┈蓬霈昔с镬戾泗乞镯身痫螋腻沆Н骢ㄒ彗轶趄零悻身皓汜箦戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇祜镫躔惋漉戾Ж义玳篝蝙轭狃痨呦岚ㄣ犰ы狃螫骇珏臾ě盹漉戾吾礤К身皓镦姬物翳轭绉麒孱趄蹂零见术篝К砒痫螋簖麒孱趄蹂汜箦汜祆ы狃螫骇珏臾ě犰獒螫身皓镦见术篝К咦褒麒孱趄蹂汜箦汜祆尼翎涕篝Шь蹯歆ㄣ犰ы狃螫骇珏臾ě轸屙螫身皓镦姬趄蹂Ь麒孱趄蹂零姬驷祗濮麒孱趄蹂汜祆尼翎硫蜥Шф镬潇Ж骢ㄍ婶屙汜祆尼翎歪皈骇轭箦螋Ж狃痨х弭身痫螋婶屙吾礤Н报婶屙┈汜祆ы狃螫骇珏臾ě盹漉戾吾礤К身皓桐零悻汜祆尼翎硫蜥Шф蝻砥镬溽忪濮ㄣ犰ы狃螫骇珏臾ě轸屙螫身皓┅孱姬物翳轭绉麒孱趄蹂汜箦汜祆ы狃螫骇珏臾ě栝溟铉К身皓镦姬趄蹂Ь麒孱趄蹂戾剂祆吾礤缶狃痨х弭砒痫螋邃吾礤螫报砒痫螋螬轭戾既殇溴钗犴弩汜祆尼翎渝臾骇骝镯骑熹徕戾Ж汜祆ъ轶趔Шы狃Ж骢ㄟ玩癌狃痨х弭身痫螋婶屙吾礤Н报咄姘┈汜祆尼翎硫蜥Шф蝻砥镬溽忪濮ㄣ犰ы狃螫骇珏臾ě轸屙螫身皓┅轭汜祆尼翎硫蜥Шф镬潇Ж骢ㄍ吾礤汜箦汜祆尼翎渝臾骇礤礅弪Ж吾礤乳滗孱吾礤螬镦姬趄蹂Ь麒孱趄蹂姬驷祗濮麒孱趄蹂汜祆尼翎歪皈骇轭箦螋Ж吾礤汜祆ы狃螫骇珏臾ě盹漉戾吾礤К身皓桐孱洮零悻领煳犴弩姬驷祗濮麒孱趄蹂汜箦汜祆尼翎涕篝Шь蹯歆ㄣ犰ы狃螫骇珏臾ě轸屙螫身皓镦姬趄蹂Ь麒孱趄蹂戾剂祆吾礤缶狃痨х弭砒痫螋邃吾礤螫报砒痫螋螬轭汜祆尼翎硫蜥Шф镬潇Ж骢ㄍ吾礤汜祆尼翎歪皈骇轭箦螋Ж吾礤汜祆ы狃螫骇珏臾ě盹漉戾吾礤К身皓桐零悻领煳犴弩姬驷祗濮麒孱趄蹂汜祆尼翎硫蜥Шф镬潇Ж骢ㄍ婶屙汜祆尼翎歪皈骇轭箦螋Ж狃痨х弭身痫螋婶屙吾礤Н报婶屙┈汜祆ы狃螫骇珏臾ě盹漉戾吾礤К身皓桐零悻汜祆尼翎硫蜥Шф蝻砥镬溽忪濮ㄣ犰ы狃螫骇珏臾ě轸屙螫身皓┅孱孱孱孱с镬戾泗赠疱领獒箦笞轸杪狍濮骢箩箦领獒箦蟋嗅蜥砹扉狍弩腻沆螬戾趄邈с镬戾泗砒疳钿邃Н骢ㄉ铋糸犰歪瓞同腻沆汜箦腻沆镦见腻沆赠疱领獒螫葬麒孱趄蹂汜箦汜祆尼翎涕篝Шь蹯歆ㄣ犰ы狃螫骇珏臾ě豉疱轴蝮К葬┅镦姬趄蹂Ь麒孱趄蹂汜祆尼翎歪皈骇轭箦螋Ж汜祆ы狃螫骇珏臾ě钺礤К葬┈狃痨豉疱砒痱燥赠疱组翳领炝扉狍弩Н川深轸獒焱狃嗅蜥砹扉狍弩汜祆尼翎歪皈骇屙痿Ж┈汜祆ы狃螫骇珏臾ě豉К葬┅桐姬驷祗濮麒孱趄蹂孱歼装麒孱趄蹂孱с镬戾泗深轸獒歆骢ㄍ腻沆汜箦腻沆镦见腻沆赠疱领獒螫葬麒孱趄蹂汜箦汜祆尼翎涕篝Шь蹯歆ㄣ犰ы狃螫骇珏臾ě豉疱轴蝮К葬┅镦姬趄蹂Ь麒孱趄蹂汜祆尼翎歪皈骇轭箦螋Ж汜祆ы狃螫骇珏臾ě钺礤К葬┈狃痨豉疱砒痱燥赠疱Н波汜祆尼翎歪皈骇屙痿Ж┈汜祆ы狃螫骇珏臾ě豉К葬┅桐姬驷祗濮麒孱趄蹂孱歼装麒孱趄蹂孱轭戾忌铋糸犰汜祆尼翎硫蜥Шф镬潇Ж骢ㄟ玩艾咄姹狃痨с镬戾泗深轸獒歆波咄姘咄姹┈箩箦领獒箦蟋腻沆螬轭戾寂疳钿邃汜祆尼翎硫蜥Шф镬潇Ж骢ㄟ秀艾咝惚狃痨с镬戾泗砒疳钿邃Н敞深轸獒飕咝惆咝惚┈箩箦领獒箦蟋腻沆螬轭砒疳钿邃ч眇矧羯翦恣骢ㄅ痫螋蟋蓬霈婶屙戾纪镤蹯辶扉狍弩汜箦汜祆尼翎歪皈骇轶彭痿Ж汜祆ы狃螫骇珏臾ě屮疳钿邃赠疱领獒箦螫砒痫螋螬镦姬趄蹂Ь麒孱趄蹂狃痨у疳钿惋漉戾领獒箦螫报汜祆ы狃螫骇珏臾ě豉疱领獒箦螫砒痫螋螬姬驷祗濮麒孱趄蹂汜祆ы狃螫骇珏臾ě屮疳钿邃赠疱领獒箦螫砒痫螋螬孱轭戾趄邈п滗领煲邈矧淞扉狍弩Н骢ㄅ戾趄邈п滗涉义泔蜾Н骢ㄟ贪咛暴汜箦咛艾咛饼镦见挪г躔戾К吾礤赠麒孱趄蹂汜箦狃痨ч笠邈矧湓疱Н报赠镦姬趄蹂Ь麒孱趄蹂戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇屮翦钿赠疱领獒螫ㄅ博轭狃痨狃痨呦岚ㄎ犴濠ㄔ姬驷祗濮麒孱趄蹂挪孱孱轭汜祆尼翎硫蜥Шф镬潇Ж骢ㄟ玩艾咄姹狃痨п滗涉义泔蜾Н波咄姘咄姹┈努汜祆尼翎歪皈骇麸疹骘熹徕戾Ж惋漉戾领獒箦螬轭汜箦婶屙镦见身痫螋轴祯濮吾礤麒孱趄蹂汜箦汜祆尼翎歪皈骇祜镫躔Ж吾礤汜祆ы狃螫骇珏臾ě鲠祯弩К砒痫螋螬镦见术篝К鱼桢礤麒孱趄蹂狃痨п滗领煲邈矧淞扉狍弩Н报戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇屮翦钿蓬雩ㄅ铞轭狃痨狃痨呦岚ㄎ犴濠ㄓ汨屙濠姬物翳轭绉麒孱趄蹂汜箦汜祆尼翎歪皈骇祜镫躔Ж吾礤汜祆ы狃螫骇珏臾ě泔铙趄蹉麸蝮К砒痫螋螬镦见术篝К鱼桢礤麒孱趄蹂狃痨п滗领煲邈矧淞扉狍弩Н报戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇屮翦钿蓬雩ㄅ铞轭狃痨狃痨呦岚ㄎ犴濠ㄓ汨屙濠姬物翳轭绉麒孱趄蹂汜箦汜祆尼翎歪皈骇祜镫躔Ж吾礤惋漉戾领獒箦螬镦见术篝К赠麒孱趄蹂狃痨п滗领煲邈矧淞扉狍弩Н报戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇屮翦钿赠疱领獒螫ㄅ铞轭狃痨狃痨呦岚ㄎ犴濠ㄔ┅姬物翳轭绉麒孱趄蹂狃痨п滗领煲邈矧淞扉狍弩Н报蓬雯孱孱孱见身痫螋赠疱К赠疱吾礤羽邈麒孱趄蹂戾寂铞呔汜箦汜祆尼翎歪皈骇祜镫躔Ж赠疱吾礤汜祆ы狃螫骇珏臾ě豉疱领獒箦螫砒痫螋螬镦见术篝К领獒笊铈稞麒孱趄蹂戾寂疳钿邃赠汜箦汜祆尼翎歪皈骇祜镫躔Ж赠疱吾礤惋漉戾领獒箦螬镦见术篝К赠麒孱趄蹂赠姬物翳轭绉麒孱趄蹂狃痨豉疱砒痱燥赠疱Н波汜祆尼翎歪皈骇屙痿Ж┈汜祆物鲠蔑眇殪弪赠疱螫骇珏袅扉狍深骘嘛澌Ж领獒笊铈铹孱轭戾家彐弪孱沐湮犴弩狃痨с镬戾泗赠疱砒痱吾礤螫报汜祆物鲠蔑眇殪弪赠疱螫骇珏袅扉狍深骘嘛澌Ж领獒笊铈铹轭戾寂本戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇屮翦钿赠疱领獒螫ㄅ铞轭狃痨狃痨呦岚ㄔ疱吾礤┄砒疳钿邃赠轭戾趄邈п滗涉义泔蜾领獒螫骢ㄅ吾礤汜箦汜祆尼翎歪皈骇祜镫躔Ж吾礤惋漉戾领獒箦螬镦见术篝К领獒笤麒孱趄蹂汜箦狃痨ч笠邈矧湓疱Н报领獒笤镦姬趄蹂Ь麒孱趄蹂戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇屮翦钿赠疱领獒螫ㄅ轭狃痨狃痨呦岚ㄎ犴濠领獒笤歼麒孱趄蹂孱歼装麒孱趄蹂孱轭汜祆尼翎硫蜥Шф镬潇Ж骢ㄟ玩艾咄姹狃痨п滗涉义泔蜾领獒螫波咄姘咄姹┈疟汜祆尼翎渝臾骇麸疹骘熹徕戾Ж义驽蝈钽邃吾礤螬姬物翳轭绉麒孱趄蹂汜箦汜祆尼翎歪皈骇祜镫躔Ж赠疱吾礤惋漉戾领獒箦螬镦见术篝К赠麒孱趄蹂戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇屮翦钿赠疱领獒螫ㄅ铞轭狃痨狃痨呦岚ㄔ疱吾礤┄赠姬物翳轭绉麒孱趄蹂蓬孱孱轭汜箦汜祆尼翎歪皈骇祜镫躔Ж赠疱吾礤汜祆ы狃螫骇珏臾ě豉疱螫砒痫螋螬镦姬物翳轭绉麒孱趄蹂狃痨п滗领煲邈矧淞扉狍弩Н报蓬鲞见术篝К赠疱深骘麒孱趄蹂汜箦羽邈镦姬身痫螋领歆麒孱趄蹂狃痨п滗领煲邈矧淞扉狍弩Н报戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇礤蜱逶疱砒痫螋Ж蓬鲞轭狃痨狃痨狃痨呦岚ㄅ痫螋螬ㄔ疱吾礤┄汜祆ы狃螫骇珏臾ě泔铙趄蹉麸蝮К赠疱深骘┅见身痫螋语礤К敏矧吾礤簖麒孱趄蹂狃痨п滗领煲邈矧淞扉狍弩Н报戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇礤蜱逶疱砒痫螋Ж蓬鲞轭狃痨狃痨狃痨呦岚ㄅ痫螋螬ㄔ疱吾礤┄汜祆尼翎硫蜥Шф蝻砥镬溽忪濮敏矧吾礤螬┅姬身痫螋物铄Ь麒孱趄蹂狃痨п滗领煲邈矧淞扉狍弩Н报蓬鲞孱孱孱ч铈弪澎屙螫骢ㄅ铞澎屙赠澎屙螬狃痨ч铈弪澎屙笄铵川蓬霈澎屙赠澎屙蟋汜祆物鲠蔑眇殪弪赠疱螫骇屙痿吁怏臾īч铈弪涕篝嗅臾骢ㄅ铞嗅趔赠戾趄邈х锱戾眢Н骢ㄟ贪咛爆咛铂咛畅汜箦咛艾咛爆咛铂咛除镦见努圯咦艾吁恺麒孱趄蹂б殓梏Ку铞Ы九篚猝骄吁恺
        <{E, [P|Rest], ETy, Sub}> when 'true' -> case apply 'inferPat'/3(E, P, ETy) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', PatRes}> when 'true' ->
        apply 'goElems'/4(call 'maps':'get'('env', PatRes), Rest, let <_Oa0> = call 'Nova.Compiler.Types':'applySubst'(call 'maps':'get'('sub', PatRes))
      in apply _Oa0(ETy), let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(call 'maps':'get'('sub', PatRes))
      in apply _Oa0(Sub))
      <{'Right', PatRes}> when 'true' ->
        apply 'goElems'/4(call 'maps':'get'('env', PatRes), Rest, let <_Oa0> = call 'Nova.Compiler.Types':'applySubst'(call 'maps':'get'('sub', PatRes))
      in apply _Oa0(ETy), let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(call 'maps':'get'('sub', PatRes))
      in apply _Oa0(Sub))
      end
      end
      in let <_DLet0> = let <_Oa0> = call 'Nova.Compiler.Types':'freshVar'(Env)
      in apply _Oa0(#{#<101>(8,1,'integer',['unsigned'|['big']]),#<108>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<109>(8,1,'integer',['unsigned'|['big']])}#)
      in case _DLet0 of
        <{'Tuple', ElemVar, Env1}> when 'true' -> let <ElemTy> = {'TyVar', ElemVar}
      in case let <_Oa0> = apply 'unifyEnv'/1(Env1)
      in apply apply _Oa0(Ty)(call 'Nova.Compiler.Types':'tArray'(ElemTy)) of
      <{'Left', Ue}> when 'true' ->
        {'Left', apply 'UnifyErr'/1(Ue)}
      <{'Right', S1}> when 'true' ->
        let <ElemTy_> = let <_Oa0> = call 'Nova.Compiler.Types':'applySubst'(S1)
      in apply _Oa0(ElemTy)
      in apply 'goElems'/4(Env1, Pats, ElemTy_, S1)
    end
      end

'inferPat'/3 =
  fun (_P0, _P1, _P2) ->
    case {_P0, _P1, _P2} of
      <{Env, {'PatVar', Name}, Ty}> when 'true' ->
        let <Scheme> = let <_Oa0> = call 'Nova.Compiler.Types':'mkScheme'([])
      in apply _Oa0(Ty)
      in let <Env_> = let <_Oa0> = call 'Nova.Compiler.Types':'extendEnv'(Env)
      in apply apply _Oa0(Name)(Scheme)
      in {'Right', у铞Ы九铞攥篚猝骄汜祆物鲠蔑眇殪弪赠疱螫骇屙痿吁怏臾ī
      <{Env, 'PatWildcard', _W0}> when 'true' ->
        {'Right', у铞Ы九铞篚猝骄汜祆物鲠蔑眇殪弪赠疱螫骇屙痿吁怏臾ī
      <{Env, {'PatLit', Lit}, Ty}> when 'true' ->
        let <LitTy> = apply 'inferLit'/1(Lit)
      in case let <_Oa0> = apply 'unifyEnv'/1(Env)
      in apply apply _Oa0(Ty)(LitTy) of
      <{'Left', Ue}> when 'true' ->
        {'Left', apply 'UnifyErr'/1(Ue)}
      <{'Right', S}> when 'true' ->
        {'Right', у铞Ы九铞篚猝骄育
    end
      <{Env, {'PatCon', ConName, Pats}, Ty}> when 'true' ->
        let <UnqualifiedName> = case call 'Data.String':'lastIndexOf'(call 'Data.String':'Pattern'(#{#<46>(8,1,'integer',['unsigned'|['big']])}#), ConName) of
      <{'Just', Idx}> when 'true' ->
        call 'Data.String':'drop'(call 'erlang':'+'(Idx, 1), ConName)
      <'Nothing'> when 'true' ->
        ConName
    end
      in let <MkError> = case call 'Data.String':'lastIndexOf'(call 'Data.String':'Pattern'(#{#<46>(8,1,'integer',['unsigned'|['big']])}#), ConName) of
      <{'Just', Idx}> when 'true' ->
        apply 'UndefinedQualifiedImport'/2(call 'Data.String':'take'(Idx, ConName), UnqualifiedName)
      <'Nothing'> when 'true' ->
        apply 'UnboundVariable'/1(ConName)
    end
      in letrec 'tryLookup'/1 = fun (Name) ->
      let <_Oa0> = call 'Nova.Compiler.Types':'lookupEnv'(Env)
      in apply _Oa0(Name)
      in case apply 'tryLookup'/1(ConName) of
      <{'Just', Scheme}> when 'true' ->
        let <R> = apply 'instantiate'/2(Env, Scheme)
      in apply 'inferConPats'/4(call 'maps':'get'('env', R), call 'maps':'get'('ty', R), Pats, Ty)
      <'Nothing'> when 'true' ->
        case apply 'tryLookup'/1(UnqualifiedName) of
      <{'Just', Scheme}> when 'true' ->
        let <R> = apply 'instantiate'/2(Env, Scheme)
      in apply 'inferConPats'/4(call 'maps':'get'('env', R), call 'maps':'get'('ty', R), Pats, Ty)
      <'Nothing'> when 'true' ->
        {'Left', MkError}
    end
    end
      <{Env, {'PatParens', P}, Ty}> when 'true' ->
        apply 'inferPat'/3(Env, P, Ty)
      <{Env, {'PatRecord', Fields}, Ty}> when 'true' ->
        apply 'inferRecordPat'/3(Env, Fields, Ty)
      <{Env, {'PatList', Pats}, Ty}> when 'true' ->
        apply 'inferListPat'/3(Env, Pats, Ty)
      <{Env, {'PatCons', Hd, Tl}, Ty}> when 'true' ->
        apply 'inferConsPat'/4(Env, Hd, Tl, Ty)
      <{Env, {'PatAs', Name, Pat}, Ty}> when 'true' ->
        case apply 'inferPat'/3(Env, Pat, Ty) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', PatRes}> when 'true' ->
        let <Scheme> = let <_Oa0> = call 'Nova.Compiler.Types':'mkScheme'([])
      in apply _Oa0(let <_Oa0> = call 'Nova.Compiler.Types':'applySubst'(call 'maps':'get'('sub', PatRes))
      in apply _Oa0(Ty))
      in let <Env_> = let <_Oa0> = call 'Nova.Compiler.Types':'extendEnv'(call 'maps':'get'('env', PatRes))
      in apply apply _Oa0(Name)(Scheme)
      in {'Right', у铞Ы九铞攥篚猝骄汜祆ы狃螫骇珏臾ě篚猝嗅粢弩
      <{'Right', PatRes}> when 'true' ->
        let <Scheme> = let <_Oa0> = call 'Nova.Compiler.Types':'mkScheme'([])
      in apply _Oa0(let <_Oa0> = call 'Nova.Compiler.Types':'applySubst'(call 'maps':'get'('sub', PatRes))
      in apply _Oa0(Ty))
      in let <Env_> = let <_Oa0> = call 'Nova.Compiler.Types':'extendEnv'(call 'maps':'get'('env', PatRes))
      in apply apply _Oa0(Name)(Scheme)
      in {'Right', у铞Ы九铞攥篚猝骄汜祆ы狃螫骇珏臾ě篚猝嗅粢弩
      end
      <{_W0, _W1, _W2}> when 'true' ->
        {'Left', apply 'NotImplemented'/1(#{#<112>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<102>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<109>(8,1,'integer',['unsigned'|['big']])}#)}
    end

'inferRecordPat'/3 =
  fun (Env, Fields, Ty) ->
    apply 'inferRecordPatGo'/5(Ty, Env, Fields, call 'Data.Map':'empty'(), call 'Nova.Compiler.Types':'emptySubst'())

'inferRecordUpdate'/3 =
  fun (Env, Rec, Updates) ->
    case apply 'infer'/2(Env, Rec) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', RecRes}> when 'true' ->
        case apply 'inferFields'/2(call 'maps':'get'('env', RecRes), call 'Data.List':'fromFoldable'(Updates)) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', UpdateRes}> when 'true' ->
        let <_DLet0> = let <_Oa0> = call 'Nova.Compiler.Types':'freshVar'(call 'maps':'get'('env', UpdateRes))
      in apply _Oa0(#{#<114>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<119>(8,1,'integer',['unsigned'|['big']])}#)
      in case _DLet0 of
        <{'Tuple', RowVar, Env2}> when 'true' -> let <UpdateFields> = call 'Data.Map':'fromFoldable'(call 'maps':'get'('tys', UpdateRes))
      in let <ExpectedRec> = {'TyRecord', ф殄熹螫骄震溽翦崎屐潴蝻鳔骄术篝К绎髦狎
      in case let <_Oa0> = apply 'unifyEnv'/1(Env2)
      in apply apply _Oa0(let <_Oa0> = call 'Nova.Compiler.Types':'applySubst'(call 'maps':'get'('sub', UpdateRes))
      in apply _Oa0(call 'maps':'get'('ty', RecRes)))(ExpectedRec) of
      <{'Left', Ue}> when 'true' ->
        {'Left', apply 'UnifyErr'/1(Ue)}
      <{'Right', S}> when 'true' ->
        let <Sub> = let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(S)
      in apply _Oa0(let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(call 'maps':'get'('sub', UpdateRes))
      in apply _Oa0(call 'maps':'get'('sub', RecRes)))
      in {'Right', 豉Ы眷弭歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇狃痨吁怏臾ㄓ踱轭狃痨呦岚ㄣ犰ы狃螫骇珏臾ě豉К义阋弩┅篚猝骄吁猬у铞Ы九铞昌
    end
      end
      <{'Right', UpdateRes}> when 'true' ->
        let <_DLet0> = let <_Oa0> = call 'Nova.Compiler.Types':'freshVar'(call 'maps':'get'('env', UpdateRes))
      in apply _Oa0(#{#<114>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<119>(8,1,'integer',['unsigned'|['big']])}#)
      in case _DLet0 of
        <{'Tuple', RowVar, Env2}> when 'true' -> let <UpdateFields> = call 'Data.Map':'fromFoldable'(call 'maps':'get'('tys', UpdateRes))
      in let <ExpectedRec> = {'TyRecord', ф殄熹螫骄震溽翦崎屐潴蝻鳔骄术篝К绎髦狎
      in case let <_Oa0> = apply 'unifyEnv'/1(Env2)
      in apply apply _Oa0(let <_Oa0> = call 'Nova.Compiler.Types':'applySubst'(call 'maps':'get'('sub', UpdateRes))
      in apply _Oa0(call 'maps':'get'('ty', RecRes)))(ExpectedRec) of
      <{'Left', Ue}> when 'true' ->
        {'Left', apply 'UnifyErr'/1(Ue)}
      <{'Right', S}> when 'true' ->
        let <Sub> = let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(S)
      in apply _Oa0(let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(call 'maps':'get'('sub', UpdateRes))
      in apply _Oa0(call 'maps':'get'('sub', RecRes)))
      in {'Right', 豉Ы眷弭歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇狃痨吁怏臾ㄓ踱轭狃痨呦岚ㄣ犰ы狃螫骇珏臾ě豉К义阋弩┅篚猝骄吁猬у铞Ы九铞昌
    end
      end
      end
      <{'Right', RecRes}> when 'true' ->
        case apply 'inferFields'/2(call 'maps':'get'('env', RecRes), call 'Data.List':'fromFoldable'(Updates)) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', UpdateRes}> when 'true' ->
        let <_DLet0> = let <_Oa0> = call 'Nova.Compiler.Types':'freshVar'(call 'maps':'get'('env', UpdateRes))
      in apply _Oa0(#{#<114>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<119>(8,1,'integer',['unsigned'|['big']])}#)
      in case _DLet0 of
        <{'Tuple', RowVar, Env2}> when 'true' -> let <UpdateFields> = call 'Data.Map':'fromFoldable'(call 'maps':'get'('tys', UpdateRes))
      in let <ExpectedRec> = {'TyRecord', ф殄熹螫骄震溽翦崎屐潴蝻鳔骄术篝К绎髦狎
      in case let <_Oa0> = apply 'unifyEnv'/1(Env2)
      in apply apply _Oa0(let <_Oa0> = call 'Nova.Compiler.Types':'applySubst'(call 'maps':'get'('sub', UpdateRes))
      in apply _Oa0(call 'maps':'get'('ty', RecRes)))(ExpectedRec) of
      <{'Left', Ue}> when 'true' ->
        {'Left', apply 'UnifyErr'/1(Ue)}
      <{'Right', S}> when 'true' ->
        let <Sub> = let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(S)
      in apply _Oa0(let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(call 'maps':'get'('sub', UpdateRes))
      in apply _Oa0(call 'maps':'get'('sub', RecRes)))
      in {'Right', 豉Ы眷弭歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇狃痨吁怏臾ㄓ踱轭狃痨呦岚ㄣ犰ы狃螫骇珏臾ě豉К义阋弩┅篚猝骄吁猬у铞Ы九铞昌
    end
      end
      <{'Right', UpdateRes}> when 'true' ->
        let <_DLet0> = let <_Oa0> = call 'Nova.Compiler.Types':'freshVar'(call 'maps':'get'('env', UpdateRes))
      in apply _Oa0(#{#<114>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<119>(8,1,'integer',['unsigned'|['big']])}#)
      in case _DLet0 of
        <{'Tuple', RowVar, Env2}> when 'true' -> let <UpdateFields> = call 'Data.Map':'fromFoldable'(call 'maps':'get'('tys', UpdateRes))
      in let <ExpectedRec> = {'TyRecord', ф殄熹螫骄震溽翦崎屐潴蝻鳔骄术篝К绎髦狎
      in case let <_Oa0> = apply 'unifyEnv'/1(Env2)
      in apply apply _Oa0(let <_Oa0> = call 'Nova.Compiler.Types':'applySubst'(call 'maps':'get'('sub', UpdateRes))
      in apply _Oa0(call 'maps':'get'('ty', RecRes)))(ExpectedRec) of
      <{'Left', Ue}> when 'true' ->
        {'Left', apply 'UnifyErr'/1(Ue)}
      <{'Right', S}> when 'true' ->
        let <Sub> = let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(S)
      in apply _Oa0(let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(call 'maps':'get'('sub', UpdateRes))
      in apply _Oa0(call 'maps':'get'('sub', RecRes)))
      in {'Right', 豉Ы眷弭歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇狃痨吁怏臾ㄓ踱轭狃痨呦岚ㄣ犰ы狃螫骇珏臾ě豉К义阋弩┅篚猝骄吁猬у铞Ы九铞昌
    end
      end
      end
      end

'inferUnaryOp'/3 =
  fun (Env, Op, E) ->
    case Op of
      <#{#<45>(8,1,'integer',['unsigned'|['big']])}#> when 'true' ->
        case apply 'infer'/2(Env, E) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Res}> when 'true' ->
        case let <_Oa0> = apply 'unifyEnv'/1(call 'maps':'get'('env', Res))
      in apply apply _Oa0(call 'maps':'get'('ty', Res))(call 'Nova.Compiler.Types':'tInt'()) of
      <{'Left', Ue}> when 'true' ->
        {'Left', apply 'UnifyErr'/1(Ue)}
      <{'Right', S}> when 'true' ->
        {'Right', 豉Ы俱犰物鲠蔑眇殪弪赠疱螫骇羯铘Ж┈篚猝骄戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇泔眇矬逵踱篝Ж萤轭狃痨呦岚ㄣ犰ы狃螫骇珏臾ě篚猝义螬┈у铞Ы俱犰ы狃螫骇珏臾ě孱雩义螬
    end
      <{'Right', Res}> when 'true' ->
        case let <_Oa0> = apply 'unifyEnv'/1(call 'maps':'get'('env', Res))
      in apply apply _Oa0(call 'maps':'get'('ty', Res))(call 'Nova.Compiler.Types':'tInt'()) of
      <{'Left', Ue}> when 'true' ->
        {'Left', apply 'UnifyErr'/1(Ue)}
      <{'Right', S}> when 'true' ->
        {'Right', 豉Ы俱犰物鲠蔑眇殪弪赠疱螫骇羯铘Ж┈篚猝骄戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇泔眇矬逵踱篝Ж萤轭狃痨呦岚ㄣ犰ы狃螫骇珏臾ě篚猝义螬┈у铞Ы俱犰ы狃螫骇珏臾ě孱雩义螬
    end
      end
      <#{#<33>(8,1,'integer',['unsigned'|['big']])}#> when 'true' ->
        case apply 'infer'/2(Env, E) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Res}> when 'true' ->
        case let <_Oa0> = apply 'unifyEnv'/1(call 'maps':'get'('env', Res))
      in apply apply _Oa0(call 'maps':'get'('ty', Res))(call 'Nova.Compiler.Types':'tBool'()) of
      <{'Left', Ue}> when 'true' ->
        {'Left', apply 'UnifyErr'/1(Ue)}
      <{'Right', S}> when 'true' ->
        {'Right', 豉Ы俱犰物鲠蔑眇殪弪赠疱螫骇袈镲歆ī篚猝骄戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇泔眇矬逵踱篝Ж萤轭狃痨呦岚ㄣ犰ы狃螫骇珏臾ě篚猝义螬┈у铞Ы俱犰ы狃螫骇珏臾ě孱雩义螬
    end
      <{'Right', Res}> when 'true' ->
        case let <_Oa0> = apply 'unifyEnv'/1(call 'maps':'get'('env', Res))
      in apply apply _Oa0(call 'maps':'get'('ty', Res))(call 'Nova.Compiler.Types':'tBool'()) of
      <{'Left', Ue}> when 'true' ->
        {'Left', apply 'UnifyErr'/1(Ue)}
      <{'Right', S}> when 'true' ->
        {'Right', 豉Ы俱犰物鲠蔑眇殪弪赠疱螫骇袈镲歆ī篚猝骄戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇泔眇矬逵踱篝Ж萤轭狃痨呦岚ㄣ犰ы狃螫骇珏臾ě篚猝义螬┈у铞Ы俱犰ы狃螫骇珏臾ě孱雩义螬
    end
      end
      <_W0> when 'true' ->
        case let <_Oa0> = call 'Nova.Compiler.Types':'lookupEnv'(Env)
      in apply _Oa0(Op) of
      <'Nothing'> when 'true' ->
        {'Left', apply 'UnboundVariable'/1(Op)}
      <{'Just', Scheme}> when 'true' ->
        let <OpInst> = apply 'instantiate'/2(Env, Scheme)
      in case apply 'infer'/2(call 'maps':'get'('env', OpInst), E) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Res}> when 'true' ->
        let <_DLet0> = let <_Oa0> = call 'Nova.Compiler.Types':'freshVar'(call 'maps':'get'('env', Res))
      in apply _Oa0(#{#<117>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<121>(8,1,'integer',['unsigned'|['big']])}#)
      in case _DLet0 of
        <{'Tuple', ResTv, Env2}> when 'true' -> case let <_Oa0> = apply 'unifyEnv'/1(Env2)
      in apply apply _Oa0(call 'maps':'get'('ty', OpInst))(let <_Oa0> = call 'Nova.Compiler.Types':'tArrow'(call 'maps':'get'('ty', Res))
      in apply _Oa0({'TyVar', ResTv})) of
      <{'Left', Ue}> when 'true' ->
        {'Left', apply 'UnifyErr'/1(Ue)}
      <{'Right', S}> when 'true' ->
        let <Sub> = let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(S)
      in apply _Oa0(call 'maps':'get'('sub', Res))
      in {'Right', 豉Ы眷弭歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇狃痨吁怏臾ㄓ轭狃痨呦岚г轴颛义笤鳊┈篚猝骄吁猬у铞Ы九铞昌
    end
      end
      <{'Right', Res}> when 'true' ->
        let <_DLet0> = let <_Oa0> = call 'Nova.Compiler.Types':'freshVar'(call 'maps':'get'('env', Res))
      in apply _Oa0(#{#<117>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<121>(8,1,'integer',['unsigned'|['big']])}#)
      in case _DLet0 of
        <{'Tuple', ResTv, Env2}> when 'true' -> case let <_Oa0> = apply 'unifyEnv'/1(Env2)
      in apply apply _Oa0(call 'maps':'get'('ty', OpInst))(let <_Oa0> = call 'Nova.Compiler.Types':'tArrow'(call 'maps':'get'('ty', Res))
      in apply _Oa0({'TyVar', ResTv})) of
      <{'Left', Ue}> when 'true' ->
        {'Left', apply 'UnifyErr'/1(Ue)}
      <{'Right', S}> when 'true' ->
        let <Sub> = let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(S)
      in apply _Oa0(call 'maps':'get'('sub', Res))
      in {'Right', 豉Ы眷弭歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇狃痨吁怏臾ㄓ轭狃痨呦岚г轴颛义笤鳊┈篚猝骄吁猬у铞Ы九铞昌
    end
      end
      end
    end
    end

'processImportDecl'/3 =
  fun (Registry, Env, Imp) ->
    case let <_Oa0> = call 'Nova.Compiler.Types':'lookupModule'(Registry)
      in apply _Oa0(call 'maps':'get'('moduleName', Imp)) of
      <'Nothing'> when 'true' ->
        Env
      <{'Just', Exports}> when 'true' ->
        let <EnvWithQualified> = case call 'maps':'get'('alias', Imp) of
      <{'Just', Alias}> when 'true' ->
        call 'Nova.Compiler.Types':'mergeExportsToEnvWithPrefix'(Env, Exports, Alias)
      <'Nothing'> when 'true' ->
        let <LastPart> = case call 'Data.String':'lastIndexOf'(call 'Data.String':'Pattern'(#{#<46>(8,1,'integer',['unsigned'|['big']])}#), call 'maps':'get'('moduleName', Imp)) of
      <'Nothing'> when 'true' ->
        call 'maps':'get'('moduleName', Imp)
      <{'Just', Idx}> when 'true' ->
        call 'Data.String':'drop'(call 'erlang':'+'(Idx, 1), call 'maps':'get'('moduleName', Imp))
    end
      in call 'Nova.Compiler.Types':'mergeExportsToEnvWithPrefix'(Env, Exports, LastPart)
    end
      in case call 'maps':'get'('hiding', Imp) of
      <'true'> when 'true' -> apply 'mergeExportsWithTypeAliases'/2(EnvWithQualified, Exports)
      <'false'> when 'true' -> case call 'Data.List':'null'(call 'maps':'get'('items', Imp)) of
      <'true'> when 'true' -> case call 'maps':'get'('alias', Imp) of
      <{'Just', _W0}> when 'true' ->
        let <ModuleAliases> = case call 'Data.Map':'isEmpty'(call 'maps':'get'('expandedTypeAliases', Exports)) of
      <'true'> when 'true' -> apply 'expandModuleAliases'/1(call 'maps':'get'('typeAliases', Exports))
      <'false'> when 'true' -> call 'maps':'get'('expandedTypeAliases', Exports)
    end
      in letrec 'addIfRecordAlias'/2 = fun (_L0, _L1) ->
      case {_L0, _L1} of
        <{E, {'Tuple', Name, Ty}}> when 'true' -> case apply 'isRecordType'/1(Ty) of
      <'true'> when 'true' -> let <_Oa0> = call 'Nova.Compiler.Types':'extendTypeAlias'(E)
      in apply apply _Oa0(Name)(Ty)
      <'false'> when 'true' -> E
    end
      end
      in call 'Data.Array':'foldl'(fun (_Mf0, _Mf1) -> apply 'addIfRecordAlias'/2(_Mf0, _Mf1), EnvWithQualified, call 'Data.Map':'toUnfoldable'(ModuleAliases))
      <'Nothing'> when 'true' ->
        apply 'mergeExportsWithTypeAliases'/2(EnvWithQualified, Exports)
    end
      <'false'> when 'true' -> call 'Data.Foldable':'foldl'(fun (_Pc0, _Pc1) -> apply 'importItem'/3(Exports, _Pc0, _Pc1), EnvWithQualified, call 'maps':'get'('items', Imp))
    end
    end
    end

'processImports'/3 =
  fun (Registry, Env, Decls) ->
    letrec 'processImport'/2 = fun (_L0, _L1) ->
      case {_L0, _L1} of
        <{E, {'DeclImport', Imp}}> when 'true' -> apply 'processImportDecl'/3(Registry, E, Imp)
        <{E, _W0}> when 'true' -> E
      end
      in call 'Data.Array':'foldl'(fun (_Mf0, _Mf1) -> apply 'processImport'/2(_Mf0, _Mf1), Env, Decls)

'processNonFunctionsWithAliases'/3 =
  fun (ImportedAliases, Env, Decls) ->
    let <LocalParamAliasMap> = apply 'collectParamTypeAliases'/1(Decls)
      in let <ImportedSimpleAliases> = call 'Data.Map':'mapMaybe'(fun (Info) ->
      case call 'Data.Array':'null'(call 'Nova.Compiler.Types':'getAliasInfoParams'(Info)) of
      <'true'> when 'true' -> {'Just', apply 'typeExprToType'/2(call 'Data.Map':'empty'(), call 'Nova.Compiler.Types':'getAliasInfoBody'(Info))}
      <'false'> when 'true' -> 'Nothing'
    end, ImportedAliases)
      in let <ParamAliasMap> = call 'Data.Map':'union'(LocalParamAliasMap, ImportedAliases)
      in let <EnvWithImportedAliases> = call 'maps':'merge'(Env, 豉疱领獒箦螫骄汜祆尼翎歪皈骇躅轱瞌ㄉ眇矧翦溆轫痨辶扉狍弩汜祆ы狃螫骇珏臾ě豉疱领獒箦螫蓬雯轭戾继镢犰领獒笸狃狃痨с镬戾泗赠疱领獒箦笞轸杪狍濮敞身痫螋邃娱眇戾领獒箦蟋嗅蜥砹扉狍歪瓞腻沆螬轭戾剂扉狍歪鹁田汜炝扉狍歪轭戾趄邈ю蝻沐篌尼翎赠疱Н骢ㄅ腻沆汜箦腻沆镦见腻沆尼翎赠疱К聂麒孱趄蹂狃痨с桢汶尼翎赠疱组翳领炝扉狍弩Н川领獒笸狃嗅蜥砹扉狍歪瓞努聂见腻沆五黥疱К昔麒孱趄蹂狃痨с桢汶五黥疱组翳领炝扉狍弩Н川领獒笸狃嗅蜥砹扉狍歪瓞努昔歼装麒孱趄蹂孱ю蝻沐篌赠疱领獒螫骢ㄅ腻沆汜箦腻沆镦见腻沆赠疱领獒螫葬麒孱趄蹂狃痨с桢汶赠疱领獒螫波努葬歼装麒孱趄蹂孱ю蝻沐篌赠疱渺狍螫骢ㄅ腻沆汜箦腻沆镦见腻沆赠疱渺狍螫糟麒孱趄蹂狃痨с桢汶赠疱渺狍螫波努糟歼装麒孱趄蹂孱轭戾寂铞本汜祆尼翎硫蜥Шф镬潇Ж骢ㄟ玩艾咄姹狃痨ю蝻沐篌赠疱领獒螫波咄姘咄姹┈蓬鲎轸枭眇矧翦淞扉狍弩腻沆螬轭戾寂铞簿汜祆尼翎硫蜥Шф镬潇Ж骢ㄟ玩艾咄姹狃痨ю蝻沐篌尼翎赠疱Н波咄姘咄姹┈蓬霰腻沆螬轭戾寂铞尘汜祆尼翎硫蜥Шф镬潇Ж骢ㄟ玩艾咄姹狃痨ю蝻沐篌赠疱渺狍螫波咄姘咄姹┈蓬霾腻沆螬轭蓬龀豉疱描邈胪镤蹯濮骢ㄒ彗轶趄蓬霈惋洎戾寄邈祗汜祆尼翎硫蜥Шф蝻砥镬溽忪濮ㄣ犰ы狃螫骇珏臾ě溴沆狎狒轱铙К惋洎轭汜箦狃痨с桢汶惋漉戾Н敞义玳篝蝙蓬霈腻沆螬镦见体骠К膨螨麒孱趄蹂体骠К膨螨见б殓梏К蓬鲞麒孱趄蹂б殓梏К戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇黼赠疱渫镤蹯濮ㄍ镤轭狃痨呦岚ㄅ铞擤孱豉疱砒痱燥赠疱组翳领獒箦螫骢领獒笸狃轴蛲狃砒痱狃痨豉疱砒痱燥赠疱组翳领炝扉狍弩Н川领獒笸狃汜祆尼翎歪皈骇屙痿Ж┈轴蛲狃砒痱р蹰熹蔑铙趄蹉麸蛟疱组翳领獒箦螫骢领獒笸狃轴蛲狃崎屐潴义篚祠赠疱狃痨р蹰熹蔑铙趄蹉麸蛟疱组翳领獒箦笄铵川领獒笸狃轴蛲狃义篚祠赠疱崎屐潴р蹰熹蔑铙趄蹉麸蛟疱组翳领獒箦笄铵骢ㄟ邪咝爆咝铂咝畅汜箦咝艾咝爆咝铂咝除镦见咦艾咦爆义篚祠赠疱圯麒孱趄蹂义篚祠赠疱见领獒笸狃轴蛲狃义篚祠赠疱燮殄熹义篝蔟麒孱趄蹂戾计殄熹赠狃痨豉疱砒痱燥赠疱组翳领獒箦螫敞领獒笸狃轴蛲狃汜祆ы狃螫骇珏臾ě豉К崎屐洎轭戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇袅蝌秣Ж崎屐湓轭狃痨呦岚ㄡ痧禊р蹰熹蔑铙趄蹉麸蛟疱组翳领獒箦笄铵川领獒笸狃轴蛲狃义篚祠赠疱义篝┅孱с桢汶尼翎赠疱组翳领炝扉狍弩Н骢领獒笸狃嗅蜥砹扉狍歪瓞蓬霈聂戾荚疱轴蛐衢蝮汜祆尼翎硫蜥Шы狃组翳深溴Ж骢ㄉ蜘汜祆尼翎怎痨濮骇怎痨濮ㄖ戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇黼灾狎Ж汜祆у蜢犷绉骇Ж汜祆у蜢犷绉骇Ж涩暴┅轭狃痨呦岚ㄖ┅汜祆尼翎硫蜥Шф蝻砥镬溽忪濮ㄣ犰ы狃螫骇珏臾ě豉疱轴蝮К聂┅轭戾荚疱轴蛲狃汜祆尼翎歪皈骇骝镯骑熹徕戾Ж赠疱轴蛐衢蝮轭戾荚疱硫珞汜祆ъ轶趔Шы狃Ж骢ㄟ贪汜箦咛褒镦见г躔戾К咦艾增麒孱趄蹂г轴颛增孱洮赠疱轴蛐衢蝮轭戾家弩蹯粼疱г蔑瞌戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇黼悦镱Ж汜祆ы狃螫骇珏臾ě钺礤К聂┅轭狃痨呦岚ㄔ疱硫珞轭戾趄邈п滗蔑铙趄蹉麸颛骢ㄅ蔑瞟戾济镱赠疱狃痨р蹰熹蔑铙趄蹉麸蛟疱组翳领炝扉狍弩Н胆领獒笸狃嗅蜥砹扉狍歪瓞赠疱轴蛲狃汜祆ы狃螫骇珏臾ě骈屐潴К蔑瞟义篚祠赠疱轭戾济镱鱼桢礤戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇黼鱼桢礤Ж汜祆ъ轶趔Шы狃Ж汜祆尼翎怎痨濮骇箢洄ī赠疱轴蛐衢蝮┅轭狃痨呦岚蔑钤疱轭戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇屮翦钿蓬雩ㄅ轭狃痨狃痨呦岚ㄣ犰ы狃螫骇珏臾ě钺礤К蔑瞟┄蔑钣汨屙濠轭汜祆尼翎硫蜥Шф镬潇Ж骢ㄟ玩艾咄姹狃痨п滗蔑铙趄蹉麸颛波咄姘咄姹┈蓬霈汜祆尼翎硫蜥Шф蝻砥镬溽忪濮ㄣ犰ы狃螫骇珏臾ě泔铙趄蹉麸蝮К聂┅с桢汶五黥疱组翳领炝扉狍弩Н骢领獒笸狃嗅蜥砹扉狍歪瓞蓬霈昔戾荚疱轴蛐衢蝮汜祆尼翎硫蜥Шы狃组翳深溴Ж骢ㄉ蜘汜祆尼翎怎痨濮骇怎痨濮ㄖ戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇黼灾狎Ж汜祆у蜢犷绉骇Ж汜祆у蜢犷绉骇Ж涩暴┅轭狃痨呦岚ㄖ┅汜祆尼翎硫蜥Шф蝻砥镬溽忪濮ㄣ犰ы狃螫骇珏臾ě豉疱轴蝮К昔┅轭戾荚疱轴蛲狃汜祆尼翎歪皈骇骝镯骑熹徕戾Ж赠疱轴蛐衢蝮轭戾荚疱硫珞汜祆ъ轶趔Шы狃Ж骢ㄟ贪汜箦咛褒镦见г躔戾К咦艾增麒孱趄蹂г轴颛增孱洮赠疱轴蛐衢蝮轭戾家弩蹯粼疱г蔑瞌戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇黼悦镱Ж汜祆ы狃螫骇珏臾ě钺礤К昔┅轭狃痨呦岚ㄔ疱硫珞轭戾甲蜥痧邃赠狃痨豉疱砒痱燥赠疱组翳领炝扉狍弩Н川领獒笸狃嗅蜥砹扉狍歪瓞赠疱轴蛲狃汜祆ы狃螫骇珏臾ě黩狃疱湓疱К昔┅轭戾济镱赠疱戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇袅蝌秣Ж昨狃疱湓轭狃痨呦岚ㄒ弩蹯粼疱轭戾济镱鱼桢礤戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇黼鱼桢礤Ж汜祆ъ轶趔Шы狃Ж汜祆尼翎怎痨濮骇箢洄ī赠疱轴蛐衢蝮┅轭狃痨呦岚蔑钤疱轭戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇屮翦钿蓬雩ㄅ铞轭狃痨狃痨呦岚ㄣ犰ы狃螫骇珏臾ě泔铙趄蹉麸颛昔┅蔑钣汨屙濠ч铈弪蔑钚狒螫骢ㄅ铞蔑钤嗅趔义篚祠赠狃痨ч铈弪蔑钚狒笄铵胆义篚祠赠蓬霈蔑钤嗅趔汜祆物鲠蔑眇殪弪赠疱螫骇屙痿吁怏臾īч铈弪蔑铙嗅臾骢ㄅ铞蠕嗅衄造嗅衄赠戾歼奶弭熬戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇骝弩柚狎Ж蓬雯轭狃痨呦岚ǎ＜卑本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑妇ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑咕ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺）轭汜箦吣体舭镦见г躔戾К澎屙轴颥蓬霰麒孱趄蹂戾寂戾碓г轴颛澎屙轴螨轭汜箦戾歼厢熬狃痨躅殒蓬雩报蓬霰轭狃痨狃痨呦岚ㄔ┄汜祆物鲠蔑眇殪弪赠疱螫骇袅蝌狴Ж澎屙赠┅镦见体骠К斟麒孱趄蹂体骠К狃痨д铋纟膨颛报斟见б殓梏К颖麒孱趄蹂戾寂戾碓呔戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇狃痨吁怏臾ㄓ暴轭狃痨呦岚ㄅ戾碓轭戾继轶粼戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇狃痨吁怏臾ㄓ暴轭狃痨呦岚ㄣ犰物鲠蔑眇殪弪赠疱螫骇袅蝌狴Ж澎屙赠┅轭汜箦狃痨ч铈弪嗅臾敞蓬霰蠕嗅衄澎屙赠擤镦姬物翳轭绉麒孱趄蹂物翳轭绉见体骠К吲蝌麒孱趄蹂体骠К吲蝌见术篝К蠕义簖麒孱趄蹂汜箦狃痨ч铈弪嗅臾敞汜祆ы狃螫骇珏臾ě孱雩蠕义螬造嗅衄戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇狃痨吁怏臾ㄣ犰ы狃螫骇珏臾ě篚猝蠕义螬轭狃痨呦岚ㄌ轶粼┅镦姬物翳轭绉麒孱趄蹂物翳轭绉见体骠К吲蝌麒孱趄蹂体骠К吲蝌见术篝К造义簖麒孱趄蹂б殓梏Ку铞Ы俱犰ы狃螫骇珏臾ě孱雩造义螬篚猝骄戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇泔眇矬逵踱篝Ж汜祆ы狃螫骇珏臾ě篚猝造义螬轭狃痨呦岚戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇泔眇矬逵踱篝Ж汜祆ы狃螫骇珏臾ě篚猝蠕义螬轭狃痨呦岚ㄓ暴
      <{'Right', TlRes}> when 'true' ->
        {'Right', у铞Ы俱犰ы狃螫骇珏臾ě孱雩造义螬篚猝骄戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇泔眇矬逵踱篝Ж汜祆ы狃螫骇珏臾ě篚猝造义螬轭狃痨呦岚戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇泔眇矬逵踱篝Ж汜祆ы狃螫骇珏臾ě篚猝蠕义螬轭狃痨呦岚ㄓ暴
      end
      <{'Right', HdRes}> when 'true' ->
        case apply 'inferPat'/3(call 'maps':'get'('env', HdRes), TlPat, let <_Oa0> = call 'Nova.Compiler.Types':'applySubst'(call 'maps':'get'('sub', HdRes))
      in apply _Oa0(ListTy)) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', TlRes}> when 'true' ->
        {'Right', у铞Ы俱犰ы狃螫骇珏臾ě孱雩造义螬篚猝骄戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇泔眇矬逵踱篝Ж汜祆ы狃螫骇珏臾ě篚猝造义螬轭狃痨呦岚戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇泔眇矬逵踱篝Ж汜祆ы狃螫骇珏臾ě篚猝蠕义螬轭狃痨呦岚ㄓ暴
      <{'Right', TlRes}> when 'true' ->
        {'Right', у铞Ы俱犰ы狃螫骇珏臾ě孱雩造义螬篚猝骄戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇泔眇矬逵踱篝Ж汜祆ы狃螫骇珏臾ě篚猝造义螬轭狃痨呦岚戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇泔眇矬逵踱篝Ж汜祆ы狃螫骇珏臾ě篚猝蠕义螬轭狃痨呦岚ㄓ暴
      end
      end
    end
      end

'inferElemsGo'/4 =
  fun (_P0, _P1, _P2, _P3) ->
    case {_P0, _P1, _P2, _P3} of
      <{E, _W0, [], Sub}> when 'true' ->
        {'Right', 篚猝骄吁猬у铞Ы九
      <{E, ETy, [Expr|Rest], Sub}> when 'true' ->
        case apply 'infer'/2(E, Expr) of
      <{'Left', Err}> when 'true' ->
        {'Left', Err}
      <{'Right', Res}> when 'true' ->
        case let <_Oa0> = apply 'unifyEnv'/1(call 'maps':'get'('env', Res))
      in apply apply _Oa0(let <_Oa0> = call 'Nova.Compiler.Types':'applySubst'(call 'maps':'get'('sub', Res))
      in apply _Oa0(ETy))(call 'maps':'get'('ty', Res)) of
      <{'Left', Ue}> when 'true' ->
        {'Left', apply 'UnifyErr'/1(Ue)}
      <{'Right', S2}> when 'true' ->
        apply 'inferElemsGo'/4(call 'maps':'get'('env', Res), let <_Oa0> = call 'Nova.Compiler.Types':'applySubst'(S2)
      in apply _Oa0(ETy), Rest, let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(S2)
      in apply _Oa0(let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(call 'maps':'get'('sub', Res))
      in apply _Oa0(Sub)))
    end
    end
    end

'inferFieldsGo'/4 =
  fun (_P0, _P1, _P2, _P3) ->
    case {_P0, _P1, _P2, _P3} of
      <{E, [], Acc, Sub}> when 'true' ->
        {'Right', 豉螫骄汜祆尼翎涕篝Ш蝈鲥蝮濮零悌篚猝骄吁猬у铞Ы九
      <{E, [{'Tuple', Name, Expr}|Rest], Acc, Sub}> when 'true' ->
        case apply 'infer'/2(E, Expr) of
      <{'Left', Err}> when 'true' ->
        {'Left', Err}
      <{'Right', Res}> when 'true' ->
        apply 'inferFieldsGo'/4(call 'maps':'get'('env', Res), Rest, [call 'Data.Tuple':'Tuple'(Name, call 'maps':'get'('ty', Res))|Acc], let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(call 'maps':'get'('sub', Res))
      in apply _Oa0(Sub))
    end
    end

'inferManyGo'/4 =
  fun (_P0, _P1, _P2, _P3) ->
    case {_P0, _P1, _P2, _P3} of
      <{E, [], Acc, Sub}> when 'true' ->
        {'Right', 豉螫骄汜祆尼翎硫蜥Шф蝻砥镬溽忪濮ㄣ犰尼翎涕篝Ш蝈鲥蝮濮零悌┈篚猝骄吁猬у铞Ы九
      <{E, [Expr|Rest], Acc, Sub}> when 'true' ->
        case apply 'infer'/2(E, Expr) of
      <{'Left', Err}> when 'true' ->
        {'Left', Err}
      <{'Right', Res}> when 'true' ->
        apply 'inferManyGo'/4(call 'maps':'get'('env', Res), Rest, [call 'maps':'get'('ty', Res)|Acc], let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(call 'maps':'get'('sub', Res))
      in apply _Oa0(Sub))
    end
    end

'instantiateGo'/4 =
  fun (_P0, _P1, _P2, _P3) ->
    case {_P0, _P1, _P2, _P3} of
      <{SchemeTy, E, [], Sub}> when 'true' ->
        apply 'mkInstResult'/2(let <_Oa0> = call 'Nova.Compiler.Types':'applySubst'(Sub)
      in apply _Oa0(SchemeTy), E)
      <{SchemeTy, E, [V|Rest], Sub}> when 'true' ->
        let <_Let0> = V
      in case _Let0 of
        <ч洄航稚洮ь犴濮航治犴妪麒孱趄蹂戾歼体舯戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇骝弩柚狎Ж农轭狃痨呦岚ㄖ吾礤轭汜箦咛弭镦见г躔戾К乞弩璎胚麒孱趄蹂戾加踱呔汜祆尼翎歪皈骇轭箦螋Ж稚洮г轴颛乞弩椠吁猢轭狃痨ч铙翎铘獒翦秋Н川鱼桢礤赠胚义篝吁膺孱孱孱篚怏糸趱翦赠疱砒痱Н骢ㄟ邪咝爆咝铂咝畅汜箦咝艾咝爆咝铂咝除镦见领獒笸狃嗅蜥砹扉狍歪瓞嗅蜥碛踱篝г砒痱轴颛吾礤麒孱趄蹂汜箦汜祆尼翎歪皈骇祜镫躔Ж吾礤嗅蜥碛踱篝镦见术篝К赠麒孱趄蹂赠姬物翳轭绉麒孱趄蹂г蔑瞌戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇黼悦镱Ж吾礤轭狃痨呦岚ㄛ荸孱见领獒笸狃嗅蜥砹扉狍歪瓞嗅蜥碛踱篝г砒痱蔑瞌吾礤麒孱趄蹂汜箦汜祆尼翎歪皈骇祜镫躔Ж吾礤领獒笸狃镦见术篝К赠麒孱趄蹂赠姬物翳轭绉麒孱趄蹂狃痨豉疱砒痱燥赠疱Н波汜祆尼翎歪皈骇屙痿Ж┈г砒痱蔑瞌吾礤孱见领獒笸狃嗅蜥砹扉狍歪瓞嗅蜥碛踱篝г砒痱琉皈片硫琮麒孱趄蹂汜箦狃痨с镬戾泗赠疱琉皈报г砒痱琉皈片硫琮镦见г躔戾К蔑钗犴瀣硫珞麒孱趄蹂汜箦汜祆尼翎歪皈骇祜镫躔Ж蔑钗犴瀣嗅蜥砹扉狍歪皓镦见术篝К深骘麒孱趄蹂汜箦汜祆у蜢犷绉骇胶涧ㄣ犰尼翎硫蜥Шъ孱玺瑙ㄣ犰物鲠蔑眇殪弪赠疱螫骇珏袅扉狍深骘嗅蜥眢Ж深骘┅汜祆尼翎硫蜥Шъ孱玺瑙硫珞┅镦姬趄蹂Ь麒孱趄蹂戾剂蜱赠疱缶汜祆ъ轶趔Шы狃Ж骢ㄟ秀癌狃痨篚怏糸趱翦赠疱砒痱Н川领獒笸狃嗅蜥砹扉狍歪瓞嗅蜥碛踱篝咝惆┈硫珞轭戾嘉弩翦溆踱篝汜祆尼翎歪皈骇骝镯骑熹徕戾Ж汜祆尼翎硫蜥Ш轲Ж汜祆物鲠蔑眇殪弪赠疱螫骇珏袅扉狍深骘嗅蜥眢Ж深骘┈硫缭疱螬轭狃痨篚怏糸趱翦赠疱砒痱Н川领獒笸狃嗅蜥砹扉狍歪瓞五篝邃吁怏衄汜祆物鲠蔑眇殪弪赠疱螫骇珏袅扉狍深骘嘛澌Ж深骘┅歼麒孱趄蹂汜箦狃痨篚怏糸趱翦赠疱砒痱Н川领獒笸狃嗅蜥砹扉狍歪瓞嗅蜥碛踱篝譬镦见г蔑瞌糟麒孱趄蹂г蔑瞌ь犴濮骄汜祆ы狃螫骇珏臾ě钺礤К糟┈п蜱螫骄汜祆尼翎硫蜥Ш箢镢Ж汜祆ы狃螫骇珏臾ě狎珞К糟┈狃痨篚怏糸趱翦赠疱砒痱Н川领獒笸狃嗅蜥砹扉狍歪瓞嗅蜥碛踱篝硫绌
      <Other> when 'true' ->
        Other
    end
        end
      <_W0> when 'true' ->
        case apply 'substituteTypeExpr'/4(AliasMap, ParamAliasMap, ParamSubst, F) of
      <{'TyCon', Tc}> when 'true' ->
        {'TyCon', ь犴濮骄汜祆ы狃螫骇珏臾ě钺礤К糟┈п蜱螫骄汜祆尼翎硫蜥Ш箢镢Ж汜祆ы狃螫骇珏臾ě狎珞К糟┈狃痨篚怏糸趱翦赠疱砒痱Н川领獒笸狃嗅蜥砹扉狍歪瓞嗅蜥碛踱篝硫绌
      <Other> when 'true' ->
        Other
    end
    end
    end
      <{AliasMap, ParamAliasMap, ParamSubst, {'TyExprArrow', A, B}}> when 'true' ->
        let <_Oa0> = call 'Nova.Compiler.Types':'tArrow'(apply 'substituteTypeExpr'/4(AliasMap, ParamAliasMap, ParamSubst, A))
      in apply _Oa0(apply 'substituteTypeExpr'/4(AliasMap, ParamAliasMap, ParamSubst, B))
      <{AliasMap, ParamAliasMap, ParamSubst, {'TyExprRecord', Fields, MaybeRow}}> when 'true' ->
        let <FieldMap> = call 'Data.Map':'fromFoldable'(call 'lists':'map'(fun (_L0) ->
      case {_L0} of
        <{{'Tuple', L, T}}> when 'true' -> call 'Data.Tuple':'Tuple'(L, apply 'substituteTypeExpr'/4(AliasMap, ParamAliasMap, ParamSubst, T))
      end, Fields))
      in {'TyRecord', ф殄熹螫骄崎屐渫狃蝻鳔骄物翳轭绉
      <{AliasMap, ParamAliasMap, ParamSubst, {'TyExprTuple', Ts}}> when 'true' ->
        call 'Nova.Compiler.Types':'tTuple'(call 'Data.Array':'fromFoldable'(call 'lists':'map'(fun (_Pc0) -> apply 'substituteTypeExpr'/4(AliasMap, ParamAliasMap, ParamSubst, _Pc0), Ts)))
      <{AliasMap, ParamAliasMap, ParamSubst, {'TyExprParens', T}}> when 'true' ->
        apply 'substituteTypeExpr'/4(AliasMap, ParamAliasMap, ParamSubst, T)
      <{AliasMap, ParamAliasMap, ParamSubst, {'TyExprForAll', _W0, T}}> when 'true' ->
        apply 'substituteTypeExpr'/4(AliasMap, ParamAliasMap, ParamSubst, T)
      <{AliasMap, ParamAliasMap, ParamSubst, {'TyExprConstrained', _W0, T}}> when 'true' ->
        apply 'substituteTypeExpr'/4(AliasMap, ParamAliasMap, ParamSubst, T)
    end

'typeExprToTypeWithAllAliases'/4 =
  fun (_P0, _P1, _P2, _P3) ->
    case {_P0, _P1, _P2, _P3} of
      <{AliasMap, ParamAliasMap, VarMap, {'TyExprVar', Name}}> when 'true' ->
        case call 'Data.Map':'lookup'(Name, VarMap) of
      <{'Just', Tv}> when 'true' ->
        {'TyVar', Tv}
      <'Nothing'> when 'true' ->
        {'TyCon', let <_Oa0> = call 'Nova.Compiler.Types':'mkTCon'(Name)
      in apply _Oa0([])}
    end
      <{AliasMap, ParamAliasMap, VarMap, {'TyExprCon', Name}}> when 'true' ->
        let <UnqualifiedName> = case call 'Data.String':'lastIndexOf'(call 'Data.String':'Pattern'(#{#<46>(8,1,'integer',['unsigned'|['big']])}#), Name) of
      <{'Just', Idx}> when 'true' ->
        call 'Data.String':'drop'(call 'erlang':'+'(Idx, 1), Name)
      <'Nothing'> when 'true' ->
        Name
    end
      in letrec 'lookupInAliasMap'/1 = fun (Nm) ->
      call 'Data.Map':'lookup'(Nm, AliasMap)
       'lookupInParamAliasMap'/1 = fun (Nm) ->
      call 'Data.Map':'lookup'(Nm, ParamAliasMap)
       'tryLookup'/1 = fun (Nm) ->
      case apply 'lookupInAliasMap'/1(Nm) of
      <{'Just', Ty}> when 'true' ->
        {'Just', Ty}
      <'Nothing'> when 'true' ->
        case apply 'lookupInParamAliasMap'/1(Nm) of
      <{'Just', Info}> when 'true' ->
        let <Ps> = call 'Nova.Compiler.Types':'getAliasInfoParams'(Info)
      in let <BodyExpr> = call 'Nova.Compiler.Types':'getAliasInfoBody'(Info)
      in case call 'Data.Array':'null'(Ps) of
      <'true'> when 'true' -> {'Just', apply 'typeExprToTypeWithAllAliases'/4(AliasMap, ParamAliasMap, VarMap, BodyExpr)}
      <'false'> when 'true' -> 'Nothing'
    end
      <'Nothing'> when 'true' ->
        'Nothing'
    end
    end
      in case apply 'tryLookup'/1(Name) of
      <{'Just', Ty}> when 'true' ->
        Ty
      <'Nothing'> when 'true' ->
        case apply 'tryLookup'/1(UnqualifiedName) of
      <{'Just', Ty}> when 'true' ->
        Ty
      <'Nothing'> when 'true' ->
        apply 'typeExprToType'/2(VarMap, {'TyExprCon', Name})
    end
    end
      <{AliasMap, ParamAliasMap, VarMap, {'TyExprApp', F, Arg}}> when 'true' ->
        letrec 'applyTypeArg'/5 = fun (AMap, PaMap, VMap, Func, ArgExpr) ->
      let <ArgTy> = apply 'typeExprToTypeWithAllAliases'/4(AMap, PaMap, VMap, ArgExpr)
      in case apply 'typeExprToTypeWithAllAliases'/4(AMap, PaMap, VMap, Func) of
      <{'TyCon', Tc}> when 'true' ->
        {'TyCon', ь犴濮骄汜祆ы狃螫骇珏臾ě钺礤К糟┈п蜱螫骄汜祆尼翎硫蜥Ш箢镢Ж汜祆ы狃螫骇珏臾ě狎珞К糟┈硫缭
      <Other> when 'true' ->
        call 'Nova.Compiler.Types':'mkTyApp'(Other, ArgTy)
    end
      in case apply 'collectTypeApp'/1({'TyExprApp', F, Arg}) of
      <{'Tuple', ConName, Args}> when 'true' ->
        case call 'Data.Map':'lookup'(ConName, ParamAliasMap) of
      <{'Just', Info}> when 'true' ->
        let <Ps> = call 'Nova.Compiler.Types':'getAliasInfoParams'(Info)
      in let <BodyExpr> = call 'Nova.Compiler.Types':'getAliasInfoBody'(Info)
      in case call 'erlang':'=:='(call 'Data.Array':'length'(Ps), call 'Data.Array':'length'(Args)) of
      <'true'> when 'true' -> let <ArgTypes> = call 'lists':'map'(fun (_Pc0) -> apply 'typeExprToTypeWithAllAliases'/4(AliasMap, ParamAliasMap, VarMap, _Pc0), Args)
      in let <ParamSubst> = call 'Data.Map':'fromFoldable'(call 'Data.Array':'zip'(Ps, ArgTypes))
      in apply 'substituteTypeExpr'/4(AliasMap, ParamAliasMap, ParamSubst, BodyExpr)
      <'false'> when 'true' -> apply 'applyTypeArg'/5(AliasMap, ParamAliasMap, VarMap, F, Arg)
    end
      <_W0> when 'true' ->
        apply 'applyTypeArg'/5(AliasMap, ParamAliasMap, VarMap, F, Arg)
    end
    end
      <{AliasMap, ParamAliasMap, VarMap, {'TyExprArrow', A, B}}> when 'true' ->
        let <_Oa0> = call 'Nova.Compiler.Types':'tArrow'(apply 'typeExprToTypeWithAllAliases'/4(AliasMap, ParamAliasMap, VarMap, A))
      in apply _Oa0(apply 'typeExprToTypeWithAllAliases'/4(AliasMap, ParamAliasMap, VarMap, B))
      <{AliasMap, ParamAliasMap, VarMap, {'TyExprRecord', Fields, MaybeRow}}> when 'true' ->
        let <FieldMap> = call 'Data.Map':'fromFoldable'(call 'lists':'map'(fun (_L0) ->
      case {_L0} of
        <{{'Tuple', L, T}}> when 'true' -> call 'Data.Tuple':'Tuple'(L, apply 'typeExprToTypeWithAllAliases'/4(AliasMap, ParamAliasMap, VarMap, T))
      end, Fields))
      in let <Row> = case MaybeRow of
      <{'Just', R}> when 'true' ->
        case call 'Data.Map':'lookup'(R, VarMap) of
      <{'Just', Tv}> when 'true' ->
        {'Just', Tv}
      <'Nothing'> when 'true' ->
        'Nothing'
    end
      <'Nothing'> when 'true' ->
        'Nothing'
    end
      in {'TyRecord', ф殄熹螫骄崎屐渫狃蝻鳔骄绎鼾
      <{AliasMap, ParamAliasMap, VarMap, {'TyExprForAll', Vars, T}}> when 'true' ->
        let <VarList> = call 'Data.Array':'mapWithIndex'(fun (I, Name) ->
      call 'Data.Tuple':'Tuple'(Name, let <_Oa0> = call 'Nova.Compiler.Types':'mkTVar'(call 'erlang':'-'(call 'erlang':'+'(I, 1)))
      in apply _Oa0(Name)), call 'Data.Array':'fromFoldable'(Vars))
      in let <NewVarMap> = call 'Data.Map':'union'(call 'Data.Map':'fromFoldable'(VarList), VarMap)
      in apply 'typeExprToTypeWithAllAliases'/4(AliasMap, ParamAliasMap, NewVarMap, T)
      <{AliasMap, ParamAliasMap, VarMap, {'TyExprConstrained', _W0, T}}> when 'true' ->
        apply 'typeExprToTypeWithAllAliases'/4(AliasMap, ParamAliasMap, VarMap, T)
      <{AliasMap, ParamAliasMap, VarMap, {'TyExprParens', T}}> when 'true' ->
        apply 'typeExprToTypeWithAllAliases'/4(AliasMap, ParamAliasMap, VarMap, T)
      <{AliasMap, ParamAliasMap, VarMap, {'TyExprTuple', Ts}}> when 'true' ->
        call 'Nova.Compiler.Types':'tTuple'(call 'Data.Array':'fromFoldable'(call 'lists':'map'(fun (_Pc0) -> apply 'typeExprToTypeWithAllAliases'/4(AliasMap, ParamAliasMap, VarMap, _Pc0), Ts)))
    end

'buildConstructorTypeWithAllAliases'/5 =
  fun (AliasMap, ParamAliasMap, VarMap, Fields, ResultType) ->
    apply 'buildConstructorTypeWithAllAliasesGo'/5(AliasMap, ParamAliasMap, VarMap, ResultType, Fields)

'buildConstructorTypeWithAllAliasesGo'/5 =
  fun (_P0, _P1, _P2, _P3, _P4) ->
    case {_P0, _P1, _P2, _P3, _P4} of
      <{_W0, _W1, _W2, ResultType, []}> when 'true' ->
        ResultType
      <{AliasMap, ParamAliasMap, VarMap, ResultType, [Field|Rest]}> when 'true' ->
        let <FieldTy> = apply 'typeExprToTypeWithAllAliases'/4(AliasMap, ParamAliasMap, VarMap, call 'maps':'get'('ty', Field))
      in let <_Oa0> = call 'Nova.Compiler.Types':'tArrow'(FieldTy)
      in apply _Oa0(apply 'buildConstructorTypeWithAllAliasesGo'/5(AliasMap, ParamAliasMap, VarMap, ResultType, Rest))
    end

'inferClauses'/5 =
  fun (Env, ScrutTy, ResultTy, Clauses, InitSub) ->
    apply 'inferClausesGo'/5(ScrutTy, ResultTy, Env, Clauses, InitSub)

'inferClausesGo'/5 =
  fun (_P0, _P1, _P2, _P3, _P4) ->
    case {_P0, _P1, _P2, _P3, _P4} of
      <{_W0, _W1, E, [], Sub}> when 'true' ->
        {'Right', у铞Ы九篚猝骄吁恺
      <{STy, RTy, E, [Clause|Rest], Sub}> when 'true' ->
        let <STy_> = let <_Oa0> = call 'Nova.Compiler.Types':'applySubst'(Sub)
      in apply _Oa0(STy)
      in let <RTy_> = let <_Oa0> = call 'Nova.Compiler.Types':'applySubst'(Sub)
      in apply _Oa0(RTy)
      in case apply 'inferPat'/3(E, call 'maps':'get'('pattern', Clause), STy_) of
      <{'Left', Err}> when 'true' ->
        {'Left', Err}
      <{'Right', PatRes}> when 'true' ->
        let <PatEnv> = let <_Oa0> = call 'Nova.Compiler.Types':'applySubstToEnv'(call 'maps':'get'('sub', PatRes))
      in apply _Oa0(call 'maps':'get'('env', PatRes))
      in case apply 'inferGuard'/2(PatEnv, call 'maps':'get'('guard', Clause)) of
      <{'Left', Err}> when 'true' ->
        {'Left', Err}
      <{'Right', GuardRes}> when 'true' ->
        case apply 'infer'/2(call 'maps':'get'('env', GuardRes), call 'maps':'get'('body', Clause)) of
      <{'Left', Err}> when 'true' ->
        {'Left', Err}
      <{'Right', BodyRes}> when 'true' ->
        case let <_Oa0> = apply 'unifyEnv'/1(call 'maps':'get'('env', BodyRes))
      in apply apply _Oa0(let <_Oa0> = call 'Nova.Compiler.Types':'applySubst'(call 'maps':'get'('sub', BodyRes))
      in apply _Oa0(RTy_))(call 'maps':'get'('ty', BodyRes)) of
      <{'Left', Ue}> when 'true' ->
        {'Left', apply 'UnifyErr'/1(Ue)}
      <{'Right', S}> when 'true' ->
        let <NewSub> = let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(S)
      in apply _Oa0(let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(call 'maps':'get'('sub', BodyRes))
      in apply _Oa0(let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(call 'maps':'get'('sub', GuardRes))
      in apply _Oa0(let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(call 'maps':'get'('sub', PatRes))
      in apply _Oa0(Sub))))
      in let <E_> = call 'maps':'merge'(E, с秕铘弪Ы俱犰ы狃螫骇珏臾ě泔躅翦颛汜祆ы狃螫骇珏臾ě孱雩嘛澌义螬轭狃痨ч铈弪渺狨箦笄铵胆釉以胚义篝五饔踱孱孱孱孱孱ч铈弪蔑钚狒笄铵骢ㄟ邪咝爆咝铂咝超咝穿汜箦咝艾咝爆咝铂咝超咝待镦见义篚祠赠努赠圯吁恺麒孱趄蹂汜箦戾歼厢熬狃痨躅殒蓬雩报农轭狃痨狃痨呦岚ㄔ┄义篚祠赠镦见体骠К斟麒孱趄蹂体骠К狃痨д铋纟膨颛报斟见б殓梏К育麒孱趄蹂б殓梏Ку铞Ы九篚猝骄戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇泔眇矬逵踱篝Ж萤轭狃痨呦岚ㄓ踱
    end
      <{ResultTy, E, Ty, [P|Rest], Sub}> when 'true' ->
        case Ty of
      <{'TyCon', C}> when 'true' ->
        case case call 'erlang':'=:='(call 'maps':'get'('name', C), #{#<70>(8,1,'integer',['unsigned'|['big']]),#<117>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']])}#) of <'true'> when 'true' -> call 'erlang':'=:='(call 'Data.Array':'length'(call 'maps':'get'('args', C)), 2) <_> when 'true' -> 'false' end of
      <'true'> when 'true' -> case пЫ俱犰尼翎硫蜥Шц遽洄ㄣ犰ы狃螫骇珏臾ě狎珞К茅┈рЫ俱犰尼翎硫蜥Шъ狍臾ㄣ犰ы狃螫骇珏臾ě狎珞К茅镦件пШ禁术篝К硫缭рШ禁术篝К义笤麒孱趄蹂汜箦狃痨ч铈弪嗅臾敞努鞋硫缭镦见体骠К膨螨麒孱趄蹂体骠К膨螨见б殓梏К嗅粢弩麒孱趄蹂狃痨ч铈弪蔑钚狒笄铵胆义篚祠赠汜祆ы狃螫骇珏臾ě孱雩嗅粢弩┈义笤义篝戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇泔眇矬逵踱篝Ж汜祆ы狃螫骇珏臾ě篚猝嗅粢弩┅轭狃痨呦岚ㄓ踱┅孱歼装麒孱趄蹂体骠К狃痨物羯眇戾礤铘邃Н报｛＜卑咕ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜狗鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑妇ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑簿ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北淳ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑咕ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑熬ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜巢鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑簿ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北肪ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北熬ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜构鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北毒ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑稻ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北熬ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜巢鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北毒ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜辈本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北簿ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺）孱姬驷祗濮麒孱趄蹂体骠К狃痨物羯眇戾礤铘邃Н报｛＜卑本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜辈熬ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北簿ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜构鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北毒ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑熬ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜巢鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑簿ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北肪ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北熬ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜构鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北毒ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑稻ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北熬ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜巢鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北毒ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜辈本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北簿ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜巢鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑稻ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北熬ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜巢鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜构鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北熬ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北稻ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北毒ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北淳ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北肪ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜构鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北毒ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北淳ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺）孱歼装麒孱趄蹂体骠К狃痨物羯眇戾礤铘邃Н报｛＜卑本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜辈熬ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北簿ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜构鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北毒ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑熬ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜巢鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑簿ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北肪ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北熬ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜构鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北毒ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑稻ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北熬ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜巢鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北毒ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜辈本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北簿ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜巢鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑稻ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北熬ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜巢鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜构鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北熬ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北稻ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北毒ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北淳ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北肪ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜构鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北毒ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北淳ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺）孱孱ч铈弪义泔蜾嗅羟铵骢ㄟ邪咝爆咝铂咝超咝穿汜箦咝艾咝爆咝铂咝超咝待镦见赠努圯崎屐湓疱蟋吁恺麒孱趄蹂戾歼奶弭熬戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇骝弩柚狎Ж农轭狃痨呦岚ǎ＜北淳ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北咕ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺）轭汜箦吣体舭镦见г躔戾К绎髦狎胚麒孱趄蹂戾寂疱泗邃义憔г义泔蜾Кф殄熹螫骄崎屐湓疱蟋蝻鳔骄术篝К绎髦狎
      in case let <_Oa0> = apply 'unifyEnv'/1(E_)
      in apply apply _Oa0(let <_Oa0> = call 'Nova.Compiler.Types':'applySubst'(Sub)
      in apply _Oa0(Ty))(ExpectedRec) of
      <{'Left', Ue}> when 'true' ->
        {'Left', apply 'UnifyErr'/1(Ue)}
      <{'Right', S}> when 'true' ->
        {'Right', у铞Ы九攥篚猝骄戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇泔眇矬逵踱篝Ж萤轭狃痨呦岚ㄓ踱
    end
      end
      <{Ty, E, [{'Tuple', Label, Pat}|Rest], FieldTypes, Sub}> when 'true' ->
        let <_DLet0> = let <_Oa0> = call 'Nova.Compiler.Types':'freshVar'(E)
      in apply _Oa0(call 'Nova.Prelude':'semigroupAppendImpl'(#{#<102>(8,1,'integer',['unsigned'|['big']]),#<95>(8,1,'integer',['unsigned'|['big']])}#, Label))
      in case _DLet0 of
        <{'Tuple', FieldVar, E1}> when 'true' -> let <FieldTy> = {'TyVar', FieldVar}
      in case apply 'inferPat'/3(E1, Pat, FieldTy) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', PatRes}> when 'true' ->
        apply 'inferRecordPatGo'/5(Ty, call 'maps':'get'('env', PatRes), Rest, call 'Data.Map':'insert'(Label, let <_Oa0> = call 'Nova.Compiler.Types':'applySubst'(call 'maps':'get'('sub', PatRes))
      in apply _Oa0(FieldTy), FieldTypes), let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(call 'maps':'get'('sub', PatRes))
      in apply _Oa0(Sub))
      <{'Right', PatRes}> when 'true' ->
        apply 'inferRecordPatGo'/5(Ty, call 'maps':'get'('env', PatRes), Rest, call 'Data.Map':'insert'(Label, let <_Oa0> = call 'Nova.Compiler.Types':'applySubst'(call 'maps':'get'('sub', PatRes))
      in apply _Oa0(FieldTy), FieldTypes), let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(call 'maps':'get'('sub', PatRes))
      in apply _Oa0(Sub))
      end
      end
    end

'typeExprToTypeWithEnv'/5 =
  fun (_P0, _P1, _P2, _P3, _P4) ->
    case {_P0, _P1, _P2, _P3, _P4} of
      <{Env, AliasMap, ParamAliasMap, VarMap, {'TyExprVar', Name}}> when 'true' ->
        case call 'Data.Map':'lookup'(Name, VarMap) of
      <{'Just', Tv}> when 'true' ->
        {'TyVar', Tv}
      <'Nothing'> when 'true' ->
        {'TyCon', let <_Oa0> = call 'Nova.Compiler.Types':'mkTCon'(Name)
      in apply _Oa0([])}
    end
      <{Env, AliasMap, ParamAliasMap, VarMap, {'TyExprCon', Name}}> when 'true' ->
        let <UnqualifiedName> = case call 'Data.String':'lastIndexOf'(call 'Data.String':'Pattern'(#{#<46>(8,1,'integer',['unsigned'|['big']])}#), Name) of
      <{'Just', Idx}> when 'true' ->
        call 'Data.String':'drop'(call 'erlang':'+'(Idx, 1), Name)
      <'Nothing'> when 'true' ->
        Name
    end
      in letrec 'tryEnvLookup'/1 = fun (Nm) ->
      let <_Oa0> = call 'Nova.Compiler.Types':'lookupTypeAlias'(Env)
      in apply _Oa0(Nm)
       'tryLookup'/1 = fun (Nm) ->
      case call 'Data.Map':'lookup'(Nm, AliasMap) of
      <{'Just', Ty}> when 'true' ->
        {'Just', Ty}
      <'Nothing'> when 'true' ->
        case call 'Data.Map':'lookup'(Nm, ParamAliasMap) of
      <{'Just', Info}> when 'true' ->
        let <Ps> = call 'Nova.Compiler.Types':'getAliasInfoParams'(Info)
      in let <BodyExpr> = call 'Nova.Compiler.Types':'getAliasInfoBody'(Info)
      in case call 'Data.Array':'null'(Ps) of
      <'true'> when 'true' -> {'Just', apply 'typeExprToTypeWithEnv'/5(Env, AliasMap, ParamAliasMap, VarMap, BodyExpr)}
      <'false'> when 'true' -> 'Nothing'
    end
      <_W0> when 'true' ->
        'Nothing'
    end
    end
      in case apply 'tryLookup'/1(Name) of
      <{'Just', Ty}> when 'true' ->
        Ty
      <'Nothing'> when 'true' ->
        case apply 'tryLookup'/1(UnqualifiedName) of
      <{'Just', Ty}> when 'true' ->
        Ty
      <'Nothing'> when 'true' ->
        case apply 'tryEnvLookup'/1(Name) of
      <{'Just', Ty}> when 'true' ->
        Ty
      <'Nothing'> when 'true' ->
        case apply 'tryEnvLookup'/1(UnqualifiedName) of
      <{'Just', Ty}> when 'true' ->
        Ty
      <'Nothing'> when 'true' ->
        apply 'typeExprToType'/2(VarMap, {'TyExprCon', Name})
    end
    end
    end
    end
      <{Env, AliasMap, ParamAliasMap, VarMap, {'TyExprApp', F, Arg}}> when 'true' ->
        case apply 'collectTypeApp'/1({'TyExprApp', F, Arg}) of
      <{'Tuple', ConName, Args}> when 'true' ->
        case call 'Data.Map':'lookup'(ConName, ParamAliasMap) of
      <{'Just', Info}> when 'true' ->
        case call 'erlang':'=:='(call 'Data.Array':'length'(call 'Nova.Compiler.Types':'getAliasInfoParams'(Info)), call 'Data.Array':'length'(Args)) of
          <'true'> when 'true' -> let <ArgTypes> = call 'lists':'map'(fun (_Pc0) -> apply 'typeExprToTypeWithEnv'/5(Env, AliasMap, ParamAliasMap, VarMap, _Pc0), Args)
      in let <ParamSubst> = call 'Data.Map':'fromFoldable'(call 'Data.Array':'zip'(call 'Nova.Compiler.Types':'getAliasInfoParams'(Info), ArgTypes))
      in apply 'substituteTypeExpr'/4(AliasMap, ParamAliasMap, ParamSubst, call 'Nova.Compiler.Types':'getAliasInfoBody'(Info))
          <_> when 'true' -> case apply 'typeExprToTypeWithEnv'/5(Env, AliasMap, ParamAliasMap, VarMap, F) of
      <{'TyCon', Tc}> when 'true' ->
        {'TyCon', ь犴濮骄汜祆ы狃螫骇珏臾ě钺礤К糟┈п蜱螫骄汜祆尼翎硫蜥Ш箢镢Ж汜祆ы狃螫骇珏臾ě狎珞К糟┈狃痨豉疱砒痱燥赠疱组翳蓬雩胆蓬霈领獒笸狃嗅蜥砹扉狍歪瓞轴蛲狃硫绌
      <Other> when 'true' ->
        Other
    end
        end
      <_W0> when 'true' ->
        case apply 'typeExprToTypeWithEnv'/5(Env, AliasMap, ParamAliasMap, VarMap, F) of
      <{'TyCon', Tc}> when 'true' ->
        {'TyCon', ь犴濮骄汜祆ы狃螫骇珏臾ě钺礤К糟┈п蜱螫骄汜祆尼翎硫蜥Ш箢镢Ж汜祆ы狃螫骇珏臾ě狎珞К糟┈狃痨豉疱砒痱燥赠疱组翳蓬雩胆蓬霈领獒笸狃嗅蜥砹扉狍歪瓞轴蛲狃硫绌
      <Other> when 'true' ->
        Other
    end
    end
    end
      <{Env, AliasMap, ParamAliasMap, VarMap, {'TyExprArrow', A, B}}> when 'true' ->
        let <_Oa0> = call 'Nova.Compiler.Types':'tArrow'(apply 'typeExprToTypeWithEnv'/5(Env, AliasMap, ParamAliasMap, VarMap, A))
      in apply _Oa0(apply 'typeExprToTypeWithEnv'/5(Env, AliasMap, ParamAliasMap, VarMap, B))
      <{Env, AliasMap, ParamAliasMap, VarMap, {'TyExprRecord', Fields, MaybeRow}}> when 'true' ->
        let <FieldMap> = call 'Data.Map':'fromFoldable'(call 'lists':'map'(fun (_L0) ->
      case {_L0} of
        <{{'Tuple', L, T}}> when 'true' -> call 'Data.Tuple':'Tuple'(L, apply 'typeExprToTypeWithEnv'/5(Env, AliasMap, ParamAliasMap, VarMap, T))
      end, Fields))
      in let <Row> = case MaybeRow of
      <{'Just', R}> when 'true' ->
        case call 'Data.Map':'lookup'(R, VarMap) of
      <{'Just', Tv}> when 'true' ->
        {'Just', Tv}
      <'Nothing'> when 'true' ->
        'Nothing'
    end
      <'Nothing'> when 'true' ->
        'Nothing'
    end
      in {'TyRecord', ф殄熹螫骄崎屐渫狃蝻鳔骄绎鼾
      <{Env, AliasMap, ParamAliasMap, VarMap, {'TyExprForAll', Vars, T}}> when 'true' ->
        let <VarList> = call 'Data.Array':'mapWithIndex'(fun (I, Name) ->
      call 'Data.Tuple':'Tuple'(Name, let <_Oa0> = call 'Nova.Compiler.Types':'mkTVar'(call 'erlang':'-'(call 'erlang':'+'(I, 1)))
      in apply _Oa0(Name)), call 'Data.Array':'fromFoldable'(Vars))
      in let <NewVarMap> = call 'Data.Map':'union'(call 'Data.Map':'fromFoldable'(VarList), VarMap)
      in apply 'typeExprToTypeWithEnv'/5(Env, AliasMap, ParamAliasMap, NewVarMap, T)
      <{Env, AliasMap, ParamAliasMap, VarMap, {'TyExprConstrained', _W0, T}}> when 'true' ->
        apply 'typeExprToTypeWithEnv'/5(Env, AliasMap, ParamAliasMap, VarMap, T)
      <{Env, AliasMap, ParamAliasMap, VarMap, {'TyExprParens', T}}> when 'true' ->
        apply 'typeExprToTypeWithEnv'/5(Env, AliasMap, ParamAliasMap, VarMap, T)
      <{Env, AliasMap, ParamAliasMap, VarMap, {'TyExprTuple', Ts}}> when 'true' ->
        call 'Nova.Compiler.Types':'tTuple'(call 'Data.Array':'fromFoldable'(call 'lists':'map'(fun (_Pc0) -> apply 'typeExprToTypeWithEnv'/5(Env, AliasMap, ParamAliasMap, VarMap, _Pc0), Ts)))
    end

'collectParamTypeAliases'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'collectParamTypeAliases'/1(_A0)
      in _F0

'collectTypeAliases'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'collectTypeAliases'/1(_A0)
      in _F0

'collectTypeApp'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'collectTypeApp'/1(_A0)
      in _F0

'collectTypeExprNames'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'collectTypeExprNames'/1(_A0)
      in _F0

'collectTypeNames'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'collectTypeNames'/1(_A0)
      in _F0

'expandModuleAliases'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'expandModuleAliases'/1(_A0)
      in _F0

'exprToPattern'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'exprToPattern'/1(_A0)
      in _F0

'extractExports'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'extractExports'/1(_A0)
      in _F0

'getExportedNames'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'getExportedNames'/1(_A0)
      in _F0

'getImportItemName'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'getImportItemName'/1(_A0)
      in _F0

'guardClauseToCondExpr'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'guardClauseToCondExpr'/1(_A0)
      in _F0

'guardedExprsToIf'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'guardedExprsToIf'/1(_A0)
      in _F0

'guardsToCondition'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'guardsToCondition'/1(_A0)
      in _F0

'inferLit'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'inferLit'/1(_A0)
      in _F0

'isRecordType'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'isRecordType'/1(_A0)
      in _F0

'mergeMultiClauseFunctions'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'mergeMultiClauseFunctions'/1(_A0)
      in _F0

'showExprShort'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'showExprShort'/1(_A0)
      in _F0

'unifyEnv'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'unifyEnv'/1(_A0)
      in _F0

'addErrorContext'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'addErrorContext'/2(_A0, _A1)
      in _F1
      in _F0

'addErrorContext'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'addErrorContext'/2(_A0, _A1)
      in _F0

'addFunctionPlaceholders'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'addFunctionPlaceholders'/2(_A0, _A1)
      in _F1
      in _F0

'addFunctionPlaceholders'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'addFunctionPlaceholders'/2(_A0, _A1)
      in _F0

'buildPatternGuardCases'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'buildPatternGuardCases'/2(_A0, _A1)
      in _F1
      in _F0

'buildPatternGuardCases'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'buildPatternGuardCases'/2(_A0, _A1)
      in _F0

'checkDataType'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'checkDataType'/2(_A0, _A1)
      in _F1
      in _F0

'checkDataType'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'checkDataType'/2(_A0, _A1)
      in _F0

'checkDecl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'checkDecl'/2(_A0, _A1)
      in _F1
      in _F0

'checkDecl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'checkDecl'/2(_A0, _A1)
      in _F0

'checkFunction'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'checkFunction'/2(_A0, _A1)
      in _F1
      in _F0

'checkFunction'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'checkFunction'/2(_A0, _A1)
      in _F0

'checkFunctionBodies'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'checkFunctionBodies'/2(_A0, _A1)
      in _F1
      in _F0

'checkFunctionBodies'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'checkFunctionBodies'/2(_A0, _A1)
      in _F0

'checkFunctionBodiesGo'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'checkFunctionBodiesGo'/2(_A0, _A1)
      in _F1
      in _F0

'checkFunctionBodiesGo'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'checkFunctionBodiesGo'/2(_A0, _A1)
      in _F0

'checkModuleSimple'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'checkModuleSimple'/2(_A0, _A1)
      in _F1
      in _F0

'checkModuleSimple'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'checkModuleSimple'/2(_A0, _A1)
      in _F0

'checkTypeAlias'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'checkTypeAlias'/2(_A0, _A1)
      in _F1
      in _F0

'checkTypeAlias'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'checkTypeAlias'/2(_A0, _A1)
      in _F0

'checkTypeClass'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'checkTypeClass'/2(_A0, _A1)
      in _F1
      in _F0

'checkTypeClass'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'checkTypeClass'/2(_A0, _A1)
      in _F0

'collectImportedAliases'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'collectImportedAliases'/2(_A0, _A1)
      in _F1
      in _F0

'collectImportedAliases'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'collectImportedAliases'/2(_A0, _A1)
      in _F0

'collectResolvedImports'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'collectResolvedImports'/2(_A0, _A1)
      in _F1
      in _F0

'collectResolvedImports'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'collectResolvedImports'/2(_A0, _A1)
      in _F0

'extractExportsWithRegistry'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'extractExportsWithRegistry'/2(_A0, _A1)
      in _F1
      in _F0

'extractExportsWithRegistry'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'extractExportsWithRegistry'/2(_A0, _A1)
      in _F0

'generalize'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'generalize'/2(_A0, _A1)
      in _F1
      in _F0

'generalize'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'generalize'/2(_A0, _A1)
      in _F0

'infer'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'infer'/2(_A0, _A1)
      in _F1
      in _F0

'infer'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'infer'/2(_A0, _A1)
      in _F0

'inferBinds'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'inferBinds'/2(_A0, _A1)
      in _F1
      in _F0

'inferBinds'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'inferBinds'/2(_A0, _A1)
      in _F0

'inferDo'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'inferDo'/2(_A0, _A1)
      in _F1
      in _F0

'inferDo'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'inferDo'/2(_A0, _A1)
      in _F0

'inferFields'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'inferFields'/2(_A0, _A1)
      in _F1
      in _F0

'inferFields'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'inferFields'/2(_A0, _A1)
      in _F0

'inferGuard'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'inferGuard'/2(_A0, _A1)
      in _F1
      in _F0

'inferGuard'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'inferGuard'/2(_A0, _A1)
      in _F0

'inferGuardExpr'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'inferGuardExpr'/2(_A0, _A1)
      in _F1
      in _F0

'inferGuardExpr'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'inferGuardExpr'/2(_A0, _A1)
      in _F0

'inferMany'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'inferMany'/2(_A0, _A1)
      in _F1
      in _F0

'inferMany'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'inferMany'/2(_A0, _A1)
      in _F0

'instantiate'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'instantiate'/2(_A0, _A1)
      in _F1
      in _F0

'instantiate'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'instantiate'/2(_A0, _A1)
      in _F0

'listMapWithIndex'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'listMapWithIndex'/2(_A0, _A1)
      in _F1
      in _F0

'listMapWithIndex'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'listMapWithIndex'/2(_A0, _A1)
      in _F0

'mergeExportsWithTypeAliases'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'mergeExportsWithTypeAliases'/2(_A0, _A1)
      in _F1
      in _F0

'mergeExportsWithTypeAliases'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'mergeExportsWithTypeAliases'/2(_A0, _A1)
      in _F0

'mkInstResult'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'mkInstResult'/2(_A0, _A1)
      in _F1
      in _F0

'mkInstResult'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'mkInstResult'/2(_A0, _A1)
      in _F0

'processInfixDeclarations'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'processInfixDeclarations'/2(_A0, _A1)
      in _F1
      in _F0

'processInfixDeclarations'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'processInfixDeclarations'/2(_A0, _A1)
      in _F0

'processNonFunctions'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'processNonFunctions'/2(_A0, _A1)
      in _F1
      in _F0

'processNonFunctions'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'processNonFunctions'/2(_A0, _A1)
      in _F0

'typeExprToType'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'typeExprToType'/2(_A0, _A1)
      in _F1
      in _F0

'typeExprToType'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'typeExprToType'/2(_A0, _A1)
      in _F0

'withContext'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'withContext'/2(_A0, _A1)
      in _F1
      in _F0

'withContext'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'withContext'/2(_A0, _A1)
      in _F0

'wrapWithPatternGuards'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'wrapWithPatternGuards'/2(_A0, _A1)
      in _F1
      in _F0

'wrapWithPatternGuards'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'wrapWithPatternGuards'/2(_A0, _A1)
      in _F0

'addFunctionPlaceholdersWithAliases'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'addFunctionPlaceholdersWithAliases'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'addFunctionPlaceholdersWithAliases'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'addFunctionPlaceholdersWithAliases'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'addFunctionPlaceholdersWithAliases'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'addFunctionPlaceholdersWithAliases'/3(_A0, _A1, _A2)
      in _F0

'addValuesToExports'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'addValuesToExports'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'addValuesToExports'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'addValuesToExports'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'addValuesToExports'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'addValuesToExports'/3(_A0, _A1, _A2)
      in _F0

'buildConstructorType'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'buildConstructorType'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'buildConstructorType'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'buildConstructorType'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'buildConstructorType'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'buildConstructorType'/3(_A0, _A1, _A2)
      in _F0

'buildConstructorTypeGo'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'buildConstructorTypeGo'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'buildConstructorTypeGo'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'buildConstructorTypeGo'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'buildConstructorTypeGo'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'buildConstructorTypeGo'/3(_A0, _A1, _A2)
      in _F0

'checkDataTypeWithAliases'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'checkDataTypeWithAliases'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'checkDataTypeWithAliases'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'checkDataTypeWithAliases'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'checkDataTypeWithAliases'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'checkDataTypeWithAliases'/3(_A0, _A1, _A2)
      in _F0

'checkModule'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'checkModule'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'checkModule'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'checkModule'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'checkModule'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'checkModule'/3(_A0, _A1, _A2)
      in _F0

'checkNewtypeWithAliases'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'checkNewtypeWithAliases'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'checkNewtypeWithAliases'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'checkNewtypeWithAliases'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'checkNewtypeWithAliases'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'checkNewtypeWithAliases'/3(_A0, _A1, _A2)
      in _F0

'collectFromImportDecl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'collectFromImportDecl'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'collectFromImportDecl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'collectFromImportDecl'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'collectFromImportDecl'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'collectFromImportDecl'/3(_A0, _A1, _A2)
      in _F0

'collectTypeAliasesWithBase'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'collectTypeAliasesWithBase'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'collectTypeAliasesWithBase'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'collectTypeAliasesWithBase'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'collectTypeAliasesWithBase'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'collectTypeAliasesWithBase'/3(_A0, _A1, _A2)
      in _F0

'importItem'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'importItem'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'importItem'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'importItem'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'importItem'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'importItem'/3(_A0, _A1, _A2)
      in _F0

'inferElems'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'inferElems'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'inferElems'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'inferElems'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'inferElems'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'inferElems'/3(_A0, _A1, _A2)
      in _F0

'inferListPat'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'inferListPat'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'inferListPat'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'inferListPat'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'inferListPat'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'inferListPat'/3(_A0, _A1, _A2)
      in _F0

'inferPat'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'inferPat'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'inferPat'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'inferPat'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'inferPat'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'inferPat'/3(_A0, _A1, _A2)
      in _F0

'inferRecordPat'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'inferRecordPat'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'inferRecordPat'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'inferRecordPat'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'inferRecordPat'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'inferRecordPat'/3(_A0, _A1, _A2)
      in _F0

'inferRecordUpdate'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'inferRecordUpdate'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'inferRecordUpdate'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'inferRecordUpdate'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'inferRecordUpdate'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'inferRecordUpdate'/3(_A0, _A1, _A2)
      in _F0

'inferUnaryOp'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'inferUnaryOp'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'inferUnaryOp'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'inferUnaryOp'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'inferUnaryOp'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'inferUnaryOp'/3(_A0, _A1, _A2)
      in _F0

'processImportDecl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'processImportDecl'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'processImportDecl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'processImportDecl'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'processImportDecl'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'processImportDecl'/3(_A0, _A1, _A2)
      in _F0

'processImports'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'processImports'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'processImports'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'processImports'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'processImports'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'processImports'/3(_A0, _A1, _A2)
      in _F0

'processNonFunctionsWithAliases'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'processNonFunctionsWithAliases'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'processNonFunctionsWithAliases'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'processNonFunctionsWithAliases'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'processNonFunctionsWithAliases'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'processNonFunctionsWithAliases'/3(_A0, _A1, _A2)
      in _F0

'typeCheckModule'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'typeCheckModule'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'typeCheckModule'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'typeCheckModule'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'typeCheckModule'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'typeCheckModule'/3(_A0, _A1, _A2)
      in _F0

'typeExprToTypeWithAliases'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'typeExprToTypeWithAliases'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'typeExprToTypeWithAliases'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'typeExprToTypeWithAliases'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'typeExprToTypeWithAliases'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'typeExprToTypeWithAliases'/3(_A0, _A1, _A2)
      in _F0

'buildConstructorTypeWithAliases'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        let <_F3> = fun (_A3) ->
        apply 'buildConstructorTypeWithAliases'/4(_A0, _A1, _A2, _A3)
      in _F3
      in _F2
      in _F1
      in _F0

'buildConstructorTypeWithAliases'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        let <_F2> = fun (_A3) ->
        apply 'buildConstructorTypeWithAliases'/4(_A0, _A1, _A2, _A3)
      in _F2
      in _F1
      in _F0

'buildConstructorTypeWithAliases'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        let <_F1> = fun (_A3) ->
        apply 'buildConstructorTypeWithAliases'/4(_A0, _A1, _A2, _A3)
      in _F1
      in _F0

'buildConstructorTypeWithAliases'/3 =
  fun (_A0, _A1, _A2) ->
    let <_F0> = fun (_A3) ->
        apply 'buildConstructorTypeWithAliases'/4(_A0, _A1, _A2, _A3)
      in _F0

'buildConstructorTypeWithAliasesGo'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        let <_F3> = fun (_A3) ->
        apply 'buildConstructorTypeWithAliasesGo'/4(_A0, _A1, _A2, _A3)
      in _F3
      in _F2
      in _F1
      in _F0

'buildConstructorTypeWithAliasesGo'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        let <_F2> = fun (_A3) ->
        apply 'buildConstructorTypeWithAliasesGo'/4(_A0, _A1, _A2, _A3)
      in _F2
      in _F1
      in _F0

'buildConstructorTypeWithAliasesGo'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        let <_F1> = fun (_A3) ->
        apply 'buildConstructorTypeWithAliasesGo'/4(_A0, _A1, _A2, _A3)
      in _F1
      in _F0

'buildConstructorTypeWithAliasesGo'/3 =
  fun (_A0, _A1, _A2) ->
    let <_F0> = fun (_A3) ->
        apply 'buildConstructorTypeWithAliasesGo'/4(_A0, _A1, _A2, _A3)
      in _F0

'checkDataTypeWithAllAliases'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        let <_F3> = fun (_A3) ->
        apply 'checkDataTypeWithAllAliases'/4(_A0, _A1, _A2, _A3)
      in _F3
      in _F2
      in _F1
      in _F0

'checkDataTypeWithAllAliases'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        let <_F2> = fun (_A3) ->
        apply 'checkDataTypeWithAllAliases'/4(_A0, _A1, _A2, _A3)
      in _F2
      in _F1
      in _F0

'checkDataTypeWithAllAliases'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        let <_F1> = fun (_A3) ->
        apply 'checkDataTypeWithAllAliases'/4(_A0, _A1, _A2, _A3)
      in _F1
      in _F0

'checkDataTypeWithAllAliases'/3 =
  fun (_A0, _A1, _A2) ->
    let <_F0> = fun (_A3) ->
        apply 'checkDataTypeWithAllAliases'/4(_A0, _A1, _A2, _A3)
      in _F0

'checkNewtypeWithAllAliases'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        let <_F3> = fun (_A3) ->
        apply 'checkNewtypeWithAllAliases'/4(_A0, _A1, _A2, _A3)
      in _F3
      in _F2
      in _F1
      in _F0

'checkNewtypeWithAllAliases'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        let <_F2> = fun (_A3) ->
        apply 'checkNewtypeWithAllAliases'/4(_A0, _A1, _A2, _A3)
      in _F2
      in _F1
      in _F0

'checkNewtypeWithAllAliases'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        let <_F1> = fun (_A3) ->
        apply 'checkNewtypeWithAllAliases'/4(_A0, _A1, _A2, _A3)
      in _F1
      in _F0

'checkNewtypeWithAllAliases'/3 =
  fun (_A0, _A1, _A2) ->
    let <_F0> = fun (_A3) ->
        apply 'checkNewtypeWithAllAliases'/4(_A0, _A1, _A2, _A3)
      in _F0

'inferConPats'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        let <_F3> = fun (_A3) ->
        apply 'inferConPats'/4(_A0, _A1, _A2, _A3)
      in _F3
      in _F2
      in _F1
      in _F0

'inferConPats'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        let <_F2> = fun (_A3) ->
        apply 'inferConPats'/4(_A0, _A1, _A2, _A3)
      in _F2
      in _F1
      in _F0

'inferConPats'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        let <_F1> = fun (_A3) ->
        apply 'inferConPats'/4(_A0, _A1, _A2, _A3)
      in _F1
      in _F0

'inferConPats'/3 =
  fun (_A0, _A1, _A2) ->
    let <_F0> = fun (_A3) ->
        apply 'inferConPats'/4(_A0, _A1, _A2, _A3)
      in _F0

'inferConsPat'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        let <_F3> = fun (_A3) ->
        apply 'inferConsPat'/4(_A0, _A1, _A2, _A3)
      in _F3
      in _F2
      in _F1
      in _F0

'inferConsPat'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        let <_F2> = fun (_A3) ->
        apply 'inferConsPat'/4(_A0, _A1, _A2, _A3)
      in _F2
      in _F1
      in _F0

'inferConsPat'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        let <_F1> = fun (_A3) ->
        apply 'inferConsPat'/4(_A0, _A1, _A2, _A3)
      in _F1
      in _F0

'inferConsPat'/3 =
  fun (_A0, _A1, _A2) ->
    let <_F0> = fun (_A3) ->
        apply 'inferConsPat'/4(_A0, _A1, _A2, _A3)
      in _F0

'inferElemsGo'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        let <_F3> = fun (_A3) ->
        apply 'inferElemsGo'/4(_A0, _A1, _A2, _A3)
      in _F3
      in _F2
      in _F1
      in _F0

'inferElemsGo'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        let <_F2> = fun (_A3) ->
        apply 'inferElemsGo'/4(_A0, _A1, _A2, _A3)
      in _F2
      in _F1
      in _F0

'inferElemsGo'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        let <_F1> = fun (_A3) ->
        apply 'inferElemsGo'/4(_A0, _A1, _A2, _A3)
      in _F1
      in _F0

'inferElemsGo'/3 =
  fun (_A0, _A1, _A2) ->
    let <_F0> = fun (_A3) ->
        apply 'inferElemsGo'/4(_A0, _A1, _A2, _A3)
      in _F0

'inferFieldsGo'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        let <_F3> = fun (_A3) ->
        apply 'inferFieldsGo'/4(_A0, _A1, _A2, _A3)
      in _F3
      in _F2
      in _F1
      in _F0

'inferFieldsGo'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        let <_F2> = fun (_A3) ->
        apply 'inferFieldsGo'/4(_A0, _A1, _A2, _A3)
      in _F2
      in _F1
      in _F0

'inferFieldsGo'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        let <_F1> = fun (_A3) ->
        apply 'inferFieldsGo'/4(_A0, _A1, _A2, _A3)
      in _F1
      in _F0

'inferFieldsGo'/3 =
  fun (_A0, _A1, _A2) ->
    let <_F0> = fun (_A3) ->
        apply 'inferFieldsGo'/4(_A0, _A1, _A2, _A3)
      in _F0

'inferManyGo'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        let <_F3> = fun (_A3) ->
        apply 'inferManyGo'/4(_A0, _A1, _A2, _A3)
      in _F3
      in _F2
      in _F1
      in _F0

'inferManyGo'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        let <_F2> = fun (_A3) ->
        apply 'inferManyGo'/4(_A0, _A1, _A2, _A3)
      in _F2
      in _F1
      in _F0

'inferManyGo'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        let <_F1> = fun (_A3) ->
        apply 'inferManyGo'/4(_A0, _A1, _A2, _A3)
      in _F1
      in _F0

'inferManyGo'/3 =
  fun (_A0, _A1, _A2) ->
    let <_F0> = fun (_A3) ->
        apply 'inferManyGo'/4(_A0, _A1, _A2, _A3)
      in _F0

'instantiateGo'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        let <_F3> = fun (_A3) ->
        apply 'instantiateGo'/4(_A0, _A1, _A2, _A3)
      in _F3
      in _F2
      in _F1
      in _F0

'instantiateGo'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        let <_F2> = fun (_A3) ->
        apply 'instantiateGo'/4(_A0, _A1, _A2, _A3)
      in _F2
      in _F1
      in _F0

'instantiateGo'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        let <_F1> = fun (_A3) ->
        apply 'instantiateGo'/4(_A0, _A1, _A2, _A3)
      in _F1
      in _F0

'instantiateGo'/3 =
  fun (_A0, _A1, _A2) ->
    let <_F0> = fun (_A3) ->
        apply 'instantiateGo'/4(_A0, _A1, _A2, _A3)
      in _F0

'substituteTypeExpr'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        let <_F3> = fun (_A3) ->
        apply 'substituteTypeExpr'/4(_A0, _A1, _A2, _A3)
      in _F3
      in _F2
      in _F1
      in _F0

'substituteTypeExpr'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        let <_F2> = fun (_A3) ->
        apply 'substituteTypeExpr'/4(_A0, _A1, _A2, _A3)
      in _F2
      in _F1
      in _F0

'substituteTypeExpr'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        let <_F1> = fun (_A3) ->
        apply 'substituteTypeExpr'/4(_A0, _A1, _A2, _A3)
      in _F1
      in _F0

'substituteTypeExpr'/3 =
  fun (_A0, _A1, _A2) ->
    let <_F0> = fun (_A3) ->
        apply 'substituteTypeExpr'/4(_A0, _A1, _A2, _A3)
      in _F0

'typeExprToTypeWithAllAliases'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        let <_F3> = fun (_A3) ->
        apply 'typeExprToTypeWithAllAliases'/4(_A0, _A1, _A2, _A3)
      in _F3
      in _F2
      in _F1
      in _F0

'typeExprToTypeWithAllAliases'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        let <_F2> = fun (_A3) ->
        apply 'typeExprToTypeWithAllAliases'/4(_A0, _A1, _A2, _A3)
      in _F2
      in _F1
      in _F0

'typeExprToTypeWithAllAliases'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        let <_F1> = fun (_A3) ->
        apply 'typeExprToTypeWithAllAliases'/4(_A0, _A1, _A2, _A3)
      in _F1
      in _F0

'typeExprToTypeWithAllAliases'/3 =
  fun (_A0, _A1, _A2) ->
    let <_F0> = fun (_A3) ->
        apply 'typeExprToTypeWithAllAliases'/4(_A0, _A1, _A2, _A3)
      in _F0

'buildConstructorTypeWithAllAliases'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        let <_F3> = fun (_A3) ->
        let <_F4> = fun (_A4) ->
        apply 'buildConstructorTypeWithAllAliases'/5(_A0, _A1, _A2, _A3, _A4)
      in _F4
      in _F3
      in _F2
      in _F1
      in _F0

'buildConstructorTypeWithAllAliases'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        let <_F2> = fun (_A3) ->
        let <_F3> = fun (_A4) ->
        apply 'buildConstructorTypeWithAllAliases'/5(_A0, _A1, _A2, _A3, _A4)
      in _F3
      in _F2
      in _F1
      in _F0

'buildConstructorTypeWithAllAliases'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        let <_F1> = fun (_A3) ->
        let <_F2> = fun (_A4) ->
        apply 'buildConstructorTypeWithAllAliases'/5(_A0, _A1, _A2, _A3, _A4)
      in _F2
      in _F1
      in _F0

'buildConstructorTypeWithAllAliases'/3 =
  fun (_A0, _A1, _A2) ->
    let <_F0> = fun (_A3) ->
        let <_F1> = fun (_A4) ->
        apply 'buildConstructorTypeWithAllAliases'/5(_A0, _A1, _A2, _A3, _A4)
      in _F1
      in _F0

'buildConstructorTypeWithAllAliases'/4 =
  fun (_A0, _A1, _A2, _A3) ->
    let <_F0> = fun (_A4) ->
        apply 'buildConstructorTypeWithAllAliases'/5(_A0, _A1, _A2, _A3, _A4)
      in _F0

'buildConstructorTypeWithAllAliasesGo'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        let <_F3> = fun (_A3) ->
        let <_F4> = fun (_A4) ->
        apply 'buildConstructorTypeWithAllAliasesGo'/5(_A0, _A1, _A2, _A3, _A4)
      in _F4
      in _F3
      in _F2
      in _F1
      in _F0

'buildConstructorTypeWithAllAliasesGo'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        let <_F2> = fun (_A3) ->
        let <_F3> = fun (_A4) ->
        apply 'buildConstructorTypeWithAllAliasesGo'/5(_A0, _A1, _A2, _A3, _A4)
      in _F3
      in _F2
      in _F1
      in _F0

'buildConstructorTypeWithAllAliasesGo'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        let <_F1> = fun (_A3) ->
        let <_F2> = fun (_A4) ->
        apply 'buildConstructorTypeWithAllAliasesGo'/5(_A0, _A1, _A2, _A3, _A4)
      in _F2
      in _F1
      in _F0

'buildConstructorTypeWithAllAliasesGo'/3 =
  fun (_A0, _A1, _A2) ->
    let <_F0> = fun (_A3) ->
        let <_F1> = fun (_A4) ->
        apply 'buildConstructorTypeWithAllAliasesGo'/5(_A0, _A1, _A2, _A3, _A4)
      in _F1
      in _F0

'buildConstructorTypeWithAllAliasesGo'/4 =
  fun (_A0, _A1, _A2, _A3) ->
    let <_F0> = fun (_A4) ->
        apply 'buildConstructorTypeWithAllAliasesGo'/5(_A0, _A1, _A2, _A3, _A4)
      in _F0

'inferClauses'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        let <_F3> = fun (_A3) ->
        let <_F4> = fun (_A4) ->
        apply 'inferClauses'/5(_A0, _A1, _A2, _A3, _A4)
      in _F4
      in _F3
      in _F2
      in _F1
      in _F0

'inferClauses'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        let <_F2> = fun (_A3) ->
        let <_F3> = fun (_A4) ->
        apply 'inferClauses'/5(_A0, _A1, _A2, _A3, _A4)
      in _F3
      in _F2
      in _F1
      in _F0

'inferClauses'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        let <_F1> = fun (_A3) ->
        let <_F2> = fun (_A4) ->
        apply 'inferClauses'/5(_A0, _A1, _A2, _A3, _A4)
      in _F2
      in _F1
      in _F0

'inferClauses'/3 =
  fun (_A0, _A1, _A2) ->
    let <_F0> = fun (_A3) ->
        let <_F1> = fun (_A4) ->
        apply 'inferClauses'/5(_A0, _A1, _A2, _A3, _A4)
      in _F1
      in _F0

'inferClauses'/4 =
  fun (_A0, _A1, _A2, _A3) ->
    let <_F0> = fun (_A4) ->
        apply 'inferClauses'/5(_A0, _A1, _A2, _A3, _A4)
      in _F0

'inferClausesGo'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        let <_F3> = fun (_A3) ->
        let <_F4> = fun (_A4) ->
        apply 'inferClausesGo'/5(_A0, _A1, _A2, _A3, _A4)
      in _F4
      in _F3
      in _F2
      in _F1
      in _F0

'inferClausesGo'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        let <_F2> = fun (_A3) ->
        let <_F3> = fun (_A4) ->
        apply 'inferClausesGo'/5(_A0, _A1, _A2, _A3, _A4)
      in _F3
      in _F2
      in _F1
      in _F0

'inferClausesGo'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        let <_F1> = fun (_A3) ->
        let <_F2> = fun (_A4) ->
        apply 'inferClausesGo'/5(_A0, _A1, _A2, _A3, _A4)
      in _F2
      in _F1
      in _F0

'inferClausesGo'/3 =
  fun (_A0, _A1, _A2) ->
    let <_F0> = fun (_A3) ->
        let <_F1> = fun (_A4) ->
        apply 'inferClausesGo'/5(_A0, _A1, _A2, _A3, _A4)
      in _F1
      in _F0

'inferClausesGo'/4 =
  fun (_A0, _A1, _A2, _A3) ->
    let <_F0> = fun (_A4) ->
        apply 'inferClausesGo'/5(_A0, _A1, _A2, _A3, _A4)
      in _F0

'inferConPatsGo'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        let <_F3> = fun (_A3) ->
        let <_F4> = fun (_A4) ->
        apply 'inferConPatsGo'/5(_A0, _A1, _A2, _A3, _A4)
      in _F4
      in _F3
      in _F2
      in _F1
      in _F0

'inferConPatsGo'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        let <_F2> = fun (_A3) ->
        let <_F3> = fun (_A4) ->
        apply 'inferConPatsGo'/5(_A0, _A1, _A2, _A3, _A4)
      in _F3
      in _F2
      in _F1
      in _F0

'inferConPatsGo'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        let <_F1> = fun (_A3) ->
        let <_F2> = fun (_A4) ->
        apply 'inferConPatsGo'/5(_A0, _A1, _A2, _A3, _A4)
      in _F2
      in _F1
      in _F0

'inferConPatsGo'/3 =
  fun (_A0, _A1, _A2) ->
    let <_F0> = fun (_A3) ->
        let <_F1> = fun (_A4) ->
        apply 'inferConPatsGo'/5(_A0, _A1, _A2, _A3, _A4)
      in _F1
      in _F0

'inferConPatsGo'/4 =
  fun (_A0, _A1, _A2, _A3) ->
    let <_F0> = fun (_A4) ->
        apply 'inferConPatsGo'/5(_A0, _A1, _A2, _A3, _A4)
      in _F0

'inferRecordPatGo'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        let <_F3> = fun (_A3) ->
        let <_F4> = fun (_A4) ->
        apply 'inferRecordPatGo'/5(_A0, _A1, _A2, _A3, _A4)
      in _F4
      in _F3
      in _F2
      in _F1
      in _F0

'inferRecordPatGo'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        let <_F2> = fun (_A3) ->
        let <_F3> = fun (_A4) ->
        apply 'inferRecordPatGo'/5(_A0, _A1, _A2, _A3, _A4)
      in _F3
      in _F2
      in _F1
      in _F0

'inferRecordPatGo'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        let <_F1> = fun (_A3) ->
        let <_F2> = fun (_A4) ->
        apply 'inferRecordPatGo'/5(_A0, _A1, _A2, _A3, _A4)
      in _F2
      in _F1
      in _F0

'inferRecordPatGo'/3 =
  fun (_A0, _A1, _A2) ->
    let <_F0> = fun (_A3) ->
        let <_F1> = fun (_A4) ->
        apply 'inferRecordPatGo'/5(_A0, _A1, _A2, _A3, _A4)
      in _F1
      in _F0

'inferRecordPatGo'/4 =
  fun (_A0, _A1, _A2, _A3) ->
    let <_F0> = fun (_A4) ->
        apply 'inferRecordPatGo'/5(_A0, _A1, _A2, _A3, _A4)
      in _F0

'typeExprToTypeWithEnv'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        let <_F3> = fun (_A3) ->
        let <_F4> = fun (_A4) ->
        apply 'typeExprToTypeWithEnv'/5(_A0, _A1, _A2, _A3, _A4)
      in _F4
      in _F3
      in _F2
      in _F1
      in _F0

'typeExprToTypeWithEnv'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        let <_F2> = fun (_A3) ->
        let <_F3> = fun (_A4) ->
        apply 'typeExprToTypeWithEnv'/5(_A0, _A1, _A2, _A3, _A4)
      in _F3
      in _F2
      in _F1
      in _F0

'typeExprToTypeWithEnv'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        let <_F1> = fun (_A3) ->
        let <_F2> = fun (_A4) ->
        apply 'typeExprToTypeWithEnv'/5(_A0, _A1, _A2, _A3, _A4)
      in _F2
      in _F1
      in _F0

'typeExprToTypeWithEnv'/3 =
  fun (_A0, _A1, _A2) ->
    let <_F0> = fun (_A3) ->
        let <_F1> = fun (_A4) ->
        apply 'typeExprToTypeWithEnv'/5(_A0, _A1, _A2, _A3, _A4)
      in _F1
      in _F0

'typeExprToTypeWithEnv'/4 =
  fun (_A0, _A1, _A2, _A3) ->
    let <_F0> = fun (_A4) ->
        apply 'typeExprToTypeWithEnv'/5(_A0, _A1, _A2, _A3, _A4)
      in _F0

'UnifyErr'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'UnifyErr'/1(_A0)
      in _F0

'UnifyErrWithContext'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'UnifyErrWithContext'/2(_A0, _A1)
      in _F1
      in _F0

'UnifyErrWithContext'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'UnifyErrWithContext'/2(_A0, _A1)
      in _F0

'UnboundVariable'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'UnboundVariable'/1(_A0)
      in _F0

'UndefinedQualifiedImport'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'UndefinedQualifiedImport'/2(_A0, _A1)
      in _F1
      in _F0

'UndefinedQualifiedImport'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'UndefinedQualifiedImport'/2(_A0, _A1)
      in _F0

'NotImplemented'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'NotImplemented'/1(_A0)
      in _F0

'module_info'/0 = fun () -> call 'erlang':'get_module_info'('Nova.Compiler.TypeChecker')

'module_info'/1 = fun (_0) -> call 'erlang':'get_module_info'('Nova.Compiler.TypeChecker', _0)
end
