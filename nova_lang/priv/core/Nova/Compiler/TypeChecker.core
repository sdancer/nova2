module 'Nova.Compiler.TypeChecker' ['intToString'/0, 'addErrorContext'/2, 'withContext'/2, 'showExprShort'/1, 'listMapWithIndex'/2, 'mkInstResult'/2, 'instantiateGo'/4, 'instantiate'/2, 'generalize'/2, 'inferLit'/1, 'unifyEnv'/1, 'infer'/2, 'inferRecordUpdate'/3, 'inferUnaryOp'/3, 'inferDo'/2, 'inferManyGo'/4, 'inferMany'/2, 'inferElemsGo'/4, 'inferElems'/3, 'inferFieldsGo'/4, 'inferFields'/2, 'inferPat'/3, 'inferRecordPatGo'/5, 'inferRecordPat'/3, 'inferListPat'/3, 'inferConsPat'/4, 'inferConPatsGo'/5, 'inferConPats'/4, 'inferBinds'/2, 'exprToPattern'/1, 'inferGuardExpr'/2, 'inferGuard'/2, 'inferClausesGo'/5, 'inferClauses'/5, 'guardedExprsToIf'/1, 'guardsToCondition'/1, 'guardClauseToCondExpr'/1, 'wrapWithPatternGuards'/2, 'buildPatternGuardCases'/2, 'checkFunction'/2, 'checkDecl'/2, 'checkTypeClass'/2, 'checkDataType'/2, 'checkDataTypeWithAliases'/3, 'checkDataTypeWithAllAliases'/4, 'checkNewtypeWithAliases'/3, 'checkNewtypeWithAllAliases'/4, 'buildConstructorTypeGo'/3, 'buildConstructorType'/3, 'buildConstructorTypeWithAliasesGo'/4, 'buildConstructorTypeWithAliases'/4, 'buildConstructorTypeWithAllAliasesGo'/5, 'buildConstructorTypeWithAllAliases'/5, 'typeExprToTypeWithAliases'/3, 'typeExprToTypeWithAllAliases'/4, 'typeExprToTypeWithEnv'/5, 'collectTypeApp'/1, 'substituteTypeExpr'/4, 'typeExprToType'/2, 'checkTypeAlias'/2, 'isRecordType'/1, 'collectTypeNames'/1, 'collectTypeExprNames'/1, 'checkModuleSimple'/2, 'checkModule'/3, 'typeCheckModule'/3, 'processImports'/3, 'mergeExportsWithTypeAliases'/2, 'processImportDecl'/3, 'expandModuleAliases'/1, 'importItem'/3, 'collectResolvedImports'/2, 'collectFromImportDecl'/3, 'getExportedNames'/1, 'getImportItemName'/1, 'collectImportedAliases'/2, 'extractExports'/1, 'extractExportsWithRegistry'/2, 'addValuesToExports'/3, 'collectTypeAliases'/1, 'collectTypeAliasesWithBase'/3, 'collectParamTypeAliases'/1, 'processNonFunctions'/2, 'processNonFunctionsWithAliases'/3, 'processInfixDeclarations'/2, 'addFunctionPlaceholders'/2, 'addFunctionPlaceholdersWithAliases'/3, 'checkFunctionBodiesGo'/2, 'checkFunctionBodies'/2, 'mergeMultiClauseFunctions'/1, 'UnifyErr'/1, 'UnifyErrWithContext'/2, 'UnboundVariable'/1, 'UndefinedQualifiedImport'/2, 'NotImplemented'/1, 'addErrorContext'/0, 'addErrorContext'/1, 'withContext'/0, 'withContext'/1, 'showExprShort'/0, 'listMapWithIndex'/0, 'listMapWithIndex'/1, 'mkInstResult'/0, 'mkInstResult'/1, 'instantiateGo'/0, 'instantiateGo'/1, 'instantiateGo'/2, 'instantiateGo'/3, 'instantiate'/0, 'instantiate'/1, 'generalize'/0, 'generalize'/1, 'inferLit'/0, 'unifyEnv'/0, 'infer'/0, 'infer'/1, 'inferRecordUpdate'/0, 'inferRecordUpdate'/1, 'inferRecordUpdate'/2, 'inferUnaryOp'/0, 'inferUnaryOp'/1, 'inferUnaryOp'/2, 'inferDo'/0, 'inferDo'/1, 'inferManyGo'/0, 'inferManyGo'/1, 'inferManyGo'/2, 'inferManyGo'/3, 'inferMany'/0, 'inferMany'/1, 'inferElemsGo'/0, 'inferElemsGo'/1, 'inferElemsGo'/2, 'inferElemsGo'/3, 'inferElems'/0, 'inferElems'/1, 'inferElems'/2, 'inferFieldsGo'/0, 'inferFieldsGo'/1, 'inferFieldsGo'/2, 'inferFieldsGo'/3, 'inferFields'/0, 'inferFields'/1, 'inferPat'/0, 'inferPat'/1, 'inferPat'/2, 'inferRecordPatGo'/0, 'inferRecordPatGo'/1, 'inferRecordPatGo'/2, 'inferRecordPatGo'/3, 'inferRecordPatGo'/4, 'inferRecordPat'/0, 'inferRecordPat'/1, 'inferRecordPat'/2, 'inferListPat'/0, 'inferListPat'/1, 'inferListPat'/2, 'inferConsPat'/0, 'inferConsPat'/1, 'inferConsPat'/2, 'inferConsPat'/3, 'inferConPatsGo'/0, 'inferConPatsGo'/1, 'inferConPatsGo'/2, 'inferConPatsGo'/3, 'inferConPatsGo'/4, 'inferConPats'/0, 'inferConPats'/1, 'inferConPats'/2, 'inferConPats'/3, 'inferBinds'/0, 'inferBinds'/1, 'exprToPattern'/0, 'inferGuardExpr'/0, 'inferGuardExpr'/1, 'inferGuard'/0, 'inferGuard'/1, 'inferClausesGo'/0, 'inferClausesGo'/1, 'inferClausesGo'/2, 'inferClausesGo'/3, 'inferClausesGo'/4, 'inferClauses'/0, 'inferClauses'/1, 'inferClauses'/2, 'inferClauses'/3, 'inferClauses'/4, 'guardedExprsToIf'/0, 'guardsToCondition'/0, 'guardClauseToCondExpr'/0, 'wrapWithPatternGuards'/0, 'wrapWithPatternGuards'/1, 'buildPatternGuardCases'/0, 'buildPatternGuardCases'/1, 'checkFunction'/0, 'checkFunction'/1, 'checkDecl'/0, 'checkDecl'/1, 'checkTypeClass'/0, 'checkTypeClass'/1, 'checkDataType'/0, 'checkDataType'/1, 'checkDataTypeWithAliases'/0, 'checkDataTypeWithAliases'/1, 'checkDataTypeWithAliases'/2, 'checkDataTypeWithAllAliases'/0, 'checkDataTypeWithAllAliases'/1, 'checkDataTypeWithAllAliases'/2, 'checkDataTypeWithAllAliases'/3, 'checkNewtypeWithAliases'/0, 'checkNewtypeWithAliases'/1, 'checkNewtypeWithAliases'/2, 'checkNewtypeWithAllAliases'/0, 'checkNewtypeWithAllAliases'/1, 'checkNewtypeWithAllAliases'/2, 'checkNewtypeWithAllAliases'/3, 'buildConstructorTypeGo'/0, 'buildConstructorTypeGo'/1, 'buildConstructorTypeGo'/2, 'buildConstructorType'/0, 'buildConstructorType'/1, 'buildConstructorType'/2, 'buildConstructorTypeWithAliasesGo'/0, 'buildConstructorTypeWithAliasesGo'/1, 'buildConstructorTypeWithAliasesGo'/2, 'buildConstructorTypeWithAliasesGo'/3, 'buildConstructorTypeWithAliases'/0, 'buildConstructorTypeWithAliases'/1, 'buildConstructorTypeWithAliases'/2, 'buildConstructorTypeWithAliases'/3, 'buildConstructorTypeWithAllAliasesGo'/0, 'buildConstructorTypeWithAllAliasesGo'/1, 'buildConstructorTypeWithAllAliasesGo'/2, 'buildConstructorTypeWithAllAliasesGo'/3, 'buildConstructorTypeWithAllAliasesGo'/4, 'buildConstructorTypeWithAllAliases'/0, 'buildConstructorTypeWithAllAliases'/1, 'buildConstructorTypeWithAllAliases'/2, 'buildConstructorTypeWithAllAliases'/3, 'buildConstructorTypeWithAllAliases'/4, 'typeExprToTypeWithAliases'/0, 'typeExprToTypeWithAliases'/1, 'typeExprToTypeWithAliases'/2, 'typeExprToTypeWithAllAliases'/0, 'typeExprToTypeWithAllAliases'/1, 'typeExprToTypeWithAllAliases'/2, 'typeExprToTypeWithAllAliases'/3, 'typeExprToTypeWithEnv'/0, 'typeExprToTypeWithEnv'/1, 'typeExprToTypeWithEnv'/2, 'typeExprToTypeWithEnv'/3, 'typeExprToTypeWithEnv'/4, 'collectTypeApp'/0, 'substituteTypeExpr'/0, 'substituteTypeExpr'/1, 'substituteTypeExpr'/2, 'substituteTypeExpr'/3, 'typeExprToType'/0, 'typeExprToType'/1, 'checkTypeAlias'/0, 'checkTypeAlias'/1, 'isRecordType'/0, 'collectTypeNames'/0, 'collectTypeExprNames'/0, 'checkModuleSimple'/0, 'checkModuleSimple'/1, 'checkModule'/0, 'checkModule'/1, 'checkModule'/2, 'typeCheckModule'/0, 'typeCheckModule'/1, 'typeCheckModule'/2, 'processImports'/0, 'processImports'/1, 'processImports'/2, 'mergeExportsWithTypeAliases'/0, 'mergeExportsWithTypeAliases'/1, 'processImportDecl'/0, 'processImportDecl'/1, 'processImportDecl'/2, 'expandModuleAliases'/0, 'importItem'/0, 'importItem'/1, 'importItem'/2, 'collectResolvedImports'/0, 'collectResolvedImports'/1, 'collectFromImportDecl'/0, 'collectFromImportDecl'/1, 'collectFromImportDecl'/2, 'getExportedNames'/0, 'getImportItemName'/0, 'collectImportedAliases'/0, 'collectImportedAliases'/1, 'extractExports'/0, 'extractExportsWithRegistry'/0, 'extractExportsWithRegistry'/1, 'addValuesToExports'/0, 'addValuesToExports'/1, 'addValuesToExports'/2, 'collectTypeAliases'/0, 'collectTypeAliasesWithBase'/0, 'collectTypeAliasesWithBase'/1, 'collectTypeAliasesWithBase'/2, 'collectParamTypeAliases'/0, 'processNonFunctions'/0, 'processNonFunctions'/1, 'processNonFunctionsWithAliases'/0, 'processNonFunctionsWithAliases'/1, 'processNonFunctionsWithAliases'/2, 'processInfixDeclarations'/0, 'processInfixDeclarations'/1, 'addFunctionPlaceholders'/0, 'addFunctionPlaceholders'/1, 'addFunctionPlaceholdersWithAliases'/0, 'addFunctionPlaceholdersWithAliases'/1, 'addFunctionPlaceholdersWithAliases'/2, 'checkFunctionBodiesGo'/0, 'checkFunctionBodiesGo'/1, 'checkFunctionBodies'/0, 'checkFunctionBodies'/1, 'mergeMultiClauseFunctions'/0, 'UnifyErr'/0, 'UnifyErrWithContext'/0, 'UnifyErrWithContext'/1, 'UnboundVariable'/0, 'UndefinedQualifiedImport'/0, 'UndefinedQualifiedImport'/1, 'NotImplemented'/0]
  attributes []
% Data type: TCError
% Constructors: UnifyErr, UnifyErrWithContext, UnboundVariable, UndefinedQualifiedImport, NotImplemented

'UnifyErr'/1 =
  fun (V0) ->
    {'UnifyErr', V0}

'UnifyErrWithContext'/2 =
  fun (V0, V1) ->
    {'UnifyErrWithContext', V0, V1}

'UnboundVariable'/1 =
  fun (V0) ->
    {'UnboundVariable', V0}

'UndefinedQualifiedImport'/2 =
  fun (V0, V1) ->
    {'UndefinedQualifiedImport', V0, V1}

'NotImplemented'/1 =
  fun (V0) ->
    {'NotImplemented', V0}

'intToString'/0 =
  fun () ->
    fun (_Pf0) -> call 'erlang':'integer_to_list'(_Pf0)

'addErrorContext'/2 =
  fun (_P0, _P1) ->
    case {_P0, _P1} of
      <{Ctx, {'UnifyErr', E}}> when 'true' ->
        apply 'UnifyErrWithContext'/2(E, Ctx)
      <{Ctx, {'UnifyErrWithContext', E, OldCtx}}> when 'true' ->
        apply 'UnifyErrWithContext'/2(E, call 'erlang':'++'(call 'erlang':'++'(OldCtx, " -> "), Ctx))
      <{_W0, Err}> when 'true' ->
        Err
    end

'withContext'/2 =
  fun (_P0, _P1) ->
    case {_P0, _P1} of
      <{Ctx, {'Left', Err}}> when 'true' ->
        {'Left', apply 'addErrorContext'/2(Ctx, Err)}
      <{_W0, {'Right', X}}> when 'true' ->
        {'Right', X}
    end

'showExprShort'/1 =
  fun (_P0) ->
    case {_P0} of
      <{{'ExprVar', N}}> when 'true' ->
        N
      <{{'ExprQualified', M, N}}> when 'true' ->
        call 'erlang':'++'(call 'erlang':'++'(M, "."), N)
      <{{'ExprLit', {'LitInt', N}}}> when 'true' ->
        call 'erlang':'integer_to_list'(N)
      <{{'ExprLit', {'LitString', S}}}> when 'true' ->
        call 'erlang':'++'(call 'erlang':'++'("\"", call 'Data.String':'take'(20, S)), "\"")
      <{{'ExprLit', {'LitBool', B}}}> when 'true' ->
        case B of
      <'true'> when 'true' -> "true"
      <'false'> when 'true' -> "false"
    end
      <{{'ExprLit', _W0}}> when 'true' ->
        "<lit>"
      <{{'ExprApp', F, A}}> when 'true' ->
        call 'erlang':'++'(call 'erlang':'++'(call 'erlang':'++'(call 'erlang':'++'("(", apply 'showExprShort'/1(F)), " "), apply 'showExprShort'/1(A)), ")")
      <{{'ExprLambda', _W0, _W1}}> when 'true' ->
        "<lambda>"
      <{{'ExprLet', _W0, _W1}}> when 'true' ->
        "<let>"
      <{{'ExprIf', _W0, _W1, _W2}}> when 'true' ->
        "<if>"
      <{{'ExprCase', _W0, _W1}}> when 'true' ->
        "<case>"
      <{{'ExprBinOp', Op, _W0, _W1}}> when 'true' ->
        call 'erlang':'++'(call 'erlang':'++'("<binop ", Op), ">")
      <{{'ExprRecord', _W0}}> when 'true' ->
        "<record>"
      <{{'ExprRecordAccess', E, F}}> when 'true' ->
        call 'erlang':'++'(call 'erlang':'++'(apply 'showExprShort'/1(E), "."), F)
      <{{'ExprRecordUpdate', _W0, _W1}}> when 'true' ->
        "<record-update>"
      <{{'ExprList', _W0}}> when 'true' ->
        "<list>"
      <{{'ExprDo', _W0}}> when 'true' ->
        "<do>"
      <{{'ExprParens', E}}> when 'true' ->
        apply 'showExprShort'/1(E)
      <{{'ExprTyped', E, _W0}}> when 'true' ->
        apply 'showExprShort'/1(E)
      <{{'ExprUnaryOp', Op, _W0}}> when 'true' ->
        call 'erlang':'++'(call 'erlang':'++'("<unary ", Op), ">")
      <{{'ExprTuple', _W0}}> when 'true' ->
        "<tuple>"
      <{{'ExprSection', S}}> when 'true' ->
        call 'erlang':'++'(call 'erlang':'++'("(", S), ")")
      <{{'ExprSectionLeft', E, Op}}> when 'true' ->
        call 'erlang':'++'(call 'erlang':'++'(call 'erlang':'++'(call 'erlang':'++'("(", apply 'showExprShort'/1(E)), " "), Op), ")")
      <{{'ExprSectionRight', Op, E}}> when 'true' ->
        call 'erlang':'++'(call 'erlang':'++'(call 'erlang':'++'(call 'erlang':'++'("(", Op), " "), apply 'showExprShort'/1(E)), ")")
    end

'listMapWithIndex'/2 =
  fun (F, List) ->
    letrec 'go'/2 = fun (_L0, _L1) ->
      case {_L0, _L1} of
        <{_W0, []}> when 'true' -> []
        <{I, [X|Xs]}> when 'true' -> [apply F(I, X)|apply 'go'/2(call 'erlang':'+'(I, 1), Xs)]
      end
      in apply 'go'/2(0, List)

'mkInstResult'/2 =
  fun (T, E) ->
    豉Ы驹у铞Ы九ч铙翎铘獒翦秋Н骢ㄟ邪咝爆咝铂咝畅汜箦咝艾咝爆咝铂咝除镦见鱼桢礤赠努圯吁恺麒孱趄蹂狃痨ы肷铙粢弩蹯臾波戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇狃痨吁怏臾ㄓ踱轭狃痨呦岚ㄓ汨屙逶┈农见鱼桢礤赠努壑义篝莠吁恺麒孱趄蹂戾歼体舭轭汜箦咛弭镦件ч洄航稚洮ь犴濮航治犴妪麒孱趄蹂戾歼体舯戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇骝弩柚狎Ж农轭狃痨呦岚ㄖ吾礤轭汜箦咛弭镦见г躔戾К乞弩璎胚麒孱趄蹂戾加踱呔汜祆尼翎歪皈骇轭箦螋Ж稚洮г轴颛乞弩椠吁猢轭狃痨ч铙翎铘獒翦秋Н川鱼桢礤赠胚义篝吁膺孱孱孱ч铙翎铘獒翦Н骢ㄅ铞鱼桢礤戾歼体舭鱼桢礤轭汜箦咛弭镦件豉Ш接汨屙逶鲠蝮Ш接汨屙逯狎簖麒孱趄蹂狃痨ч铙翎铘獒翦秋Н川鱼桢礤赠蓬霈汜祆尼翎涕篝Шф蝻砥镬溽忪濮ㄓ汨屙逯狎螬汜祆尼翎歪皈骇屙痿Ж┅孱х孱弪犰辁濮骢ㄅ铞赠戾寂铞乞邋汜祆物鲠蔑眇殪弪赠疱螫骇骝邋赠疱轴蝮蓬雩ㄅ铞轭戾荚乞邋汜祆物鲠蔑眇殪弪赠疱螫骇骝邋赠疱轴蝮Ж赠轭戾计蝈迳潴汜祆尼翎渝臾骇麸疹骘熹徕戾Ж汜祆尼翎渝臾骇溟骀弪孱沐Ж赠乞邋蓬銎蝈濠轭戾忌湫衢蝮汜祆尼翎硫蜥Шы狃组翳深溴Ж骢ㄉ澍响渖洎汜祆尼翎怎痨濮骇怎痨濮ㄏ熹射汜祆у蜢犷绉骇Ж汜祆у蜢犷绉骇Ж射暴┅乞邋射螬轭戾家屙狃吁饩汜祆尼翎歪皈骇骝镯骑熹徕戾Ж汜祆ъ轶趔Шы狃Ж骢ㄟ贪汜箦咛褒镦见г躔戾К响渖洮五魃潺麒孱趄蹂汜祆尼翎怎痨濮骇怎痨濮ㄏ熹射г轴颛戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇黼灾狎Ж五魃洎轭狃痨呦岚ㄣ犰у蜢犷绉骇ЖⅣ戾歼祁熬狃痨ч铘燥郁蜷铉Н皑轭狃痨咂畎ㄣ犰у蜢犷绉骇Ж五魃洎┅孱洮射嗅轵螬轭戾贾狎缶汜祆ъ轶趔Шы狃Ж骢ㄟ贪汜箦咛褒镦见г躔戾К咦艾五魃潺麒孱趄蹂戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇黼灾狎Ж五魃洎轭狃痨呦岚ㄣ犰у蜢犷绉骇ЖⅣ戾歼祁熬狃痨ч铘燥郁蜷铉Н皑轭狃痨咂畎ㄣ犰у蜢犷绉骇Ж五魃洎┅孱洮射嗅轵螬轭戾家屙狃疱湓戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇狃痨吁怏臾ㄒ屙狃吁猢轭狃痨呦岚ㄔ轭戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇黼鱼桢礤Ж轴蝮轭狃痨呦岚ㄒ屙狃疱湓ч铈弪涕臾骢ㄟ邪汜箦咝褒镦见涕羯铘К咦褒麒孱趄蹂汜祆物鲠蔑眇殪弪赠疱螫骇羯铘Ж见涕粑蹴忮颛咦褒麒孱趄蹂г蔑瞌戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇黼悦镱Ж⑽蹴忮颌轭狃痨呦岚ㄛ荸见涕粲趄轭绉咦褒麒孱趄蹂汜祆物鲠蔑眇殪弪赠疱螫骇粲趄轭绉ī见涕裘栳颛咦褒麒孱趄蹂汜祆物鲠蔑眇殪弪赠疱螫骇裘栳颛ī见涕袈镲歆咦褒麒孱趄蹂汜祆物鲠蔑眇殪弪赠疱螫骇袈镲歆ī孱躅殒蓬雩骢ㄅ铞汜祆物鲠蔑眇殪弪疹殒Ш躅殒组翳领獒箦螫ㄣ犰ы狃螫骇珏臾ě豉疱领獒箦螫蓬雯ч铈弪Н骢ㄟ邪咝暴汜箦咝艾咝饼镦见蓬霈砒痱涕臾涕酏麒孱趄蹂б殓梏К豉Ы踞痧禊ч铈弪涕臾报涕舂篚猝骄汜祆物鲠蔑眇殪弪赠疱螫骇屙痿吁怏臾īу铞Ы九铞
      <{Env, {'ExprVar', Name}}> when 'true' ->
        case let <_Oa0> = call 'Nova.Compiler.Types':'lookupEnv'(Env)
      in apply _Oa0(Name) of
      <'Nothing'> when 'true' ->
        {'Left', apply 'UnboundVariable'/1(Name)}
      <{'Just', Scheme}> when 'true' ->
        let <R> = apply 'instantiate'/2(Env, Scheme)
      in {'Right', 豉Ы俱犰ы狃螫骇珏臾ě豉К药篚猝骄汜祆物鲠蔑眇殪弪赠疱螫骇屙痿吁怏臾īу铞Ы俱犰ы狃螫骇珏臾ě孱雩药
    end
      <{Env, {'ExprQualified', M, Name}}> when 'true' ->
        let <FullName> = call 'erlang':'++'(call 'erlang':'++'(M, "."), Name)
      in case let <_Oa0> = call 'Nova.Compiler.Types':'lookupEnv'(Env)
      in apply _Oa0(FullName) of
      <{'Just', Scheme}> when 'true' ->
        let <R> = apply 'instantiate'/2(Env, Scheme)
      in {'Right', 豉Ы俱犰ы狃螫骇珏臾ě豉К药篚猝骄汜祆物鲠蔑眇殪弪赠疱螫骇屙痿吁怏臾īу铞Ы俱犰ы狃螫骇珏臾ě孱雩药
      <'Nothing'> when 'true' ->
        case let <_Oa0> = call 'Nova.Compiler.Types':'lookupEnv'(Env)
      in apply _Oa0(Name) of
      <{'Just', Scheme}> when 'true' ->
        let <R> = apply 'instantiate'/2(Env, Scheme)
      in {'Right', 豉Ы俱犰ы狃螫骇珏臾ě豉К药篚猝骄汜祆物鲠蔑眇殪弪赠疱螫骇屙痿吁怏臾īу铞Ы俱犰ы狃螫骇珏臾ě孱雩药
      <'Nothing'> when 'true' ->
        {'Left', apply 'UndefinedQualifiedImport'/2(M, Name)}
    end
    end
      <{Env, {'ExprApp', F, Arg}}> when 'true' ->
        letrec 'inferApp'/3 = fun (E, Func, A) ->
      case apply 'infer'/2(E, Func) of
      <{'Left', Err}> when 'true' ->
        {'Left', Err}
      <{'Right', R1}> when 'true' ->
        case apply 'infer'/2(call 'maps':'get'('env', R1), A) of
      <{'Left', Err}> when 'true' ->
        {'Left', Err}
      <{'Right', R2}> when 'true' ->
        let <_Let0> = let <_Oa0> = call 'Nova.Compiler.Types':'freshVar'(call 'maps':'get'('env', R2))
      in apply _Oa0("r")
      in case _Let0 of
        <{'Tuple', Tv, Env3}> when 'true' -> let <ResultTy> = {'TyVar', Tv}
      in let <FuncTy> = let <_Oa0> = call 'Nova.Compiler.Types':'applySubst'(call 'maps':'get'('sub', R2))
      in apply _Oa0(call 'maps':'get'('ty', R1))
      in let <ExpectedTy> = let <_Oa0> = call 'Nova.Compiler.Types':'tArrow'(call 'maps':'get'('ty', R2))
      in apply _Oa0(ResultTy)
      in case let <_Oa0> = apply 'unifyEnv'/1(Env3)
      in apply apply _Oa0(FuncTy)(ExpectedTy) of
      <{'Left', Ue}> when 'true' ->
        {'Left', apply 'UnifyErrWithContext'/2(Ue, call 'erlang':'++'(call 'erlang':'++'(call 'erlang':'++'("app: ", apply 'showExprShort'/1(Func)), " applied to "), apply 'showExprShort'/1(A)))}
      <{'Right', S3}> when 'true' ->
        let <Sub> = let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(S3)
      in apply _Oa0(let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(call 'maps':'get'('sub', R2))
      in apply _Oa0(call 'maps':'get'('sub', R1)))
      in {'Right', 豉Ы眷弭歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇狃痨吁怏臾ㄓ畅轭狃痨呦岚ㄒ弩蹯粼┈篚猝骄吁猬у铞Ы九铞除
    end
      end
    end
    end
      in case F of
      <{'ExprVar', "-"}> when 'true' ->
        case Arg of
      <{'ExprLit', {'LitInt', _W0}}> when 'true' ->
        {'Right', 豉Ы俱犰物鲠蔑眇殪弪赠疱螫骇羯铘Ж┈篚猝骄汜祆物鲠蔑眇殪弪赠疱螫骇屙痿吁怏臾īу铞Ы九铞
      <{'ExprLit', {'LitNumber', _W0}}> when 'true' ->
        {'Right', 豉Ы钧г蔑瞌戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇黼悦镱Ж⑽蹴忮颌轭狃痨呦岚ㄛ荸篚猝骄汜祆物鲠蔑眇殪弪赠疱螫骇屙痿吁怏臾īу铞Ы九铞
      <{'ExprParens', {'ExprLit', {'LitInt', _W0}}}> when 'true' ->
        {'Right', 豉Ы俱犰物鲠蔑眇殪弪赠疱螫骇羯铘Ж┈篚猝骄汜祆物鲠蔑眇殪弪赠疱螫骇屙痿吁怏臾īу铞Ы九铞
      <_W0> when 'true' ->
        apply 'inferApp'/3(Env, F, Arg)
    end
      <_W0> when 'true' ->
        apply 'inferApp'/3(Env, F, Arg)
    end
      <{Env, {'ExprLambda', Pats, Body}}> when 'true' ->
        case call 'Data.List':'uncons'(Pats) of
      <'Nothing'> when 'true' ->
        apply 'infer'/2(Env, Body)
      <{'Just', ц遽洄航嗅衄翎殪Ш揭弩粜狒簖> when 'true' ->
        let <_Let0> = let <_Oa0> = call 'Nova.Compiler.Types':'freshVar'(Env)
      in apply _Oa0("a")
      in case _Let0 of
        <{'Tuple', ArgTv, Env1}> when 'true' -> let <ArgTy> = {'TyVar', ArgTv}
      in case apply 'inferPat'/3(Env1, Pat, ArgTy) of
      <{'Left', E}> when 'true' ->
        {'Left', E}
      <{'Right', PatRes}> when 'true' ->
        let <InnerExpr> = case call 'Data.List':'null'(RestPats) of
      <'true'> when 'true' -> Body
      <'false'> when 'true' -> {'ExprLambda', RestPats, Body}
    end
      in case apply 'infer'/2(call 'maps':'get'('env', PatRes), InnerExpr) of
      <{'Left', E}> when 'true' ->
        {'Left', E}
      <{'Right', BodyRes}> when 'true' ->
        let <Sub> = let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(call 'maps':'get'('sub', BodyRes))
      in apply _Oa0(call 'maps':'get'('sub', PatRes))
      in let <ResultTy> = let <_Oa0> = call 'Nova.Compiler.Types':'tArrow'(let <_Oa0> = call 'Nova.Compiler.Types':'applySubst'(Sub)
      in apply _Oa0(ArgTy))
      in apply _Oa0(call 'maps':'get'('ty', BodyRes))
      in {'Right', 豉Ы疽弩蹯粼篚猝骄吁猬у铞Ы俱犰ы狃螫骇珏臾ě孱雩嘛澌义螬
    end
    end
      end
    end
      <{Env, {'ExprLet', Binds, Body}}> when 'true' ->
        case apply 'inferBinds'/2(Env, Binds) of
      <{'Left', E}> when 'true' ->
        {'Left', E}
      <{'Right', LetRes}> when 'true' ->
        case apply 'infer'/2(call 'maps':'get'('env', LetRes), Body) of
      <{'Left', E}> when 'true' ->
        {'Left', E}
      <{'Right', BodyRes}> when 'true' ->
        {'Right', 豉Ы俱犰ы狃螫骇珏臾ě豉К嘛澌义螬篚猝骄戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇泔眇矬逵踱篝Ж汜祆ы狃螫骇珏臾ě篚猝嘛澌义螬轭狃痨呦岚ㄣ犰ы狃螫骇珏臾ě篚猝体粢弩┅у铞Ы俱犰ы狃螫骇珏臾ě孱雩嘛澌义螬
    end
    end
      <{Env, {'ExprIf', Cond, Then_, Else_}}> when 'true' ->
        case apply 'infer'/2(Env, Cond) of
      <{'Left', E}> when 'true' ->
        {'Left', E}
      <{'Right', CondRes}> when 'true' ->
        case let <_Oa0> = apply 'unifyEnv'/1(call 'maps':'get'('env', CondRes))
      in apply apply _Oa0(call 'maps':'get'('ty', CondRes))(call 'Nova.Compiler.Types':'tBool'()) of
      <{'Left', Ue}> when 'true' ->
        {'Left', apply 'UnifyErr'/1(Ue)}
      <{'Right', _W0}> when 'true' ->
        case apply 'infer'/2(call 'maps':'get'('env', CondRes), Then_) of
      <{'Left', E}> when 'true' ->
        {'Left', E}
      <{'Right', ThenRes}> when 'true' ->
        case apply 'infer'/2(call 'maps':'get'('env', ThenRes), Else_) of
      <{'Left', E}> when 'true' ->
        {'Left', E}
      <{'Right', ElseRes}> when 'true' ->
        case let <_Oa0> = apply 'unifyEnv'/1(call 'maps':'get'('env', ElseRes))
      in apply apply _Oa0(let <_Oa0> = call 'Nova.Compiler.Types':'applySubst'(call 'maps':'get'('sub', ElseRes))
      in apply _Oa0(call 'maps':'get'('ty', ThenRes)))(call 'maps':'get'('ty', ElseRes)) of
      <{'Left', Ue}> when 'true' ->
        {'Left', apply 'UnifyErr'/1(Ue)}
      <{'Right', S}> when 'true' ->
        {'Right', 豉Ы眷弭歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇狃痨吁怏臾ㄓ轭狃痨呦岚ㄣ犰ы狃螫骇珏臾ě豉К澎箦义螬┈篚猝骄戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇泔眇矬逵踱篝Ж萤轭狃痨呦岚ㄣ犰ы狃螫骇珏臾ě篚猝澎箦义螬┈у铞Ы俱犰ы狃螫骇珏臾ě孱雩澎箦义螬
    end
    end
    end
    end
    end
      <{Env, {'ExprCase', Scrutinee, Clauses}}> when 'true' ->
        case apply 'infer'/2(Env, Scrutinee) of
      <{'Left', E}> when 'true' ->
        {'Left', E}
      <{'Right', ScrutRes}> when 'true' ->
        let <_Let0> = let <_Oa0> = call 'Nova.Compiler.Types':'freshVar'(call 'maps':'get'('env', ScrutRes))
      in apply _Oa0("case")
      in case _Let0 of
        <{'Tuple', ResultTv, Env2}> when 'true' -> let <ResultTy> = {'TyVar', ResultTv}
      in case apply 'inferClauses'/5(Env2, call 'maps':'get'('ty', ScrutRes), ResultTy, Clauses, call 'maps':'get'('sub', ScrutRes)) of
      <{'Left', E}> when 'true' ->
        {'Left', E}
      <{'Right', ClauseRes}> when 'true' ->
        {'Right', 豉Ы眷弭歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇狃痨吁怏臾ㄣ犰ы狃螫骇珏臾ě篚猝渺狨箦义螬轭狃痨呦岚ㄒ弩蹯粼┈篚猝骄汜祆ы狃螫骇珏臾ě篚猝渺狨箦义螬у铞Ы俱犰ы狃螫骇珏臾ě孱雩渺狨箦义螬
    end
      end
    end
      <{Env, {'ExprBinOp', Op, L, R}}> when 'true' ->
        case L of
      <{'ExprSection', "_"}> when 'true' ->
        apply 'infer'/2(Env, {'ExprLambda', [{'PatVar', "_x"}|[]], {'ExprBinOp', Op, {'ExprVar', "_x"}, R}})
      <_W0> when 'true' ->
        case R of
      <{'ExprSection', "_"}> when 'true' ->
        apply 'infer'/2(Env, {'ExprLambda', [{'PatVar', "_x"}|[]], {'ExprBinOp', Op, L, {'ExprVar', "_x"}}})
      <_W0> when 'true' ->
        let <MkError> = case call 'Data.String':'lastIndexOf'(call 'Data.String':'Pattern'("."), Op) of
      <{'Just', Idx}> when 'true' ->
        apply 'UndefinedQualifiedImport'/2(call 'Data.String':'take'(Idx, Op), call 'Data.String':'drop'(call 'erlang':'+'(Idx, 1), Op))
      <'Nothing'> when 'true' ->
        apply 'UnboundVariable'/1(Op)
    end
      in case let <_Oa0> = call 'Nova.Compiler.Types':'lookupEnv'(Env)
      in apply _Oa0(Op) of
      <'Nothing'> when 'true' ->
        {'Left', MkError}
      <{'Just', Scheme}> when 'true' ->
        let <OpInst> = apply 'instantiate'/2(Env, Scheme)
      in case apply 'infer'/2(call 'maps':'get'('env', OpInst), L) of
      <{'Left', E}> when 'true' ->
        {'Left', E}
      <{'Right', LRes}> when 'true' ->
        case apply 'infer'/2(call 'maps':'get'('env', LRes), R) of
      <{'Left', E}> when 'true' ->
        {'Left', E}
      <{'Right', RRes}> when 'true' ->
        let <_Let0> = let <_Oa0> = call 'Nova.Compiler.Types':'freshVar'(call 'maps':'get'('env', RRes))
      in apply _Oa0("binop")
      in case _Let0 of
        <{'Tuple', ResTv, Env4}> when 'true' -> case let <_Oa0> = apply 'unifyEnv'/1(Env4)
      in apply apply _Oa0(let <_Oa0> = call 'Nova.Compiler.Types':'applySubst'(let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(call 'maps':'get'('sub', RRes))
      in apply _Oa0(call 'maps':'get'('sub', LRes)))
      in apply _Oa0(call 'maps':'get'('ty', OpInst)))(let <_Oa0> = call 'Nova.Compiler.Types':'tArrow'(call 'maps':'get'('ty', LRes))
      in apply _Oa0(let <_Oa0> = call 'Nova.Compiler.Types':'tArrow'(call 'maps':'get'('ty', RRes))
      in apply _Oa0({'TyVar', ResTv}))) of
      <{'Left', Ue}> when 'true' ->
        {'Left', apply 'UnifyErr'/1(Ue)}
      <{'Right', S4}> when 'true' ->
        let <Sub> = let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(S4)
      in apply _Oa0(let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(call 'maps':'get'('sub', RRes))
      in apply _Oa0(call 'maps':'get'('sub', LRes)))
      in {'Right', 豉Ы眷弭歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇狃痨吁怏臾ㄓ穿轭狃痨呦岚г轴颛义笤鳊┈篚猝骄吁猬у铞Ы九铞待
    end
      end
    end
    end
    end
    end
    end
      <{Env, {'ExprList', Elems}}> when 'true' ->
        let <_Let0> = let <_Oa0> = call 'Nova.Compiler.Types':'freshVar'(Env)
      in apply _Oa0("elem")
      in case _Let0 of
        <{'Tuple', ElemTv, Env1}> when 'true' -> let <ElemTy> = {'TyVar', ElemTv}
      in case apply 'inferElems'/3(Env1, ElemTy, Elems) of
      <{'Left', E}> when 'true' ->
        {'Left', E}
      <{'Right', Res}> when 'true' ->
        {'Right', 豉Ы钧г蔑瞌戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇黼悦镱Ж⒘蝌狴轭狃痨呦岚ㄛ戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇狃痨吁怏臾ㄣ犰ы狃螫骇珏臾ě篚猝义螬轭狃痨呦岚ㄅ戾碓┹篚猝骄汜祆ы狃螫骇珏臾ě篚猝义螬у铞Ы俱犰ы狃螫骇珏臾ě孱雩义螬
    end
      end
      <{Env, {'ExprTuple', Elems}}> when 'true' ->
        case apply 'inferMany'/2(Env, Elems) of
      <{'Left', E}> when 'true' ->
        {'Left', E}
      <{'Right', Res}> when 'true' ->
        {'Right', 豉Ы俱犰物鲠蔑眇殪弪赠疱螫骇粼躔戾Ж汜祆ы狃螫骇珏臾ě豉螫义螬┈篚猝骄汜祆ы狃螫骇珏臾ě篚猝义螬у铞Ы俱犰ы狃螫骇珏臾ě孱雩义螬
    end
      <{Env, {'ExprRecord', Fields}}> when 'true' ->
        case apply 'inferFields'/2(Env, Fields) of
      <{'Left', E}> when 'true' ->
        {'Left', E}
      <{'Right', Res}> when 'true' ->
        {'Right', 豉Ы钧г义泔蜾Кф殄熹螫骄汜祆尼翎歪皈骇骝镯骑熹徕戾Ж汜祆ы狃螫骇珏臾ě豉螫义螬┈蝻鳔骄物翳轭绉,'sub'=>call 'maps':'get'('sub', Res),'env'=>call 'maps':'get'('env', Res)}}
    end
      <{Env, {'ExprRecordAccess', Rec, Field}}> when 'true' ->
        case apply 'infer'/2(Env, Rec) of
      <{'Left', E}> when 'true' ->
        {'Left', E}
      <{'Right', RecRes}> when 'true' ->
        let <_Let0> = let <_Oa0> = call 'Nova.Compiler.Types':'freshVar'(call 'maps':'get'('env', RecRes))
      in apply _Oa0("field")
      in case _Let0 of
        <{'Tuple', ResultTv, Env2}> when 'true' -> let <_Let1> = let <_Oa0> = call 'Nova.Compiler.Types':'freshVar'(Env2)
      in apply _Oa0("row")
      in case _Let1 of
        <{'Tuple', RowTv, Env3}> when 'true' -> let <ExpectedRec> = {'TyRecord', ф殄熹螫骄汜祆尼翎歪皈骇箝铉戾麸瞌ㄆ殄熹г轴颛义篚祠增┈蝻鳔骄术篝К绎髟鳊
      in case let <_Oa0> = apply 'unifyEnv'/1(Env3)
      in apply apply _Oa0(call 'maps':'get'('ty', RecRes))(ExpectedRec) of
      <{'Left', Ue}> when 'true' ->
        {'Left', apply 'UnifyErrWithContext'/2(Ue, call 'erlang':'++'(call 'erlang':'++'(call 'erlang':'++'("field access: ", apply 'showExprShort'/1(Rec)), "."), Field))}
      <{'Right', S2}> when 'true' ->
        let <Sub> = let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(S2)
      in apply _Oa0(call 'maps':'get'('sub', RecRes))
      in {'Right', 豉Ы眷弭歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇狃痨吁怏臾ㄓ踱轭狃痨呦岚г轴颛义篚祠增┈篚猝骄吁猬у铞Ы九铞除
    end
      end
      end
    end
      <{Env, {'ExprParens', E}}> when 'true' ->
        apply 'infer'/2(Env, E)
      <{Env, {'ExprTyped', E, _W0}}> when 'true' ->
        apply 'infer'/2(Env, E)
      <{Env, {'ExprRecordUpdate', Rec, Updates}}> when 'true' ->
        apply 'inferRecordUpdate'/3(Env, Rec, call 'Data.Array':'fromFoldable'(Updates))
      <{Env, {'ExprUnaryOp', Op, E}}> when 'true' ->
        apply 'inferUnaryOp'/3(Env, Op, E)
      <{Env, {'ExprDo', Stmts}}> when 'true' ->
        apply 'inferDo'/2(Env, call 'Data.Array':'fromFoldable'(Stmts))
      <{Env, {'ExprSection', Name}}> when 'true' ->
        case call 'erlang':'=:='(call 'Data.String':'take'(1, Name), ".") of
      <'true'> when 'true' -> let <Field> = call 'Data.String':'drop'(1, Name)
      in let <_Let0> = let <_Oa0> = call 'Nova.Compiler.Types':'freshVar'(Env)
      in apply _Oa0("field")
      in case _Let0 of
        <{'Tuple', ResultTv, Env1}> when 'true' -> let <_Let1> = let <_Oa0> = call 'Nova.Compiler.Types':'freshVar'(Env1)
      in apply _Oa0("row")
      in case _Let1 of
        <{'Tuple', RowTv, Env2}> when 'true' -> let <ResultType> = {'TyVar', ResultTv}
      in let <InputType> = {'TyRecord', ф殄熹螫骄汜祆尼翎歪皈骇箝铉戾麸瞌ㄆ殄熹г轴颛义篚祠增┈蝻鳔骄术篝К绎髟鳊
      in let <SectionType> = let <_Oa0> = call 'Nova.Compiler.Types':'tArrow'(InputType)
      in apply _Oa0(ResultType)
      in {'Right', 豉Ы居邈糸镱赠疱篚猝骄汜祆尼翎歪皈骇屙痿Ж┈у铞Ы九铞昌
      end
      end
      <'false'> when 'true' -> case call 'Data.Map':'lookup'(Name, call 'maps':'get'('bindings', Env)) of
      <'Nothing'> when 'true' ->
        {'Left', apply 'UnboundVariable'/1(Name)}
      <{'Just', Scheme}> when 'true' ->
        let <_Let0> = apply 'instantiate'/2(Env, Scheme)
      in case _Let0 of
        <豉Ш皆у铞Ш脚铞昌麒孱趄蹂б殓梏К豉Ы驹篚猝骄汜祆尼翎歪皈骇屙痿Ж┈у铞Ы九铞昌
      end
    end
    end
      <{Env, {'ExprSectionLeft', Expr, Op}}> when 'true' ->
        case call 'Data.Map':'lookup'(Op, call 'maps':'get'('bindings', Env)) of
      <'Nothing'> when 'true' ->
        {'Left', apply 'UnboundVariable'/1(Op)}
      <{'Just', OpScheme}> when 'true' ->
        let <_Let0> = apply 'instantiate'/2(Env, OpScheme)
      in case _Let0 of
        <豉Ш较鹪у铞Ш脚铞饼麒孱趄蹂汜箦狃痨ч铈弪Н波蓬霰砒痱镦见体骠К琵麒孱趄蹂体骠К琵见б殓梏К砒痱义簖麒孱趄蹂戾歼体舭戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇骝弩柚狎Ж汜祆ы狃螫骇珏臾ě孱雩砒痱义螬轭狃痨呦岚á箦泸弩轭汜箦咛弭镦见г躔戾К义笤霈蓬霾麒孱趄蹂戾歼体舯戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇骝弩柚狎Ж蓬霾轭狃痨呦岚á箦泸殓梏轭汜箦咛弭镦见г躔戾К议玷粼霈蓬龀麒孱趄蹂戾寂疱泗邃橡赠戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇袅蝌秣Ж汜祆ы狃螫骇珏臾ě豉К砒痱义螬轭狃痨呦岚戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇袅蝌秣Жг轴颛议玷粼鳊轭狃痨呦岚г轴颛义笤鳊┅轭汜箦戾歼厢熬狃痨躅殒蓬雩报蓬龀轭狃痨狃痨呦岚ㄏ鹪┄砒疱泗邃橡赠镦见体骠К斟麒孱趄蹂体骠К狃痨д铋纟膨颛报斟见б殓梏К育麒孱趄蹂戾加踱戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇泔眇矬逵踱篝Ж萤轭狃痨呦岚ㄣ犰ы狃螫骇珏臾ě篚猝砒痱义螬轭戾家弩蹯粼戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇袅蝌秣Ж戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇狃痨吁怏臾ㄓ踱轭狃痨呦岚г轴颛议玷粼鳊┅轭狃痨呦岚戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇狃痨吁怏臾ㄓ踱轭狃痨呦岚г轴颛义笤鳊┅轭б殓梏К豉Ы疽弩蹯粼篚猝骄吁猬у铞Ы九铞除
    end
      end
      end
    end
      end
    end
      <{Env, {'ExprSectionRight', Op, Expr}}> when 'true' ->
        case call 'Data.Map':'lookup'(Op, call 'maps':'get'('bindings', Env)) of
      <'Nothing'> when 'true' ->
        {'Left', apply 'UnboundVariable'/1(Op)}
      <{'Just', OpScheme}> when 'true' ->
        let <_Let0> = apply 'instantiate'/2(Env, OpScheme)
      in case _Let0 of
        <豉Ш较鹪у铞Ш脚铞饼麒孱趄蹂汜箦狃痨ч铈弪Н波蓬霰砒痱镦见体骠К琵麒孱趄蹂体骠К琵见б殓梏К砒痱义簖麒孱趄蹂戾歼体舭戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇骝弩柚狎Ж汜祆ы狃螫骇珏臾ě孱雩砒痱义螬轭狃痨呦岚á箦泸弩轭汜箦咛弭镦见г躔戾К义笤霈蓬霾麒孱趄蹂戾歼体舯戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇骝弩柚狎Ж蓬霾轭狃痨呦岚á箦沆彐簪轭汜箦咛弭镦见г躔戾К体骠增蓬龀麒孱趄蹂戾寂疱泗邃橡赠戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇袅蝌秣Жг轴颛体骠增轭狃痨呦岚戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇袅蝌秣Ж汜祆ы狃螫骇珏臾ě豉К砒痱义螬轭狃痨呦岚г轴颛义笤鳊┅轭汜箦戾歼厢熬狃痨躅殒蓬雩报蓬龀轭狃痨狃痨呦岚ㄏ鹪┄砒疱泗邃橡赠镦见体骠К斟麒孱趄蹂体骠К狃痨д铋纟膨颛报斟见б殓梏К育麒孱趄蹂戾加踱戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇泔眇矬逵踱篝Ж萤轭狃痨呦岚ㄣ犰ы狃螫骇珏臾ě篚猝砒痱义螬轭戾家弩蹯粼戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇袅蝌秣Ж戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇狃痨吁怏臾ㄓ踱轭狃痨呦岚г轴颛体骠增┅轭狃痨呦岚戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇狃痨吁怏臾ㄓ踱轭狃痨呦岚г轴颛义笤鳊┅轭б殓梏К豉Ы疽弩蹯粼篚猝骄吁猬у铞Ы九铞除
    end
      end
      end
    end
      end
    end
      <{_W0, _W1}> when 'true' ->
        {'Left', apply 'NotImplemented'/1("expression form")}
    end

'inferRecordUpdate'/3 =
  fun (Env, Rec, Updates) ->
    case apply 'infer'/2(Env, Rec) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', RecRes}> when 'true' ->
        case apply 'inferFields'/2(call 'maps':'get'('env', RecRes), call 'Data.List':'fromFoldable'(Updates)) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', UpdateRes}> when 'true' ->
        let <_DLet0> = let <_Oa0> = call 'Nova.Compiler.Types':'freshVar'(call 'maps':'get'('env', UpdateRes))
      in apply _Oa0("row")
      in case _DLet0 of
        <{'Tuple', RowVar, Env2}> when 'true' -> let <UpdateFields> = call 'Data.Map':'fromFoldable'(call 'maps':'get'('tys', UpdateRes))
      in let <ExpectedRec> = {'TyRecord', ф殄熹螫骄震溽翦崎屐潴蝻鳔骄术篝К绎髦狎
      in case let <_Oa0> = apply 'unifyEnv'/1(Env2)
      in apply apply _Oa0(let <_Oa0> = call 'Nova.Compiler.Types':'applySubst'(call 'maps':'get'('sub', UpdateRes))
      in apply _Oa0(call 'maps':'get'('ty', RecRes)))(ExpectedRec) of
      <{'Left', Ue}> when 'true' ->
        {'Left', apply 'UnifyErr'/1(Ue)}
      <{'Right', S}> when 'true' ->
        let <Sub> = let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(S)
      in apply _Oa0(let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(call 'maps':'get'('sub', UpdateRes))
      in apply _Oa0(call 'maps':'get'('sub', RecRes)))
      in {'Right', 豉Ы眷弭歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇狃痨吁怏臾ㄓ踱轭狃痨呦岚ㄣ犰ы狃螫骇珏臾ě豉К义阋弩┅篚猝骄吁猬у铞Ы九铞昌
    end
      end
      <{'Right', UpdateRes}> when 'true' ->
        let <_DLet0> = let <_Oa0> = call 'Nova.Compiler.Types':'freshVar'(call 'maps':'get'('env', UpdateRes))
      in apply _Oa0("row")
      in case _DLet0 of
        <{'Tuple', RowVar, Env2}> when 'true' -> let <UpdateFields> = call 'Data.Map':'fromFoldable'(call 'maps':'get'('tys', UpdateRes))
      in let <ExpectedRec> = {'TyRecord', ф殄熹螫骄震溽翦崎屐潴蝻鳔骄术篝К绎髦狎
      in case let <_Oa0> = apply 'unifyEnv'/1(Env2)
      in apply apply _Oa0(let <_Oa0> = call 'Nova.Compiler.Types':'applySubst'(call 'maps':'get'('sub', UpdateRes))
      in apply _Oa0(call 'maps':'get'('ty', RecRes)))(ExpectedRec) of
      <{'Left', Ue}> when 'true' ->
        {'Left', apply 'UnifyErr'/1(Ue)}
      <{'Right', S}> when 'true' ->
        let <Sub> = let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(S)
      in apply _Oa0(let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(call 'maps':'get'('sub', UpdateRes))
      in apply _Oa0(call 'maps':'get'('sub', RecRes)))
      in {'Right', 豉Ы眷弭歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇狃痨吁怏臾ㄓ踱轭狃痨呦岚ㄣ犰ы狃螫骇珏臾ě豉К义阋弩┅篚猝骄吁猬у铞Ы九铞昌
    end
      end
      end
      <{'Right', RecRes}> when 'true' ->
        case apply 'inferFields'/2(call 'maps':'get'('env', RecRes), call 'Data.List':'fromFoldable'(Updates)) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', UpdateRes}> when 'true' ->
        let <_DLet0> = let <_Oa0> = call 'Nova.Compiler.Types':'freshVar'(call 'maps':'get'('env', UpdateRes))
      in apply _Oa0("row")
      in case _DLet0 of
        <{'Tuple', RowVar, Env2}> when 'true' -> let <UpdateFields> = call 'Data.Map':'fromFoldable'(call 'maps':'get'('tys', UpdateRes))
      in let <ExpectedRec> = {'TyRecord', ф殄熹螫骄震溽翦崎屐潴蝻鳔骄术篝К绎髦狎
      in case let <_Oa0> = apply 'unifyEnv'/1(Env2)
      in apply apply _Oa0(let <_Oa0> = call 'Nova.Compiler.Types':'applySubst'(call 'maps':'get'('sub', UpdateRes))
      in apply _Oa0(call 'maps':'get'('ty', RecRes)))(ExpectedRec) of
      <{'Left', Ue}> when 'true' ->
        {'Left', apply 'UnifyErr'/1(Ue)}
      <{'Right', S}> when 'true' ->
        let <Sub> = let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(S)
      in apply _Oa0(let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(call 'maps':'get'('sub', UpdateRes))
      in apply _Oa0(call 'maps':'get'('sub', RecRes)))
      in {'Right', 豉Ы眷弭歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇狃痨吁怏臾ㄓ踱轭狃痨呦岚ㄣ犰ы狃螫骇珏臾ě豉К义阋弩┅篚猝骄吁猬у铞Ы九铞昌
    end
      end
      <{'Right', UpdateRes}> when 'true' ->
        let <_DLet0> = let <_Oa0> = call 'Nova.Compiler.Types':'freshVar'(call 'maps':'get'('env', UpdateRes))
      in apply _Oa0("row")
      in case _DLet0 of
        <{'Tuple', RowVar, Env2}> when 'true' -> let <UpdateFields> = call 'Data.Map':'fromFoldable'(call 'maps':'get'('tys', UpdateRes))
      in let <ExpectedRec> = {'TyRecord', ф殄熹螫骄震溽翦崎屐潴蝻鳔骄术篝К绎髦狎
      in case let <_Oa0> = apply 'unifyEnv'/1(Env2)
      in apply apply _Oa0(let <_Oa0> = call 'Nova.Compiler.Types':'applySubst'(call 'maps':'get'('sub', UpdateRes))
      in apply _Oa0(call 'maps':'get'('ty', RecRes)))(ExpectedRec) of
      <{'Left', Ue}> when 'true' ->
        {'Left', apply 'UnifyErr'/1(Ue)}
      <{'Right', S}> when 'true' ->
        let <Sub> = let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(S)
      in apply _Oa0(let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(call 'maps':'get'('sub', UpdateRes))
      in apply _Oa0(call 'maps':'get'('sub', RecRes)))
      in {'Right', 豉Ы眷弭歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇狃痨吁怏臾ㄓ踱轭狃痨呦岚ㄣ犰ы狃螫骇珏臾ě豉К义阋弩┅篚猝骄吁猬у铞Ы九铞昌
    end
      end
      end
      end

'inferUnaryOp'/3 =
  fun (Env, Op, E) ->
    case Op of
      <"-"> when 'true' ->
        case apply 'infer'/2(Env, E) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Res}> when 'true' ->
        case let <_Oa0> = apply 'unifyEnv'/1(call 'maps':'get'('env', Res))
      in apply apply _Oa0(call 'maps':'get'('ty', Res))(call 'Nova.Compiler.Types':'tInt'()) of
      <{'Left', Ue}> when 'true' ->
        {'Left', apply 'UnifyErr'/1(Ue)}
      <{'Right', S}> when 'true' ->
        {'Right', 豉Ы俱犰物鲠蔑眇殪弪赠疱螫骇羯铘Ж┈篚猝骄戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇泔眇矬逵踱篝Ж萤轭狃痨呦岚ㄣ犰ы狃螫骇珏臾ě篚猝义螬┈у铞Ы俱犰ы狃螫骇珏臾ě孱雩义螬
    end
      <{'Right', Res}> when 'true' ->
        case let <_Oa0> = apply 'unifyEnv'/1(call 'maps':'get'('env', Res))
      in apply apply _Oa0(call 'maps':'get'('ty', Res))(call 'Nova.Compiler.Types':'tInt'()) of
      <{'Left', Ue}> when 'true' ->
        {'Left', apply 'UnifyErr'/1(Ue)}
      <{'Right', S}> when 'true' ->
        {'Right', 豉Ы俱犰物鲠蔑眇殪弪赠疱螫骇羯铘Ж┈篚猝骄戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇泔眇矬逵踱篝Ж萤轭狃痨呦岚ㄣ犰ы狃螫骇珏臾ě篚猝义螬┈у铞Ы俱犰ы狃螫骇珏臾ě孱雩义螬
    end
      end
      <"!"> when 'true' ->
        case apply 'infer'/2(Env, E) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Res}> when 'true' ->
        case let <_Oa0> = apply 'unifyEnv'/1(call 'maps':'get'('env', Res))
      in apply apply _Oa0(call 'maps':'get'('ty', Res))(call 'Nova.Compiler.Types':'tBool'()) of
      <{'Left', Ue}> when 'true' ->
        {'Left', apply 'UnifyErr'/1(Ue)}
      <{'Right', S}> when 'true' ->
        {'Right', 豉Ы俱犰物鲠蔑眇殪弪赠疱螫骇袈镲歆ī篚猝骄戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇泔眇矬逵踱篝Ж萤轭狃痨呦岚ㄣ犰ы狃螫骇珏臾ě篚猝义螬┈у铞Ы俱犰ы狃螫骇珏臾ě孱雩义螬
    end
      <{'Right', Res}> when 'true' ->
        case let <_Oa0> = apply 'unifyEnv'/1(call 'maps':'get'('env', Res))
      in apply apply _Oa0(call 'maps':'get'('ty', Res))(call 'Nova.Compiler.Types':'tBool'()) of
      <{'Left', Ue}> when 'true' ->
        {'Left', apply 'UnifyErr'/1(Ue)}
      <{'Right', S}> when 'true' ->
        {'Right', 豉Ы俱犰物鲠蔑眇殪弪赠疱螫骇袈镲歆ī篚猝骄戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇泔眇矬逵踱篝Ж萤轭狃痨呦岚ㄣ犰ы狃螫骇珏臾ě篚猝义螬┈у铞Ы俱犰ы狃螫骇珏臾ě孱雩义螬
    end
      end
      <_W0> when 'true' ->
        case let <_Oa0> = call 'Nova.Compiler.Types':'lookupEnv'(Env)
      in apply _Oa0(Op) of
      <'Nothing'> when 'true' ->
        {'Left', apply 'UnboundVariable'/1(Op)}
      <{'Just', Scheme}> when 'true' ->
        let <OpInst> = apply 'instantiate'/2(Env, Scheme)
      in case apply 'infer'/2(call 'maps':'get'('env', OpInst), E) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Res}> when 'true' ->
        let <_DLet0> = let <_Oa0> = call 'Nova.Compiler.Types':'freshVar'(call 'maps':'get'('env', Res))
      in apply _Oa0("unary")
      in case _DLet0 of
        <{'Tuple', ResTv, Env2}> when 'true' -> case let <_Oa0> = apply 'unifyEnv'/1(Env2)
      in apply apply _Oa0(call 'maps':'get'('ty', OpInst))(let <_Oa0> = call 'Nova.Compiler.Types':'tArrow'(call 'maps':'get'('ty', Res))
      in apply _Oa0({'TyVar', ResTv})) of
      <{'Left', Ue}> when 'true' ->
        {'Left', apply 'UnifyErr'/1(Ue)}
      <{'Right', S}> when 'true' ->
        let <Sub> = let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(S)
      in apply _Oa0(call 'maps':'get'('sub', Res))
      in {'Right', 豉Ы眷弭歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇狃痨吁怏臾ㄓ轭狃痨呦岚г轴颛义笤鳊┈篚猝骄吁猬у铞Ы九铞昌
    end
      end
      <{'Right', Res}> when 'true' ->
        let <_DLet0> = let <_Oa0> = call 'Nova.Compiler.Types':'freshVar'(call 'maps':'get'('env', Res))
      in apply _Oa0("unary")
      in case _DLet0 of
        <{'Tuple', ResTv, Env2}> when 'true' -> case let <_Oa0> = apply 'unifyEnv'/1(Env2)
      in apply apply _Oa0(call 'maps':'get'('ty', OpInst))(let <_Oa0> = call 'Nova.Compiler.Types':'tArrow'(call 'maps':'get'('ty', Res))
      in apply _Oa0({'TyVar', ResTv})) of
      <{'Left', Ue}> when 'true' ->
        {'Left', apply 'UnifyErr'/1(Ue)}
      <{'Right', S}> when 'true' ->
        let <Sub> = let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(S)
      in apply _Oa0(call 'maps':'get'('sub', Res))
      in {'Right', 豉Ы眷弭歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇狃痨吁怏臾ㄓ轭狃痨呦岚г轴颛义笤鳊┈篚猝骄吁猬у铞Ы九铞昌
    end
      end
      end
    end
    end

'inferDo'/2 =
  fun (Env, Stmts) ->
    case call 'Data.Array':'uncons'(Stmts) of
      <'Nothing'> when 'true' ->
        {'Left', apply 'NotImplemented'/1("empty do block")}
      <{'Just', ц遽洄航郁眙翎殪Ш揭弩酏> when 'true' ->
        case Stmt of
      <{'DoExpr', E}> when 'true' ->
        case call 'Data.Array':'null'(Rest) of
      <'true'> when 'true' -> apply 'infer'/2(Env, E)
      <'false'> when 'true' -> case apply 'infer'/2(Env, E) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Res1}> when 'true' ->
        case apply 'inferDo'/2(call 'maps':'get'('env', Res1), Rest) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', RestRes}> when 'true' ->
        {'Right', 豉Ы俱犰ы狃螫骇珏臾ě豉К义篝义螬篚猝骄戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇泔眇矬逵踱篝Ж汜祆ы狃螫骇珏臾ě篚猝义篝义螬轭狃痨呦岚ㄣ犰ы狃螫骇珏臾ě篚猝义蟊┅у铞Ы俱犰ы狃螫骇珏臾ě孱雩义篝义螬
      <{'Right', RestRes}> when 'true' ->
        {'Right', 豉Ы俱犰ы狃螫骇珏臾ě豉К义篝义螬篚猝骄戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇泔眇矬逵踱篝Ж汜祆ы狃螫骇珏臾ě篚猝义篝义螬轭狃痨呦岚ㄣ犰ы狃螫骇珏臾ě篚猝义蟊┅у铞Ы俱犰ы狃螫骇珏臾ě孱雩义篝义螬
      end
      <{'Right', Res1}> when 'true' ->
        case apply 'inferDo'/2(call 'maps':'get'('env', Res1), Rest) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', RestRes}> when 'true' ->
        {'Right', 豉Ы俱犰ы狃螫骇珏臾ě豉К义篝义螬篚猝骄戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇泔眇矬逵踱篝Ж汜祆ы狃螫骇珏臾ě篚猝义篝义螬轭狃痨呦岚ㄣ犰ы狃螫骇珏臾ě篚猝义蟊┅у铞Ы俱犰ы狃螫骇珏臾ě孱雩义篝义螬
      <{'Right', RestRes}> when 'true' ->
        {'Right', 豉Ы俱犰ы狃螫骇珏臾ě豉К义篝义螬篚猝骄戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇泔眇矬逵踱篝Ж汜祆ы狃螫骇珏臾ě篚猝义篝义螬轭狃痨呦岚ㄣ犰ы狃螫骇珏臾ě篚猝义蟊┅у铞Ы俱犰ы狃螫骇珏臾ě孱雩义篝义螬
      end
      end
    end
      <{'DoBind', Pat, E}> when 'true' ->
        case apply 'infer'/2(Env, E) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', Res1}> when 'true' ->
        let <_DLet0> = let <_Oa0> = call 'Nova.Compiler.Types':'freshVar'(call 'maps':'get'('env', Res1))
      in apply _Oa0("inner")
      in case _DLet0 of
        <{'Tuple', InnerTv, Env1}> when 'true' -> let <InnerTy> = {'TyVar', InnerTv}
      in case apply 'inferPat'/3(Env1, Pat, InnerTy) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', PatRes}> when 'true' ->
        case apply 'inferDo'/2(call 'maps':'get'('env', PatRes), Rest) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', RestRes}> when 'true' ->
        let <Sub> = let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(call 'maps':'get'('sub', RestRes))
      in apply _Oa0(let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(call 'maps':'get'('sub', PatRes))
      in apply _Oa0(call 'maps':'get'('sub', Res1)))
      in {'Right', 豉Ы俱犰ы狃螫骇珏臾ě豉К义篝义螬篚猝骄吁猬у铞Ы俱犰ы狃螫骇珏臾ě孱雩义篝义螬
      <{'Right', RestRes}> when 'true' ->
        let <Sub> = let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(call 'maps':'get'('sub', RestRes))
      in apply _Oa0(let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(call 'maps':'get'('sub', PatRes))
      in apply _Oa0(call 'maps':'get'('sub', Res1)))
      in {'Right', 豉Ы俱犰ы狃螫骇珏臾ě豉К义篝义螬篚猝骄吁猬у铞Ы俱犰ы狃螫骇珏臾ě孱雩义篝义螬
      end
      <{'Right', PatRes}> when 'true' ->
        case apply 'inferDo'/2(call 'maps':'get'('env', PatRes), Rest) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', RestRes}> when 'true' ->
        let <Sub> = let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(call 'maps':'get'('sub', RestRes))
      in apply _Oa0(let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(call 'maps':'get'('sub', PatRes))
      in apply _Oa0(call 'maps':'get'('sub', Res1)))
      in {'Right', 豉Ы俱犰ы狃螫骇珏臾ě豉К义篝义螬篚猝骄吁猬у铞Ы俱犰ы狃螫骇珏臾ě孱雩义篝义螬
      <{'Right', RestRes}> when 'true' ->
        let <Sub> = let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(call 'maps':'get'('sub', RestRes))
      in apply _Oa0(let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(call 'maps':'get'('sub', PatRes))
      in apply _Oa0(call 'maps':'get'('sub', Res1)))
      in {'Right', 豉Ы俱犰ы狃螫骇珏臾ě豉К义篝义螬篚猝骄吁猬у铞Ы俱犰ы狃螫骇珏臾ě孱雩义篝义螬
      end
      end
      end
      <{'Right', Res1}> when 'true' ->
        let <_DLet0> = let <_Oa0> = call 'Nova.Compiler.Types':'freshVar'(call 'maps':'get'('env', Res1))
      in apply _Oa0("inner")
      in case _DLet0 of
        <{'Tuple', InnerTv, Env1}> when 'true' -> let <InnerTy> = {'TyVar', InnerTv}
      in case apply 'inferPat'/3(Env1, Pat, InnerTy) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', PatRes}> when 'true' ->
        case apply 'inferDo'/2(call 'maps':'get'('env', PatRes), Rest) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', RestRes}> when 'true' ->
        let <Sub> = let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(call 'maps':'get'('sub', RestRes))
      in apply _Oa0(let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(call 'maps':'get'('sub', PatRes))
      in apply _Oa0(call 'maps':'get'('sub', Res1)))
      in {'Right', 豉Ы俱犰ы狃螫骇珏臾ě豉К义篝义螬篚猝骄吁猬у铞Ы俱犰ы狃螫骇珏臾ě孱雩义篝义螬
      <{'Right', RestRes}> when 'true' ->
        let <Sub> = let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(call 'maps':'get'('sub', RestRes))
      in apply _Oa0(let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(call 'maps':'get'('sub', PatRes))
      in apply _Oa0(call 'maps':'get'('sub', Res1)))
      in {'Right', 豉Ы俱犰ы狃螫骇珏臾ě豉К义篝义螬篚猝骄吁猬у铞Ы俱犰ы狃螫骇珏臾ě孱雩义篝义螬
      end
      <{'Right', PatRes}> when 'true' ->
        case apply 'inferDo'/2(call 'maps':'get'('env', PatRes), Rest) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', RestRes}> when 'true' ->
        let <Sub> = let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(call 'maps':'get'('sub', RestRes))
      in apply _Oa0(let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(call 'maps':'get'('sub', PatRes))
      in apply _Oa0(call 'maps':'get'('sub', Res1)))
      in {'Right', 豉Ы俱犰ы狃螫骇珏臾ě豉К义篝义螬篚猝骄吁猬у铞Ы俱犰ы狃螫骇珏臾ě孱雩义篝义螬
      <{'Right', RestRes}> when 'true' ->
        let <Sub> = let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(call 'maps':'get'('sub', RestRes))
      in apply _Oa0(let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(call 'maps':'get'('sub', PatRes))
      in apply _Oa0(call 'maps':'get'('sub', Res1)))
      in {'Right', 豉Ы俱犰ы狃螫骇珏臾ě豉К义篝义螬篚猝骄吁猬у铞Ы俱犰ы狃螫骇珏臾ě孱雩义篝义螬
      end
      end
      end
      end
      <{'DoLet', Binds}> when 'true' ->
        case apply 'inferBinds'/2(Env, Binds) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', LetRes}> when 'true' ->
        apply 'inferDo'/2(call 'maps':'get'('env', LetRes), Rest)
      <{'Right', LetRes}> when 'true' ->
        apply 'inferDo'/2(call 'maps':'get'('env', LetRes), Rest)
      end
    end
    end

'inferManyGo'/4 =
  fun (_P0, _P1, _P2, _P3) ->
    case {_P0, _P1, _P2, _P3} of
      <{E, [], Acc, Sub}> when 'true' ->
        {'Right', 豉螫骄汜祆尼翎硫蜥Шф蝻砥镬溽忪濮ㄣ犰尼翎涕篝Ш蝈鲥蝮濮零悌┈篚猝骄吁猬у铞Ы九
      <{E, [Expr|Rest], Acc, Sub}> when 'true' ->
        case apply 'infer'/2(E, Expr) of
      <{'Left', Err}> when 'true' ->
        {'Left', Err}
      <{'Right', Res}> when 'true' ->
        apply 'inferManyGo'/4(call 'maps':'get'('env', Res), Rest, [call 'maps':'get'('ty', Res)|Acc], let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(call 'maps':'get'('sub', Res))
      in apply _Oa0(Sub))
    end
    end

'inferMany'/2 =
  fun (Env, Exprs) ->
    apply 'inferManyGo'/4(Env, Exprs, [], call 'Nova.Compiler.Types':'emptySubst'())

'inferElemsGo'/4 =
  fun (_P0, _P1, _P2, _P3) ->
    case {_P0, _P1, _P2, _P3} of
      <{E, _W0, [], Sub}> when 'true' ->
        {'Right', 篚猝骄吁猬у铞Ы九
      <{E, ETy, [Expr|Rest], Sub}> when 'true' ->
        case apply 'infer'/2(E, Expr) of
      <{'Left', Err}> when 'true' ->
        {'Left', Err}
      <{'Right', Res}> when 'true' ->
        case let <_Oa0> = apply 'unifyEnv'/1(call 'maps':'get'('env', Res))
      in apply apply _Oa0(let <_Oa0> = call 'Nova.Compiler.Types':'applySubst'(call 'maps':'get'('sub', Res))
      in apply _Oa0(ETy))(call 'maps':'get'('ty', Res)) of
      <{'Left', Ue}> when 'true' ->
        {'Left', apply 'UnifyErr'/1(Ue)}
      <{'Right', S2}> when 'true' ->
        apply 'inferElemsGo'/4(call 'maps':'get'('env', Res), let <_Oa0> = call 'Nova.Compiler.Types':'applySubst'(S2)
      in apply _Oa0(ETy), Rest, let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(S2)
      in apply _Oa0(let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(call 'maps':'get'('sub', Res))
      in apply _Oa0(Sub)))
    end
    end
    end

'inferElems'/3 =
  fun (Env, ElemTy, Elems) ->
    apply 'inferElemsGo'/4(Env, ElemTy, Elems, call 'Nova.Compiler.Types':'emptySubst'())

'inferFieldsGo'/4 =
  fun (_P0, _P1, _P2, _P3) ->
    case {_P0, _P1, _P2, _P3} of
      <{E, [], Acc, Sub}> when 'true' ->
        {'Right', 豉螫骄汜祆尼翎涕篝Ш蝈鲥蝮濮零悌篚猝骄吁猬у铞Ы九
      <{E, [{'Tuple', Name, Expr}|Rest], Acc, Sub}> when 'true' ->
        case apply 'infer'/2(E, Expr) of
      <{'Left', Err}> when 'true' ->
        {'Left', Err}
      <{'Right', Res}> when 'true' ->
        apply 'inferFieldsGo'/4(call 'maps':'get'('env', Res), Rest, [call 'Data.Tuple':'Tuple'(Name, call 'maps':'get'('ty', Res))|Acc], let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(call 'maps':'get'('sub', Res))
      in apply _Oa0(Sub))
    end
    end

'inferFields'/2 =
  fun (Env, Fields) ->
    apply 'inferFieldsGo'/4(Env, Fields, [], call 'Nova.Compiler.Types':'emptySubst'())

'inferPat'/3 =
  fun (_P0, _P1, _P2) ->
    case {_P0, _P1, _P2} of
      <{Env, {'PatVar', Name}, Ty}> when 'true' ->
        let <Scheme> = let <_Oa0> = call 'Nova.Compiler.Types':'mkScheme'([])
      in apply _Oa0(Ty)
      in let <Env_> = let <_Oa0> = call 'Nova.Compiler.Types':'extendEnv'(Env)
      in apply apply _Oa0(Name)(Scheme)
      in {'Right', у铞Ы九铞攥篚猝骄汜祆物鲠蔑眇殪弪赠疱螫骇屙痿吁怏臾ī
      <{Env, 'PatWildcard', _W0}> when 'true' ->
        {'Right', у铞Ы九铞篚猝骄汜祆物鲠蔑眇殪弪赠疱螫骇屙痿吁怏臾ī
      <{Env, {'PatLit', Lit}, Ty}> when 'true' ->
        let <LitTy> = apply 'inferLit'/1(Lit)
      in case let <_Oa0> = apply 'unifyEnv'/1(Env)
      in apply apply _Oa0(Ty)(LitTy) of
      <{'Left', Ue}> when 'true' ->
        {'Left', apply 'UnifyErr'/1(Ue)}
      <{'Right', S}> when 'true' ->
        {'Right', у铞Ы九铞篚猝骄育
    end
      <{Env, {'PatCon', ConName, Pats}, Ty}> when 'true' ->
        let <UnqualifiedName> = case call 'Data.String':'lastIndexOf'(call 'Data.String':'Pattern'("."), ConName) of
      <{'Just', Idx}> when 'true' ->
        call 'Data.String':'drop'(call 'erlang':'+'(Idx, 1), ConName)
      <'Nothing'> when 'true' ->
        ConName
    end
      in let <MkError> = case call 'Data.String':'lastIndexOf'(call 'Data.String':'Pattern'("."), ConName) of
      <{'Just', Idx}> when 'true' ->
        apply 'UndefinedQualifiedImport'/2(call 'Data.String':'take'(Idx, ConName), UnqualifiedName)
      <'Nothing'> when 'true' ->
        apply 'UnboundVariable'/1(ConName)
    end
      in letrec 'tryLookup'/1 = fun (Name) ->
      let <_Oa0> = call 'Nova.Compiler.Types':'lookupEnv'(Env)
      in apply _Oa0(Name)
      in case apply 'tryLookup'/1(ConName) of
      <{'Just', Scheme}> when 'true' ->
        let <R> = apply 'instantiate'/2(Env, Scheme)
      in apply 'inferConPats'/4(call 'maps':'get'('env', R), call 'maps':'get'('ty', R), Pats, Ty)
      <'Nothing'> when 'true' ->
        case apply 'tryLookup'/1(UnqualifiedName) of
      <{'Just', Scheme}> when 'true' ->
        let <R> = apply 'instantiate'/2(Env, Scheme)
      in apply 'inferConPats'/4(call 'maps':'get'('env', R), call 'maps':'get'('ty', R), Pats, Ty)
      <'Nothing'> when 'true' ->
        {'Left', MkError}
    end
    end
      <{Env, {'PatParens', P}, Ty}> when 'true' ->
        apply 'inferPat'/3(Env, P, Ty)
      <{Env, {'PatRecord', Fields}, Ty}> when 'true' ->
        apply 'inferRecordPat'/3(Env, Fields, Ty)
      <{Env, {'PatList', Pats}, Ty}> when 'true' ->
        apply 'inferListPat'/3(Env, Pats, Ty)
      <{Env, {'PatCons', Hd, Tl}, Ty}> when 'true' ->
        apply 'inferConsPat'/4(Env, Hd, Tl, Ty)
      <{Env, {'PatAs', Name, Pat}, Ty}> when 'true' ->
        case apply 'inferPat'/3(Env, Pat, Ty) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', PatRes}> when 'true' ->
        let <Scheme> = let <_Oa0> = call 'Nova.Compiler.Types':'mkScheme'([])
      in apply _Oa0(let <_Oa0> = call 'Nova.Compiler.Types':'applySubst'(call 'maps':'get'('sub', PatRes))
      in apply _Oa0(Ty))
      in let <Env_> = let <_Oa0> = call 'Nova.Compiler.Types':'extendEnv'(call 'maps':'get'('env', PatRes))
      in apply apply _Oa0(Name)(Scheme)
      in {'Right', у铞Ы九铞攥篚猝骄汜祆ы狃螫骇珏臾ě篚猝嗅粢弩
      <{'Right', PatRes}> when 'true' ->
        let <Scheme> = let <_Oa0> = call 'Nova.Compiler.Types':'mkScheme'([])
      in apply _Oa0(let <_Oa0> = call 'Nova.Compiler.Types':'applySubst'(call 'maps':'get'('sub', PatRes))
      in apply _Oa0(Ty))
      in let <Env_> = let <_Oa0> = call 'Nova.Compiler.Types':'extendEnv'(call 'maps':'get'('env', PatRes))
      in apply apply _Oa0(Name)(Scheme)
      in {'Right', у铞Ы九铞攥篚猝骄汜祆ы狃螫骇珏臾ě篚猝嗅粢弩
      end
      <{_W0, _W1, _W2}> when 'true' ->
        {'Left', apply 'NotImplemented'/1("pattern form")}
    end

'inferRecordPatGo'/5 =
  fun (_P0, _P1, _P2, _P3, _P4) ->
    case {_P0, _P1, _P2, _P3, _P4} of
      <{Ty, E, [], FieldTypes, Sub}> when 'true' ->
        let <_DLet0> = let <_Oa0> = call 'Nova.Compiler.Types':'freshVar'(E)
      in apply _Oa0("row")
      in case _DLet0 of
        <{'Tuple', RowVar, E_}> when 'true' -> let <ExpectedRec> = {'TyRecord', ф殄熹螫骄崎屐湓疱蟋蝻鳔骄术篝К绎髦狎
      in case let <_Oa0> = apply 'unifyEnv'/1(E_)
      in apply apply _Oa0(let <_Oa0> = call 'Nova.Compiler.Types':'applySubst'(Sub)
      in apply _Oa0(Ty))(ExpectedRec) of
      <{'Left', Ue}> when 'true' ->
        {'Left', apply 'UnifyErr'/1(Ue)}
      <{'Right', S}> when 'true' ->
        {'Right', у铞Ы九攥篚猝骄戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇泔眇矬逵踱篝Ж萤轭狃痨呦岚ㄓ踱
    end
      end
      <{Ty, E, [{'Tuple', Label, Pat}|Rest], FieldTypes, Sub}> when 'true' ->
        let <_DLet0> = let <_Oa0> = call 'Nova.Compiler.Types':'freshVar'(E)
      in apply _Oa0(call 'erlang':'++'("f_", Label))
      in case _DLet0 of
        <{'Tuple', FieldVar, E1}> when 'true' -> let <FieldTy> = {'TyVar', FieldVar}
      in case apply 'inferPat'/3(E1, Pat, FieldTy) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', PatRes}> when 'true' ->
        apply 'inferRecordPatGo'/5(Ty, call 'maps':'get'('env', PatRes), Rest, call 'Data.Map':'insert'(Label, let <_Oa0> = call 'Nova.Compiler.Types':'applySubst'(call 'maps':'get'('sub', PatRes))
      in apply _Oa0(FieldTy), FieldTypes), let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(call 'maps':'get'('sub', PatRes))
      in apply _Oa0(Sub))
      <{'Right', PatRes}> when 'true' ->
        apply 'inferRecordPatGo'/5(Ty, call 'maps':'get'('env', PatRes), Rest, call 'Data.Map':'insert'(Label, let <_Oa0> = call 'Nova.Compiler.Types':'applySubst'(call 'maps':'get'('sub', PatRes))
      in apply _Oa0(FieldTy), FieldTypes), let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(call 'maps':'get'('sub', PatRes))
      in apply _Oa0(Sub))
      end
      end
    end

'inferRecordPat'/3 =
  fun (Env, Fields, Ty) ->
    apply 'inferRecordPatGo'/5(Ty, Env, Fields, call 'Data.Map':'empty'(), call 'Nova.Compiler.Types':'emptySubst'())

'inferListPat'/3 =
  fun (Env, Pats, Ty) ->
    letrec 'goElems'/4 = fun (_L0, _L1, _L2, _L3) ->
      case {_L0, _L1, _L2, _L3} of
        <{E, [], _W0, Sub}> when 'true' -> {'Right', у铞Ы九篚猝骄吁恺
        <{E, [P|Rest], ETy, Sub}> when 'true' -> case apply 'inferPat'/3(E, P, ETy) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', PatRes}> when 'true' ->
        apply 'goElems'/4(call 'maps':'get'('env', PatRes), Rest, let <_Oa0> = call 'Nova.Compiler.Types':'applySubst'(call 'maps':'get'('sub', PatRes))
      in apply _Oa0(ETy), let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(call 'maps':'get'('sub', PatRes))
      in apply _Oa0(Sub))
      <{'Right', PatRes}> when 'true' ->
        apply 'goElems'/4(call 'maps':'get'('env', PatRes), Rest, let <_Oa0> = call 'Nova.Compiler.Types':'applySubst'(call 'maps':'get'('sub', PatRes))
      in apply _Oa0(ETy), let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(call 'maps':'get'('sub', PatRes))
      in apply _Oa0(Sub))
      end
      end
      in let <_DLet0> = let <_Oa0> = call 'Nova.Compiler.Types':'freshVar'(Env)
      in apply _Oa0("elem")
      in case _DLet0 of
        <{'Tuple', ElemVar, Env1}> when 'true' -> let <ElemTy> = {'TyVar', ElemVar}
      in case let <_Oa0> = apply 'unifyEnv'/1(Env1)
      in apply apply _Oa0(Ty)(call 'Nova.Compiler.Types':'tArray'(ElemTy)) of
      <{'Left', Ue}> when 'true' ->
        {'Left', apply 'UnifyErr'/1(Ue)}
      <{'Right', S1}> when 'true' ->
        let <ElemTy_> = let <_Oa0> = call 'Nova.Compiler.Types':'applySubst'(S1)
      in apply _Oa0(ElemTy)
      in apply 'goElems'/4(Env1, Pats, ElemTy_, S1)
    end
      end

'inferConsPat'/4 =
  fun (Env, HdPat, TlPat, Ty) ->
    let <_DLet0> = let <_Oa0> = call 'Nova.Compiler.Types':'freshVar'(Env)
      in apply _Oa0("elem")
      in case _DLet0 of
        <{'Tuple', ElemVar, Env1}> when 'true' -> let <ElemTy> = {'TyVar', ElemVar}
      in case let <_Oa0> = apply 'unifyEnv'/1(Env1)
      in apply apply _Oa0(Ty)(call 'Nova.Compiler.Types':'tArray'(ElemTy)) of
      <{'Left', Ue}> when 'true' ->
        {'Left', apply 'UnifyErr'/1(Ue)}
      <{'Right', S1}> when 'true' ->
        let <ElemTy_> = let <_Oa0> = call 'Nova.Compiler.Types':'applySubst'(S1)
      in apply _Oa0(ElemTy)
      in let <ListTy> = let <_Oa0> = call 'Nova.Compiler.Types':'applySubst'(S1)
      in apply _Oa0(call 'Nova.Compiler.Types':'tArray'(ElemTy))
      in case apply 'inferPat'/3(Env1, HdPat, ElemTy_) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', HdRes}> when 'true' ->
        case apply 'inferPat'/3(call 'maps':'get'('env', HdRes), TlPat, let <_Oa0> = call 'Nova.Compiler.Types':'applySubst'(call 'maps':'get'('sub', HdRes))
      in apply _Oa0(ListTy)) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', TlRes}> when 'true' ->
        {'Right', у铞Ы俱犰ы狃螫骇珏臾ě孱雩造义螬篚猝骄戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇泔眇矬逵踱篝Ж汜祆ы狃螫骇珏臾ě篚猝造义螬轭狃痨呦岚戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇泔眇矬逵踱篝Ж汜祆ы狃螫骇珏臾ě篚猝蠕义螬轭狃痨呦岚ㄓ暴
      <{'Right', TlRes}> when 'true' ->
        {'Right', у铞Ы俱犰ы狃螫骇珏臾ě孱雩造义螬篚猝骄戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇泔眇矬逵踱篝Ж汜祆ы狃螫骇珏臾ě篚猝造义螬轭狃痨呦岚戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇泔眇矬逵踱篝Ж汜祆ы狃螫骇珏臾ě篚猝蠕义螬轭狃痨呦岚ㄓ暴
      end
      <{'Right', HdRes}> when 'true' ->
        case apply 'inferPat'/3(call 'maps':'get'('env', HdRes), TlPat, let <_Oa0> = call 'Nova.Compiler.Types':'applySubst'(call 'maps':'get'('sub', HdRes))
      in apply _Oa0(ListTy)) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', TlRes}> when 'true' ->
        {'Right', у铞Ы俱犰ы狃螫骇珏臾ě孱雩造义螬篚猝骄戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇泔眇矬逵踱篝Ж汜祆ы狃螫骇珏臾ě篚猝造义螬轭狃痨呦岚戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇泔眇矬逵踱篝Ж汜祆ы狃螫骇珏臾ě篚猝蠕义螬轭狃痨呦岚ㄓ暴
      <{'Right', TlRes}> when 'true' ->
        {'Right', у铞Ы俱犰ы狃螫骇珏臾ě孱雩造义螬篚猝骄戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇泔眇矬逵踱篝Ж汜祆ы狃螫骇珏臾ě篚猝造义螬轭狃痨呦岚戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇泔眇矬逵踱篝Ж汜祆ы狃螫骇珏臾ě篚猝蠕义螬轭狃痨呦岚ㄓ暴
      end
      end
    end
      end

'inferConPatsGo'/5 =
  fun (_P0, _P1, _P2, _P3, _P4) ->
    case {_P0, _P1, _P2, _P3, _P4} of
      <{ResultTy, E, Ty, [], Sub}> when 'true' ->
        case let <_Oa0> = apply 'unifyEnv'/1(E)
      in apply apply _Oa0(Ty)(ResultTy) of
      <{'Left', Ue}> when 'true' ->
        {'Left', apply 'UnifyErr'/1(Ue)}
      <{'Right', S}> when 'true' ->
        {'Right', у铞Ы九篚猝骄戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇泔眇矬逵踱篝Ж萤轭狃痨呦岚ㄓ踱
    end
      <{ResultTy, E, Ty, [P|Rest], Sub}> when 'true' ->
        case Ty of
      <{'TyCon', C}> when 'true' ->
        case call 'erlang':'=:='(call 'maps':'get'('name', C), "Fun") of
          <'true'> when 'true' -> case пЫ俱犰尼翎硫蜥Шц遽洄ㄣ犰ы狃螫骇珏臾ě狎珞К茅┈рЫ俱犰尼翎硫蜥Шъ狍臾ㄣ犰ы狃螫骇珏臾ě狎珞К茅镦件пШ禁术篝К硫缭рШ禁术篝К义笤麒孱趄蹂汜箦狃痨ч铈弪嗅臾敞努鞋硫缭镦见体骠К膨螨麒孱趄蹂体骠К膨螨见б殓梏К嗅粢弩麒孱趄蹂狃痨ч铈弪蔑钚狒笄铵胆义篚祠赠汜祆ы狃螫骇珏臾ě孱雩嗅粢弩┈义笤义篝戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇泔眇矬逵踱篝Ж汜祆ы狃螫骇珏臾ě篚猝嗅粢弩┅轭狃痨呦岚ㄓ踱┅孱歼装麒孱趄蹂体骠К狃痨物羯眇戾礤铘邃Н报㈨犰骘蝽邃骢钽糸镱豉疱孱歼麒孱趄蹂体骠К狃痨物羯眇戾礤铘邃Н报㈠疱泗邃骢钽糸镱豉疱轭泔铙趄蹉麸颌孱歼装麒孱趄蹂体骠К狃痨物羯眇戾礤铘邃Н报㈠疱泗邃骢钽糸镱豉疱轭泔铙趄蹉麸颌孱孱ч铈弪蔑钚狒螫骢ㄅ铞蔑钤嗅趔义篚祠赠狃痨ч铈弪蔑钚狒笄铵胆义篚祠赠蓬霈蔑钤嗅趔汜祆物鲠蔑眇殪弪赠疱螫骇屙痿吁怏臾īч铈弪麻钿螫骢ㄅ铞麻钿螬戾趄邈п滗麻钿徐徙彖镬溴蝮Н骢ㄅ麦汜祆尼翎骑熹徕戾Шф镬潇Ж骢ㄟ玩艾咄姹狃痨п滗项濮波咄姘咄姹┈努麦п滗项濮骢ㄅ麻钿汜箦汜祆ы狃螫骇珏臾ě疳趑弪瞌麻钿镦见嗅糁狎К吾礤麒孱趄蹂汜箦汜祆ы狃螫骇珏臾ě豉疱令瞌麻钿镦见术篝К赠砒痱麒孱趄蹂戾剂铑雉狒邃赠狃痨豉疱砒痱燥赠疱Н波汜祆尼翎歪皈骇屙痿Ж┈赠砒痱轭戾加汨屙寰戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇黼鱼桢礤Ж圯轭狃痨呦岚令铒翎翦湓轭戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇屮翦钿蓬雩ㄅ轭狃痨狃痨呦岚ㄎ犴濠ㄓ汨屙濠姬物翳轭绉麒孱趄蹂戾歼体舭戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇骝弩柚狎Ж农轭狃痨呦岚ㄣ犰у蜢犷绉骇Ж㈧弭撷吾礤┅轭汜箦咛弭镦见г躔戾К增胚麒孱趄蹂戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇屮翦钿蓬雩ㄅ擤轭狃痨狃痨呦岚ㄎ犴濠戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇黼鱼桢礤Ж圯轭狃痨呦岚г轴颛增┅孱孱歼装麒孱趄蹂孱ч铈弪麻钿笮狍蟛Н骢ㄟ贪咛爆咛博汜箦咛艾咛爆咛昌镦见努圯吁恺麒孱趄蹂б殓梏Ку铞Ы九篚猝骄吁恺
        <{E, [Bind|Rest], Sub}> when 'true' -> case apply 'infer'/2(E, call 'maps':'get'('value', Bind)) of
      <{'Left', Err}> when 'true' ->
        {'Left', Err}
      <{'Right', ValRes}> when 'true' ->
        case apply 'inferPat'/3(call 'maps':'get'('env', ValRes), call 'maps':'get'('pattern', Bind), call 'maps':'get'('ty', ValRes)) of
      <{'Left', Err}> when 'true' ->
        {'Left', Err}
      <{'Right', PatRes}> when 'true' ->
        let <Scheme> = apply 'generalize'/2(E, let <_Oa0> = call 'Nova.Compiler.Types':'applySubst'(let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(call 'maps':'get'('sub', PatRes))
      in apply _Oa0(call 'maps':'get'('sub', ValRes)))
      in apply _Oa0(call 'maps':'get'('ty', ValRes)))
      in let <Env3> = case call 'maps':'get'('pattern', Bind) of
      <{'PatVar', Name}> when 'true' ->
        let <_Oa0> = call 'Nova.Compiler.Types':'extendEnv'(call 'maps':'merge'(E, с秕铘弪Ы俱犰ы狃螫骇珏臾ě泔躅翦颛汜祆ы狃螫骇珏臾ě孱雩嗅粢弩┅┅轭狃痨狃痨呦岚ㄎ犴濠ㄓ汨屙濠歼装麒孱趄蹂戾夹狒蓬鼍戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇狃痨吁怏粼锱铞Ж戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇泔眇矬逵踱篝Ж汜祆ы狃螫骇珏臾ě篚猝嗅粢弩┅轭狃痨呦岚ㄣ犰ы狃螫骇珏臾ě篚猝轴煲弩┅轭狃痨呦岚ㄣ犰ы狃螫骇珏臾ě孱雩嗅粢弩┅轭汜祆ы狃螫骇礤蜱濮ㄐ狒蓬霈р轭溟铉螫骄汜祆尼翎歪皈骇躅轱瞌ㄣ犰ы狃螫骇珏臾ě忾钿轭珞К嗅襞铞┈汜祆ы狃螫骇珏臾ě忾钿轭珞К农孱轭狃痨ч铈弪麻钿笮狍蟛Н敞蓬龀义篝戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇泔眇矬逵踱篝Ж汜祆ы狃螫骇珏臾ě篚猝嗅粢弩┅轭狃痨呦岚戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇泔眇矬逵踱篝Ж汜祆ы狃螫骇珏臾ě篚猝轴煲弩┅轭狃痨呦岚ㄓ踱┅孱孱孱轭戾寂铞组翳徐徙彖镬溴蝮狃痨п滗麻钿徐徙彖镬溴蝮Н波蓬霈麻钿螬轭狃痨ч铈弪麻钿笮狍蟛Н敞蓬鲎轸栊灬沐栾熹弪蟋麻钿蟋汜祆物鲠蔑眇殪弪赠疱螫骇屙痿吁怏臾īу痱燥嗅趑弪瞌骢ㄟ邪汜箦咝褒镦见砒痱轴颛吾礤麒孱趄蹂嗅糁狎К吾礤见砒痱琉皈砒痱轴颛蔑铨硫琮麒孱趄蹂嗅裘镱К蔑瞵坩痧禊у痱燥嗅趑弪瞌报硫绌圯蔟见砒痱琉皈砒痱琉皈砒痱轴颛蔑铨硫绫硫绮麒孱趄蹂嗅裘镱К蔑瞵坩痧禊у痱燥嗅趑弪瞌报硫绫坩痧禊у痱燥嗅趑弪瞌报硫绮圯葺见砒痱涕臾涕酏麒孱趄蹂嗅籼轸К涕酏见砒痱嗅蝈铙К琵麒孱趄蹂狃痨у痱燥嗅趑弪瞌报农见咦褒麒孱趄蹂嗅糇殪溷狎洄孱ч铈弪酋狎渑痱Н骢ㄟ邪咝暴汜箦咝艾咝饼镦见努砒痱麻钕皈Ζ体骠议玷酏麒孱趄蹂汜箦狃痨ч铈弪酋狎渑痱Н波努体骠镦见体骠К膨螨麒孱趄蹂体骠К膨螨见б殓梏К体骠义簖麒孱趄蹂汜箦狃痨ч铈弪酋狎渑痱Н波汜祆ы狃螫骇珏臾ě孱雩体骠义螬议玷舂镦见体骠К膨螨麒孱趄蹂体骠К膨螨见б殓梏К议玷粢弩麒孱趄蹂б殓梏Ку铞Ы俱犰ы狃螫骇珏臾ě孱雩议玷粢弩┈篚猝骄戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇泔眇矬逵踱篝Ж汜祆ы狃螫骇珏臾ě篚猝议玷粢弩┅轭狃痨呦岚ㄣ犰ы狃螫骇珏臾ě篚猝体骠义螬
    end
    end
      <{E, {'ExprBinOp', "<-", PatExpr, ValExpr}}> when 'true' ->
        case apply 'infer'/2(E, ValExpr) of
      <{'Left', Err}> when 'true' ->
        {'Left', Err}
      <{'Right', ValRes}> when 'true' ->
        let <Pat> = apply 'exprToPattern'/1(PatExpr)
      in case apply 'inferPat'/3(call 'maps':'get'('env', ValRes), Pat, call 'maps':'get'('ty', ValRes)) of
      <{'Left', Err}> when 'true' ->
        {'Left', Err}
      <{'Right', PatRes}> when 'true' ->
        {'Right', у铞Ы俱犰ы狃螫骇珏臾ě孱雩嗅粢弩┈篚猝骄戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇泔眇矬逵踱篝Ж汜祆ы狃螫骇珏臾ě篚猝嗅粢弩┅轭狃痨呦岚ㄣ犰ы狃螫骇珏臾ě篚猝轴煲弩┅
    end
    end
      <{E, {'ExprBinOp', ",", Left, Right}}> when 'true' ->
        apply 'inferGuardExpr'/2(E, {'ExprBinOp', "&&", Left, Right})
      <{E, Expr}> when 'true' ->
        case apply 'infer'/2(E, Expr) of
      <{'Left', Err}> when 'true' ->
        {'Left', Err}
      <{'Right', Res}> when 'true' ->
        {'Right', у铞Ы俱犰ы狃螫骇珏臾ě孱雩义螬篚猝骄汜祆ы狃螫骇珏臾ě篚猝义螬
    end
    end

'inferGuard'/2 =
  fun (_P0, _P1) ->
    case {_P0, _P1} of
      <{E, 'Nothing'}> when 'true' ->
        {'Right', у铞Ы九篚猝骄汜祆物鲠蔑眇殪弪赠疱螫骇屙痿吁怏臾ī
      <{E, {'Just', GuardExpr}}> when 'true' ->
        apply 'inferGuardExpr'/2(E, GuardExpr)
    end

'inferClausesGo'/5 =
  fun (_P0, _P1, _P2, _P3, _P4) ->
    case {_P0, _P1, _P2, _P3, _P4} of
      <{_W0, _W1, E, [], Sub}> when 'true' ->
        {'Right', у铞Ы九篚猝骄吁恺
      <{STy, RTy, E, [Clause|Rest], Sub}> when 'true' ->
        let <STy_> = let <_Oa0> = call 'Nova.Compiler.Types':'applySubst'(Sub)
      in apply _Oa0(STy)
      in let <RTy_> = let <_Oa0> = call 'Nova.Compiler.Types':'applySubst'(Sub)
      in apply _Oa0(RTy)
      in case apply 'inferPat'/3(E, call 'maps':'get'('pattern', Clause), STy_) of
      <{'Left', Err}> when 'true' ->
        {'Left', Err}
      <{'Right', PatRes}> when 'true' ->
        let <PatEnv> = let <_Oa0> = call 'Nova.Compiler.Types':'applySubstToEnv'(call 'maps':'get'('sub', PatRes))
      in apply _Oa0(call 'maps':'get'('env', PatRes))
      in case apply 'inferGuard'/2(PatEnv, call 'maps':'get'('guard', Clause)) of
      <{'Left', Err}> when 'true' ->
        {'Left', Err}
      <{'Right', GuardRes}> when 'true' ->
        case apply 'infer'/2(call 'maps':'get'('env', GuardRes), call 'maps':'get'('body', Clause)) of
      <{'Left', Err}> when 'true' ->
        {'Left', Err}
      <{'Right', BodyRes}> when 'true' ->
        case let <_Oa0> = apply 'unifyEnv'/1(call 'maps':'get'('env', BodyRes))
      in apply apply _Oa0(let <_Oa0> = call 'Nova.Compiler.Types':'applySubst'(call 'maps':'get'('sub', BodyRes))
      in apply _Oa0(RTy_))(call 'maps':'get'('ty', BodyRes)) of
      <{'Left', Ue}> when 'true' ->
        {'Left', apply 'UnifyErr'/1(Ue)}
      <{'Right', S}> when 'true' ->
        let <NewSub> = let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(S)
      in apply _Oa0(let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(call 'maps':'get'('sub', BodyRes))
      in apply _Oa0(let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(call 'maps':'get'('sub', GuardRes))
      in apply _Oa0(let <_Oa0> = call 'Nova.Compiler.Types':'composeSubst'(call 'maps':'get'('sub', PatRes))
      in apply _Oa0(Sub))))
      in let <E_> = call 'maps':'merge'(E, с秕铘弪Ы俱犰ы狃螫骇珏臾ě泔躅翦颛汜祆ы狃螫骇珏臾ě孱雩嘛澌义螬轭狃痨ч铈弪渺狨箦笄铵胆釉以胚义篝五饔踱孱孱孱孱孱ч铈弪渺狨箦螫骢ㄅ铞鱼蝓粼义篚祠赠渺狨箦蟋深轸吁猢狃痨ч铈弪渺狨箦笄铵胆鱼蝓粼义篚祠赠蓬霈渺狨箦蟋深轸吁猢х踽蜾邃砒痱笤锷妲骢ㄟ邪汜箦咝褒镦见圯麒孱趄蹂砒痱轴颛Ⅴ钿彐轭邃见矍妩圯蔟麒孱趄蹂狃痨黩狃组翳嗅趑弪钋踽蜾螫波汜祆ы狃螫骇珏臾ě珲狎潴К清┈汜祆ы狃螫骇珏臾ě怙澌К清┅见矍妩义篝蔟麒孱趄蹂戾寂祗迮痱狃痨х踽蜾邃砒痱笤锷妲报义篝轭戾荚桢盥镤狃痨黩狃组翳嗅趑弪钋踽蜾螫波汜祆ы狃螫骇珏臾ě珲狎潴К清┈汜祆ы狃螫骇珏臾ě怙澌К清┅轭戾济镱渚狃痨х踽蜾笤锩镱溟糸镱Н报汜祆ы狃螫骇珏臾ě珲狎潴К清┅轭砒痱涉К蔑钿澡孱嘛澌澎箦砒痱孱х踽蜾笤锩镱溟糸镱Н骢ㄟ邪汜箦咝褒镦见圯麒孱趄蹂砒痱轴颛Ⅳ蝓澧见矍泓圯蔟麒孱趄蹂狃痨х踽蜾渺狨箦燥蔑钿砒痱Н报倾见矍泓义篝蔟麒孱趄蹂砒痱麻钕皈Ζ狃痨х踽蜾渺狨箦燥蔑钿砒痱Н报倾┈狃痨х踽蜾笤锩镱溟糸镱Н报义篝孱х踽蜾渺狨箦燥蔑钿砒痱Н骢ㄟ邪汜箦咝褒镦见酋狎渑痱К琵麒孱趄蹂见酋狎湫狒К咦艾咦饼麒孱趄蹂砒痱轴颛Ⅳ蝓澧孱黩狃组翳嗅趑弪钋踽蜾螫骢ㄇ踽蜾蟋嘛澌戾趄邈ч笮狒翦蝾酋狎洄骢ㄟ贪汜箦咛褒镦见酋狎湫狒К咦艾咦饼麒孱趄蹂趄蹂见咦褒麒孱趄蹂ф犰箦孱轭戾夹狒翦蝾酋狎潴汜祆尼翎涕篝Шф殪翦颛ㄦ躅ㄟ玩癌狃痨ч笮狒翦蝾酋狎洄报咄姘┈酋狎潴轭狃痨р蹰熹嗅趑弪钋踽蜾冕箦螫波嗅趑弪钋踽蜾蟋嘛澌р蹰熹嗅趑弪钋踽蜾冕箦螫骢ㄟ邪咝暴汜箦咝艾咝饼镦见圯嘛澌麒孱趄蹂嘛澌见埯酋狎湫狒К嗅衄鱼蝓糸铄妪义篝莠嘛澌麒孱趄蹂砒痱冕箦К鱼蝓糸铄瀣埝ю狒翦蝾Ы拘狒р镤Ы踞痧禊р蹰熹嗅趑弪钋踽蜾冕箦螫波义篝嘛澌┈х踽蜾Ы晶物翳轭绉圯蔟见圻装义篝莠嘛澌麒孱趄蹂狃痨р蹰熹嗅趑弪钋踽蜾冕箦螫波义篝嘛澌孱с桢汶契钽糸镱Н骢ㄅ铞契钽戾趄邈ч笮灬沐栾熹弪Н骢ㄟ贪汜箦咛褒镦见г轴颛增麒孱趄蹂汜箦汜祆у蜢犷绉骇窘Ж汜祆ы狃螫骇珏臾ě殇К增┈癌镦姬趄蹂Ь麒孱趄蹂汜祆у蜢犷绉骇胶涧ㄣ犰尼翎郁蜷铉Ш翎脲Ж超汜祆ы狃螫骇珏臾ě钺礤К增┅㈡钸歼麒孱趄蹂ф犰箦孱见咦褒麒孱趄蹂ф犰箦孱轭戾歼体舭戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇骝弩柚狎Ж蓬雯轭狃痨呦岚ㄣ犰у蜢犷绉骇Ж㈡钸汜祆ы狃螫骇珏臾ě钺礤К契钽┅轭汜箦咛弭镦见г躔戾К契钽增蓬霰麒孱趄蹂戾计躅阍г轴颛契钽增轭戾悸镤汜箦汜祆ы狃螫骇珏臾ě珲狎潴К契钽镦价菥麒孱趄蹂汜祆ы狃螫骇珏臾ě怙澌К契钽歼装麒孱趄蹂狃痨х踽蜾邃砒痱笤锷妲报汜祆ы狃螫骇珏臾ě珲狎潴К契钽┅孱轭戾荚屙鹩汨屙寰戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇黼鱼桢礤Ж圯轭狃痨呦岚ㄆ躅阍轭戾寂痱汜箦汜祆ы狃螫骇珏臾ě疳蜥礤翦蝮К契钽镦价菥麒孱趄蹂嘛澌歼装麒孱趄蹂砒痱提礅溽К汜祆ы狃螫骇珏臾ě疳蜥礤翦蝮К契钽┈嘛澌孱轭戾寂铞组翳契钽戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇屮翦钿蓬雩ㄅ铞暴轭狃痨狃痨呦岚ㄣ犰ы狃螫骇珏臾ě钺礤К契钽┅ㄔ屙鹩汨屙濠轭汜箦狃痨ч铈弪Н波蓬鲎轸杵躅悻砒痱镦见体骠К琵麒孱趄蹂体骠К琵见б殓梏К义簖麒孱趄蹂汜箦戾歼厢熬狃痨躅殒蓬雩报汜祆ы狃螫骇珏臾ě孱雩义螬轭狃痨狃痨呦岚戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇狃痨吁怏臾ㄣ犰ы狃螫骇珏臾ě篚猝义螬轭狃痨呦岚ㄆ躅阍┅ㄣ犰ы狃螫骇珏臾ě豉К义螬镦见体骠К斟麒孱趄蹂体骠К狃痨д铋纟膨颛报斟见б殓梏К育麒孱趄蹂戾计轭犰吁饩戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇泔眇矬逵踱篝Ж萤轭狃痨呦岚ㄣ犰ы狃螫骇珏臾ě篚猝义螬轭戾加殓鱼桢礤戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇祜镫躔蓬雩ㄅ铞轭狃痨呦岚ㄣ犰ы狃螫骇珏臾ě钺礤К契钽┅轭戾计轭犰赠戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇狃痨吁怏臾ㄆ轭犰吁猢轭狃痨呦岚ㄣ犰ы狃螫骇珏臾ě豉К义螬轭戾加汨屙寰汜箦娱缬汨屙镦见术篝К娱琮麒孱趄蹂汜箦汜祆у蜢犷绉骇铒臾ㄡ痧禊ч笮灬沐栾熹弪Н报汜祆ы狃螫骇珏臾ě豉К娱绌┅镦姬趄蹂Ь麒孱趄蹂娱歼麒孱趄蹂狃痨х孱弪犰辁濮波汜祆ы狃螫骇珏臾ě孱雩义螬崎钺煸孱歼装麒孱趄蹂狃痨х孱弪犰辁濮波汜祆ы狃螫骇珏臾ě孱雩义螬崎钺煸孱轭б殓梏К筱桢礤Ы居汨屙瀣у铞Ы眷弭歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇屮翦钿蓬雩ㄣ犰ы狃螫骇珏臾ě孱雩义螬轭狃痨狃痨呦岚ㄣ犰ы狃螫骇珏臾ě钺礤К契钽┅ㄓ汨屙濠
    end
    end
      end

'checkDecl'/2 =
  fun (_P0, _P1) ->
    case {_P0, _P1} of
      <{Env, {'DeclFunction', Func}}> when 'true' ->
        case apply 'checkFunction'/2(Env, Func) of
      <{'Left', E}> when 'true' ->
        {'Left', E}
      <{'Right', R}> when 'true' ->
        {'Right', call 'maps':'get'('env', R)}
    end
      <{Env, {'DeclTypeSig', _W0}}> when 'true' ->
        {'Right', Env}
      <{Env, {'DeclDataType', Dt}}> when 'true' ->
        {'Right', apply 'checkDataType'/2(Env, Dt)}
      <{Env, {'DeclTypeAlias', Ta}}> when 'true' ->
        {'Right', apply 'checkTypeAlias'/2(Env, Ta)}
      <{Env, {'DeclTypeClass', Tc}}> when 'true' ->
        {'Right', apply 'checkTypeClass'/2(Env, Tc)}
      <{Env, {'DeclInfix', Inf}}> when 'true' ->
        case let <_Oa0> = call 'Nova.Compiler.Types':'lookupEnv'(Env)
      in apply _Oa0(call 'maps':'get'('functionName', Inf)) of
      <{'Just', Scheme}> when 'true' ->
        {'Right', let <_Oa0> = call 'Nova.Compiler.Types':'extendEnv'(Env)
      in apply apply _Oa0(call 'maps':'get'('operator', Inf))(Scheme)}
      <'Nothing'> when 'true' ->
        {'Right', Env}
    end
      <{Env, _W0}> when 'true' ->
        {'Right', Env}
    end

'checkTypeClass'/2 =
  fun (Env, Tc) ->
    letrec 'addMethod'/2 = fun (E, Sig) ->
      let <VarPairs> = call 'Data.Array':'mapWithIndex'(fun (I, V) ->
      call 'Data.Tuple':'Tuple'(V, let <_Oa0> = call 'Nova.Compiler.Types':'mkTVar'(call 'erlang':'+'(call 'maps':'get'('counter', E), I))
      in apply _Oa0(V)), call 'Data.Array':'fromFoldable'(call 'maps':'get'('typeVars', Tc)))
      in let <VarMap> = call 'Data.Map':'fromFoldable'(VarPairs)
      in let <MethodType> = apply 'typeExprToType'/2(VarMap, call 'maps':'get'('ty', Sig))
      in let <Scheme> = let <_Oa0> = call 'Nova.Compiler.Types':'mkScheme'(call 'lists':'map'(call 'Data.Tuple':'snd'(), VarPairs))
      in apply _Oa0(MethodType)
      in let <_Oa0> = call 'Nova.Compiler.Types':'extendEnv'(E)
      in apply apply _Oa0(call 'maps':'get'('name', Sig))(Scheme)
      in call 'Data.Array':'foldl'(fun (_Mf0, _Mf1) -> apply 'addMethod'/2(_Mf0, _Mf1), Env, call 'Data.Array':'fromFoldable'(call 'maps':'get'('methods', Tc)))

'checkDataType'/2 =
  fun (Env, Dt) ->
    apply 'checkDataTypeWithAllAliases'/4(call 'Data.Map':'empty'(), call 'Data.Map':'empty'(), Env, Dt)

'checkDataTypeWithAliases'/3 =
  fun (AliasMap, Env, Dt) ->
    apply 'checkDataTypeWithAllAliases'/4(AliasMap, call 'Data.Map':'empty'(), Env, Dt)

'checkDataTypeWithAllAliases'/4 =
  fun (AliasMap, ParamAliasMap, Env, Dt) ->
    let <TypeVarPairs> = call 'Data.Array':'mapWithIndex'(fun (I, V) ->
      call 'Data.Tuple':'Tuple'(V, let <_Oa0> = call 'Nova.Compiler.Types':'mkTVar'(call 'erlang':'-'(call 'erlang':'+'(I, 1)))
      in apply _Oa0(V)), call 'Data.Array':'fromFoldable'(call 'maps':'get'('typeVars', Dt)))
      in let <TypeVarMap> = call 'Data.Map':'fromFoldable'(TypeVarPairs)
      in let <TypeArgs> = call 'lists':'map'(fun (_L0) ->
      case {_L0} of
        <{{'Tuple', _W0, Tv}}> when 'true' -> {'TyVar', Tv}
      end, TypeVarPairs)
      in let <ResultType> = {'TyCon', let <_Oa0> = call 'Nova.Compiler.Types':'mkTCon'(call 'maps':'get'('name', Dt))
      in apply _Oa0(TypeArgs)}
      in letrec 'addConstructor'/2 = fun (E, Con) ->
      let <ConType> = apply 'buildConstructorTypeWithAllAliases'/5(AliasMap, ParamAliasMap, TypeVarMap, call 'maps':'get'('fields', Con), ResultType)
      in let <ConScheme> = let <_Oa0> = call 'Nova.Compiler.Types':'mkScheme'(call 'lists':'map'(call 'Data.Tuple':'snd'(), TypeVarPairs))
      in apply _Oa0(ConType)
      in let <_Oa0> = call 'Nova.Compiler.Types':'extendEnv'(E)
      in apply apply _Oa0(call 'maps':'get'('name', Con))(ConScheme)
      in call 'Data.Array':'foldl'(fun (_Mf0, _Mf1) -> apply 'addConstructor'/2(_Mf0, _Mf1), Env, call 'Data.Array':'fromFoldable'(call 'maps':'get'('constructors', Dt)))

'checkNewtypeWithAliases'/3 =
  fun (AliasMap, Env, Nt) ->
    apply 'checkNewtypeWithAllAliases'/4(AliasMap, call 'Data.Map':'empty'(), Env, Nt)

'checkNewtypeWithAllAliases'/4 =
  fun (AliasMap, ParamAliasMap, Env, Nt) ->
    let <TypeVarPairs> = call 'Data.Array':'mapWithIndex'(fun (I, V) ->
      call 'Data.Tuple':'Tuple'(V, let <_Oa0> = call 'Nova.Compiler.Types':'mkTVar'(call 'erlang':'-'(call 'erlang':'+'(I, 1)))
      in apply _Oa0(V)), call 'Data.Array':'fromFoldable'(call 'maps':'get'('typeVars', Nt)))
      in let <TypeVarMap> = call 'Data.Map':'fromFoldable'(TypeVarPairs)
      in let <TypeArgs> = call 'lists':'map'(fun (_L0) ->
      case {_L0} of
        <{{'Tuple', _W0, Tv}}> when 'true' -> {'TyVar', Tv}
      end, TypeVarPairs)
      in let <ResultType> = {'TyCon', let <_Oa0> = call 'Nova.Compiler.Types':'mkTCon'(call 'maps':'get'('name', Nt))
      in apply _Oa0(TypeArgs)}
      in let <WrappedTy> = apply 'typeExprToTypeWithAllAliases'/4(AliasMap, ParamAliasMap, TypeVarMap, call 'maps':'get'('wrappedType', Nt))
      in let <ConType> = let <_Oa0> = call 'Nova.Compiler.Types':'tArrow'(WrappedTy)
      in apply _Oa0(ResultType)
      in let <ConScheme> = let <_Oa0> = call 'Nova.Compiler.Types':'mkScheme'(call 'lists':'map'(call 'Data.Tuple':'snd'(), TypeVarPairs))
      in apply _Oa0(ConType)
      in let <_Oa0> = call 'Nova.Compiler.Types':'extendEnv'(Env)
      in apply apply _Oa0(call 'maps':'get'('constructor', Nt))(ConScheme)

'buildConstructorTypeGo'/3 =
  fun (_P0, _P1, _P2) ->
    case {_P0, _P1, _P2} of
      <{_W0, ResultType, []}> when 'true' ->
        ResultType
      <{VarMap, ResultType, [Field|Rest]}> when 'true' ->
        let <FieldTy> = apply 'typeExprToType'/2(VarMap, call 'maps':'get'('ty', Field))
      in let <_Oa0> = call 'Nova.Compiler.Types':'tArrow'(FieldTy)
      in apply _Oa0(apply 'buildConstructorTypeGo'/3(VarMap, ResultType, Rest))
    end

'buildConstructorType'/3 =
  fun (VarMap, Fields, ResultType) ->
    apply 'buildConstructorTypeGo'/3(VarMap, ResultType, Fields)

'buildConstructorTypeWithAliasesGo'/4 =
  fun (_P0, _P1, _P2, _P3) ->
    case {_P0, _P1, _P2, _P3} of
      <{_W0, _W1, ResultType, []}> when 'true' ->
        ResultType
      <{AliasMap, VarMap, ResultType, [Field|Rest]}> when 'true' ->
        let <FieldTy> = apply 'typeExprToTypeWithAliases'/3(AliasMap, VarMap, call 'maps':'get'('ty', Field))
      in let <_Oa0> = call 'Nova.Compiler.Types':'tArrow'(FieldTy)
      in apply _Oa0(apply 'buildConstructorTypeWithAliasesGo'/4(AliasMap, VarMap, ResultType, Rest))
    end

'buildConstructorTypeWithAliases'/4 =
  fun (AliasMap, VarMap, Fields, ResultType) ->
    apply 'buildConstructorTypeWithAliasesGo'/4(AliasMap, VarMap, ResultType, Fields)

'buildConstructorTypeWithAllAliasesGo'/5 =
  fun (_P0, _P1, _P2, _P3, _P4) ->
    case {_P0, _P1, _P2, _P3, _P4} of
      <{_W0, _W1, _W2, ResultType, []}> when 'true' ->
        ResultType
      <{AliasMap, ParamAliasMap, VarMap, ResultType, [Field|Rest]}> when 'true' ->
        let <FieldTy> = apply 'typeExprToTypeWithAllAliases'/4(AliasMap, ParamAliasMap, VarMap, call 'maps':'get'('ty', Field))
      in let <_Oa0> = call 'Nova.Compiler.Types':'tArrow'(FieldTy)
      in apply _Oa0(apply 'buildConstructorTypeWithAllAliasesGo'/5(AliasMap, ParamAliasMap, VarMap, ResultType, Rest))
    end

'buildConstructorTypeWithAllAliases'/5 =
  fun (AliasMap, ParamAliasMap, VarMap, Fields, ResultType) ->
    apply 'buildConstructorTypeWithAllAliasesGo'/5(AliasMap, ParamAliasMap, VarMap, ResultType, Fields)

'typeExprToTypeWithAliases'/3 =
  fun (AliasMap, VarMap, Expr) ->
    apply 'typeExprToTypeWithAllAliases'/4(AliasMap, call 'Data.Map':'empty'(), VarMap, Expr)

'typeExprToTypeWithAllAliases'/4 =
  fun (_P0, _P1, _P2, _P3) ->
    case {_P0, _P1, _P2, _P3} of
      <{AliasMap, ParamAliasMap, VarMap, {'TyExprVar', Name}}> when 'true' ->
        case call 'Data.Map':'lookup'(Name, VarMap) of
      <{'Just', Tv}> when 'true' ->
        {'TyVar', Tv}
      <'Nothing'> when 'true' ->
        {'TyCon', let <_Oa0> = call 'Nova.Compiler.Types':'mkTCon'(Name)
      in apply _Oa0([])}
    end
      <{AliasMap, ParamAliasMap, VarMap, {'TyExprCon', Name}}> when 'true' ->
        let <UnqualifiedName> = case call 'Data.String':'lastIndexOf'(call 'Data.String':'Pattern'("."), Name) of
      <{'Just', Idx}> when 'true' ->
        call 'Data.String':'drop'(call 'erlang':'+'(Idx, 1), Name)
      <'Nothing'> when 'true' ->
        Name
    end
      in letrec 'lookupInAliasMap'/1 = fun (Nm) ->
      call 'Data.Map':'lookup'(Nm, AliasMap)
       'lookupInParamAliasMap'/1 = fun (Nm) ->
      call 'Data.Map':'lookup'(Nm, ParamAliasMap)
       'tryLookup'/1 = fun (Nm) ->
      case apply 'lookupInAliasMap'/1(Nm) of
      <{'Just', Ty}> when 'true' ->
        {'Just', Ty}
      <'Nothing'> when 'true' ->
        case apply 'lookupInParamAliasMap'/1(Nm) of
      <{'Just', Info}> when 'true' ->
        let <Ps> = call 'Nova.Compiler.Types':'getAliasInfoParams'(Info)
      in let <BodyExpr> = call 'Nova.Compiler.Types':'getAliasInfoBody'(Info)
      in case call 'Data.Array':'null'(Ps) of
      <'true'> when 'true' -> {'Just', apply 'typeExprToTypeWithAllAliases'/4(AliasMap, ParamAliasMap, VarMap, BodyExpr)}
      <'false'> when 'true' -> 'Nothing'
    end
      <'Nothing'> when 'true' ->
        'Nothing'
    end
    end
      in case apply 'tryLookup'/1(Name) of
      <{'Just', Ty}> when 'true' ->
        Ty
      <'Nothing'> when 'true' ->
        case apply 'tryLookup'/1(UnqualifiedName) of
      <{'Just', Ty}> when 'true' ->
        Ty
      <'Nothing'> when 'true' ->
        apply 'typeExprToType'/2(VarMap, {'TyExprCon', Name})
    end
    end
      <{AliasMap, ParamAliasMap, VarMap, {'TyExprApp', F, Arg}}> when 'true' ->
        letrec 'applyTypeArg'/5 = fun (AMap, PaMap, VMap, Func, ArgExpr) ->
      let <ArgTy> = apply 'typeExprToTypeWithAllAliases'/4(AMap, PaMap, VMap, ArgExpr)
      in case apply 'typeExprToTypeWithAllAliases'/4(AMap, PaMap, VMap, Func) of
      <{'TyCon', Tc}> when 'true' ->
        {'TyCon', ь犴濮骄汜祆ы狃螫骇珏臾ě钺礤К糟┈п蜱螫骄汜祆尼翎硫蜥Ш箢镢Ж汜祆ы狃螫骇珏臾ě狎珞К糟┈硫缭
      <Other> when 'true' ->
        call 'Nova.Compiler.Types':'mkTyApp'(Other, ArgTy)
    end
      in case apply 'collectTypeApp'/1({'TyExprApp', F, Arg}) of
      <{'Tuple', ConName, Args}> when 'true' ->
        case call 'Data.Map':'lookup'(ConName, ParamAliasMap) of
      <{'Just', Info}> when 'true' ->
        let <Ps> = call 'Nova.Compiler.Types':'getAliasInfoParams'(Info)
      in let <BodyExpr> = call 'Nova.Compiler.Types':'getAliasInfoBody'(Info)
      in case call 'erlang':'=:='(call 'Data.Array':'length'(Ps), call 'Data.Array':'length'(Args)) of
      <'true'> when 'true' -> let <ArgTypes> = call 'lists':'map'(fun (_Pc0) -> apply 'typeExprToTypeWithAllAliases'/4(AliasMap, ParamAliasMap, VarMap, _Pc0), Args)
      in let <ParamSubst> = call 'Data.Map':'fromFoldable'(call 'Data.Array':'zip'(Ps, ArgTypes))
      in apply 'substituteTypeExpr'/4(AliasMap, ParamAliasMap, ParamSubst, BodyExpr)
      <'false'> when 'true' -> apply 'applyTypeArg'/5(AliasMap, ParamAliasMap, VarMap, F, Arg)
    end
      <_W0> when 'true' ->
        apply 'applyTypeArg'/5(AliasMap, ParamAliasMap, VarMap, F, Arg)
    end
    end
      <{AliasMap, ParamAliasMap, VarMap, {'TyExprArrow', A, B}}> when 'true' ->
        let <_Oa0> = call 'Nova.Compiler.Types':'tArrow'(apply 'typeExprToTypeWithAllAliases'/4(AliasMap, ParamAliasMap, VarMap, A))
      in apply _Oa0(apply 'typeExprToTypeWithAllAliases'/4(AliasMap, ParamAliasMap, VarMap, B))
      <{AliasMap, ParamAliasMap, VarMap, {'TyExprRecord', Fields, MaybeRow}}> when 'true' ->
        let <FieldMap> = call 'Data.Map':'fromFoldable'(call 'lists':'map'(fun (_L0) ->
      case {_L0} of
        <{{'Tuple', L, T}}> when 'true' -> call 'Data.Tuple':'Tuple'(L, apply 'typeExprToTypeWithAllAliases'/4(AliasMap, ParamAliasMap, VarMap, T))
      end, Fields))
      in let <Row> = case MaybeRow of
      <{'Just', R}> when 'true' ->
        case call 'Data.Map':'lookup'(R, VarMap) of
      <{'Just', Tv}> when 'true' ->
        {'Just', Tv}
      <'Nothing'> when 'true' ->
        'Nothing'
    end
      <'Nothing'> when 'true' ->
        'Nothing'
    end
      in {'TyRecord', ф殄熹螫骄崎屐渫狃蝻鳔骄绎鼾
      <{AliasMap, ParamAliasMap, VarMap, {'TyExprForAll', Vars, T}}> when 'true' ->
        let <VarList> = call 'Data.Array':'mapWithIndex'(fun (I, Name) ->
      call 'Data.Tuple':'Tuple'(Name, let <_Oa0> = call 'Nova.Compiler.Types':'mkTVar'(call 'erlang':'-'(call 'erlang':'+'(I, 1)))
      in apply _Oa0(Name)), call 'Data.Array':'fromFoldable'(Vars))
      in let <NewVarMap> = call 'Data.Map':'union'(call 'Data.Map':'fromFoldable'(VarList), VarMap)
      in apply 'typeExprToTypeWithAllAliases'/4(AliasMap, ParamAliasMap, NewVarMap, T)
      <{AliasMap, ParamAliasMap, VarMap, {'TyExprConstrained', _W0, T}}> when 'true' ->
        apply 'typeExprToTypeWithAllAliases'/4(AliasMap, ParamAliasMap, VarMap, T)
      <{AliasMap, ParamAliasMap, VarMap, {'TyExprParens', T}}> when 'true' ->
        apply 'typeExprToTypeWithAllAliases'/4(AliasMap, ParamAliasMap, VarMap, T)
      <{AliasMap, ParamAliasMap, VarMap, {'TyExprTuple', Ts}}> when 'true' ->
        call 'Nova.Compiler.Types':'tTuple'(call 'Data.Array':'fromFoldable'(call 'lists':'map'(fun (_Pc0) -> apply 'typeExprToTypeWithAllAliases'/4(AliasMap, ParamAliasMap, VarMap, _Pc0), Ts)))
    end

'typeExprToTypeWithEnv'/5 =
  fun (_P0, _P1, _P2, _P3, _P4) ->
    case {_P0, _P1, _P2, _P3, _P4} of
      <{Env, AliasMap, ParamAliasMap, VarMap, {'TyExprVar', Name}}> when 'true' ->
        case call 'Data.Map':'lookup'(Name, VarMap) of
      <{'Just', Tv}> when 'true' ->
        {'TyVar', Tv}
      <'Nothing'> when 'true' ->
        {'TyCon', let <_Oa0> = call 'Nova.Compiler.Types':'mkTCon'(Name)
      in apply _Oa0([])}
    end
      <{Env, AliasMap, ParamAliasMap, VarMap, {'TyExprCon', Name}}> when 'true' ->
        let <UnqualifiedName> = case call 'Data.String':'lastIndexOf'(call 'Data.String':'Pattern'("."), Name) of
      <{'Just', Idx}> when 'true' ->
        call 'Data.String':'drop'(call 'erlang':'+'(Idx, 1), Name)
      <'Nothing'> when 'true' ->
        Name
    end
      in letrec 'tryLookup'/1 = fun (Nm) ->
      case call 'Data.Map':'lookup'(Nm, AliasMap) of
      <{'Just', Ty}> when 'true' ->
        {'Just', Ty}
      <'Nothing'> when 'true' ->
        case call 'Data.Map':'lookup'(Nm, ParamAliasMap) of
      <{'Just', Info}> when 'true' ->
        let <Ps> = call 'Nova.Compiler.Types':'getAliasInfoParams'(Info)
      in let <BodyExpr> = call 'Nova.Compiler.Types':'getAliasInfoBody'(Info)
      in case call 'Data.Array':'null'(Ps) of
      <'true'> when 'true' -> {'Just', apply 'typeExprToTypeWithEnv'/5(Env, AliasMap, ParamAliasMap, VarMap, BodyExpr)}
      <'false'> when 'true' -> 'Nothing'
    end
      <_W0> when 'true' ->
        'Nothing'
    end
    end
       'tryEnvLookup'/1 = fun (Nm) ->
      let <_Oa0> = call 'Nova.Compiler.Types':'lookupTypeAlias'(Env)
      in apply _Oa0(Nm)
      in case apply 'tryLookup'/1(Name) of
      <{'Just', Ty}> when 'true' ->
        Ty
      <'Nothing'> when 'true' ->
        case apply 'tryLookup'/1(UnqualifiedName) of
      <{'Just', Ty}> when 'true' ->
        Ty
      <'Nothing'> when 'true' ->
        case apply 'tryEnvLookup'/1(Name) of
      <{'Just', Ty}> when 'true' ->
        Ty
      <'Nothing'> when 'true' ->
        case apply 'tryEnvLookup'/1(UnqualifiedName) of
      <{'Just', Ty}> when 'true' ->
        Ty
      <'Nothing'> when 'true' ->
        apply 'typeExprToType'/2(VarMap, {'TyExprCon', Name})
    end
    end
    end
    end
      <{Env, AliasMap, ParamAliasMap, VarMap, {'TyExprApp', F, Arg}}> when 'true' ->
        case apply 'collectTypeApp'/1({'TyExprApp', F, Arg}) of
      <{'Tuple', ConName, Args}> when 'true' ->
        case call 'Data.Map':'lookup'(ConName, ParamAliasMap) of
      <{'Just', Info}> when 'true' ->
        case call 'erlang':'=:='(call 'Data.Array':'length'(call 'Nova.Compiler.Types':'getAliasInfoParams'(Info)), call 'Data.Array':'length'(Args)) of
          <'true'> when 'true' -> let <ArgTypes> = call 'lists':'map'(fun (_Pc0) -> apply 'typeExprToTypeWithEnv'/5(Env, AliasMap, ParamAliasMap, VarMap, _Pc0), Args)
      in let <ParamSubst> = call 'Data.Map':'fromFoldable'(call 'Data.Array':'zip'(call 'Nova.Compiler.Types':'getAliasInfoParams'(Info), ArgTypes))
      in apply 'substituteTypeExpr'/4(AliasMap, ParamAliasMap, ParamSubst, call 'Nova.Compiler.Types':'getAliasInfoBody'(Info))
          <_> when 'true' -> case apply 'typeExprToTypeWithEnv'/5(Env, AliasMap, ParamAliasMap, VarMap, F) of
      <{'TyCon', Tc}> when 'true' ->
        {'TyCon', ь犴濮骄汜祆ы狃螫骇珏臾ě钺礤К糟┈п蜱螫骄汜祆尼翎硫蜥Ш箢镢Ж汜祆ы狃螫骇珏臾ě狎珞К糟┈狃痨豉疱砒痱燥赠疱组翳蓬雩胆蓬霈领獒笸狃嗅蜥砹扉狍歪瓞轴蛲狃硫绌
      <Other> when 'true' ->
        Other
    end
        end
      <_W0> when 'true' ->
        case apply 'typeExprToTypeWithEnv'/5(Env, AliasMap, ParamAliasMap, VarMap, F) of
      <{'TyCon', Tc}> when 'true' ->
        {'TyCon', ь犴濮骄汜祆ы狃螫骇珏臾ě钺礤К糟┈п蜱螫骄汜祆尼翎硫蜥Ш箢镢Ж汜祆ы狃螫骇珏臾ě狎珞К糟┈狃痨豉疱砒痱燥赠疱组翳蓬雩胆蓬霈领獒笸狃嗅蜥砹扉狍歪瓞轴蛲狃硫绌
      <Other> when 'true' ->
        Other
    end
    end
    end
      <{Env, AliasMap, ParamAliasMap, VarMap, {'TyExprArrow', A, B}}> when 'true' ->
        let <_Oa0> = call 'Nova.Compiler.Types':'tArrow'(apply 'typeExprToTypeWithEnv'/5(Env, AliasMap, ParamAliasMap, VarMap, A))
      in apply _Oa0(apply 'typeExprToTypeWithEnv'/5(Env, AliasMap, ParamAliasMap, VarMap, B))
      <{Env, AliasMap, ParamAliasMap, VarMap, {'TyExprRecord', Fields, MaybeRow}}> when 'true' ->
        let <FieldMap> = call 'Data.Map':'fromFoldable'(call 'lists':'map'(fun (_L0) ->
      case {_L0} of
        <{{'Tuple', L, T}}> when 'true' -> call 'Data.Tuple':'Tuple'(L, apply 'typeExprToTypeWithEnv'/5(Env, AliasMap, ParamAliasMap, VarMap, T))
      end, Fields))
      in let <Row> = case MaybeRow of
      <{'Just', R}> when 'true' ->
        case call 'Data.Map':'lookup'(R, VarMap) of
      <{'Just', Tv}> when 'true' ->
        {'Just', Tv}
      <'Nothing'> when 'true' ->
        'Nothing'
    end
      <'Nothing'> when 'true' ->
        'Nothing'
    end
      in {'TyRecord', ф殄熹螫骄崎屐渫狃蝻鳔骄绎鼾
      <{Env, AliasMap, ParamAliasMap, VarMap, {'TyExprForAll', Vars, T}}> when 'true' ->
        let <VarList> = call 'Data.Array':'mapWithIndex'(fun (I, Name) ->
      call 'Data.Tuple':'Tuple'(Name, let <_Oa0> = call 'Nova.Compiler.Types':'mkTVar'(call 'erlang':'-'(call 'erlang':'+'(I, 1)))
      in apply _Oa0(Name)), call 'Data.Array':'fromFoldable'(Vars))
      in let <NewVarMap> = call 'Data.Map':'union'(call 'Data.Map':'fromFoldable'(VarList), VarMap)
      in apply 'typeExprToTypeWithEnv'/5(Env, AliasMap, ParamAliasMap, NewVarMap, T)
      <{Env, AliasMap, ParamAliasMap, VarMap, {'TyExprConstrained', _W0, T}}> when 'true' ->
        apply 'typeExprToTypeWithEnv'/5(Env, AliasMap, ParamAliasMap, VarMap, T)
      <{Env, AliasMap, ParamAliasMap, VarMap, {'TyExprParens', T}}> when 'true' ->
        apply 'typeExprToTypeWithEnv'/5(Env, AliasMap, ParamAliasMap, VarMap, T)
      <{Env, AliasMap, ParamAliasMap, VarMap, {'TyExprTuple', Ts}}> when 'true' ->
        call 'Nova.Compiler.Types':'tTuple'(call 'Data.Array':'fromFoldable'(call 'lists':'map'(fun (_Pc0) -> apply 'typeExprToTypeWithEnv'/5(Env, AliasMap, ParamAliasMap, VarMap, _Pc0), Ts)))
    end

'collectTypeApp'/1 =
  fun (_P0) ->
    case {_P0} of
      <{{'TyExprCon', Name}}> when 'true' ->
        call 'Data.Tuple':'Tuple'(Name, [])
      <{{'TyExprApp', F, Arg}}> when 'true' ->
        let <_Let0> = apply 'collectTypeApp'/1(F)
      in case _Let0 of
        <{'Tuple', Name, Args}> when 'true' -> call 'Data.Tuple':'Tuple'(Name, call 'Data.Array':'snoc'(Args, Arg))
      end
      <{_W0}> when 'true' ->
        call 'Data.Tuple':'Tuple'("", [])
    end

'substituteTypeExpr'/4 =
  fun (_P0, _P1, _P2, _P3) ->
    case {_P0, _P1, _P2, _P3} of
      <{AliasMap, ParamAliasMap, ParamSubst, {'TyExprVar', Name}}> when 'true' ->
        case call 'Data.Map':'lookup'(Name, ParamSubst) of
      <{'Just', Ty}> when 'true' ->
        Ty
      <'Nothing'> when 'true' ->
        {'TyCon', let <_Oa0> = call 'Nova.Compiler.Types':'mkTCon'(Name)
      in apply _Oa0([])}
    end
      <{AliasMap, ParamAliasMap, ParamSubst, {'TyExprCon', Name}}> when 'true' ->
        case call 'Data.Map':'lookup'(Name, AliasMap) of
      <{'Just', Ty}> when 'true' ->
        Ty
      <'Nothing'> when 'true' ->
        apply 'typeExprToType'/2(call 'Data.Map':'empty'(), {'TyExprCon', Name})
    end
      <{AliasMap, ParamAliasMap, ParamSubst, {'TyExprApp', F, Arg}}> when 'true' ->
        case apply 'collectTypeApp'/1({'TyExprApp', F, Arg}) of
      <{'Tuple', ConName, Args}> when 'true' ->
        case call 'Data.Map':'lookup'(ConName, ParamAliasMap) of
      <{'Just', Info}> when 'true' ->
        case call 'erlang':'=:='(call 'Data.Array':'length'(call 'Nova.Compiler.Types':'getAliasInfoParams'(Info)), call 'Data.Array':'length'(Args)) of
          <'true'> when 'true' -> let <ArgTypes> = call 'lists':'map'(fun (_Pc0) -> apply 'substituteTypeExpr'/4(AliasMap, ParamAliasMap, ParamSubst, _Pc0), Args)
      in let <NestedSubst> = call 'Data.Map':'fromFoldable'(call 'Data.Array':'zip'(call 'Nova.Compiler.Types':'getAliasInfoParams'(Info), ArgTypes))
      in apply 'substituteTypeExpr'/4(AliasMap, ParamAliasMap, NestedSubst, call 'Nova.Compiler.Types':'getAliasInfoBody'(Info))
          <_> when 'true' -> case apply 'substituteTypeExpr'/4(AliasMap, ParamAliasMap, ParamSubst, F) of
      <{'TyCon', Tc}> when 'true' ->
        {'TyCon', ь犴濮骄汜祆ы狃螫骇珏臾ě钺礤К糟┈п蜱螫骄汜祆尼翎硫蜥Ш箢镢Ж汜祆ы狃螫骇珏臾ě狎珞К糟┈狃痨篚怏糸趱翦赠疱砒痱Н川领獒笸狃嗅蜥砹扉狍歪瓞嗅蜥碛踱篝硫绌
      <Other> when 'true' ->
        Other
    end
        end
      <_W0> when 'true' ->
        case apply 'substituteTypeExpr'/4(AliasMap, ParamAliasMap, ParamSubst, F) of
      <{'TyCon', Tc}> when 'true' ->
        {'TyCon', ь犴濮骄汜祆ы狃螫骇珏臾ě钺礤К糟┈п蜱螫骄汜祆尼翎硫蜥Ш箢镢Ж汜祆ы狃螫骇珏臾ě狎珞К糟┈狃痨篚怏糸趱翦赠疱砒痱Н川领獒笸狃嗅蜥砹扉狍歪瓞嗅蜥碛踱篝硫绌
      <Other> when 'true' ->
        Other
    end
    end
    end
      <{AliasMap, ParamAliasMap, ParamSubst, {'TyExprArrow', A, B}}> when 'true' ->
        let <_Oa0> = call 'Nova.Compiler.Types':'tArrow'(apply 'substituteTypeExpr'/4(AliasMap, ParamAliasMap, ParamSubst, A))
      in apply _Oa0(apply 'substituteTypeExpr'/4(AliasMap, ParamAliasMap, ParamSubst, B))
      <{AliasMap, ParamAliasMap, ParamSubst, {'TyExprRecord', Fields, MaybeRow}}> when 'true' ->
        let <FieldMap> = call 'Data.Map':'fromFoldable'(call 'lists':'map'(fun (_L0) ->
      case {_L0} of
        <{{'Tuple', L, T}}> when 'true' -> call 'Data.Tuple':'Tuple'(L, apply 'substituteTypeExpr'/4(AliasMap, ParamAliasMap, ParamSubst, T))
      end, Fields))
      in {'TyRecord', ф殄熹螫骄崎屐渫狃蝻鳔骄物翳轭绉
      <{AliasMap, ParamAliasMap, ParamSubst, {'TyExprTuple', Ts}}> when 'true' ->
        call 'Nova.Compiler.Types':'tTuple'(call 'Data.Array':'fromFoldable'(call 'lists':'map'(fun (_Pc0) -> apply 'substituteTypeExpr'/4(AliasMap, ParamAliasMap, ParamSubst, _Pc0), Ts)))
      <{AliasMap, ParamAliasMap, ParamSubst, {'TyExprParens', T}}> when 'true' ->
        apply 'substituteTypeExpr'/4(AliasMap, ParamAliasMap, ParamSubst, T)
      <{AliasMap, ParamAliasMap, ParamSubst, {'TyExprForAll', _W0, T}}> when 'true' ->
        apply 'substituteTypeExpr'/4(AliasMap, ParamAliasMap, ParamSubst, T)
      <{AliasMap, ParamAliasMap, ParamSubst, {'TyExprConstrained', _W0, T}}> when 'true' ->
        apply 'substituteTypeExpr'/4(AliasMap, ParamAliasMap, ParamSubst, T)
    end

'typeExprToType'/2 =
  fun (_P0, _P1) ->
    case {_P0, _P1} of
      <{VarMap, {'TyExprVar', Name}}> when 'true' ->
        case call 'Data.Map':'lookup'(Name, VarMap) of
      <{'Just', Tv}> when 'true' ->
        {'TyVar', Tv}
      <'Nothing'> when 'true' ->
        {'TyCon', let <_Oa0> = call 'Nova.Compiler.Types':'mkTCon'(Name)
      in apply _Oa0([])}
    end
      <{VarMap, {'TyExprCon', Name}}> when 'true' ->
        case Name of
      <"_"> when 'true' ->
        {'TyVar', let <_Oa0> = call 'Nova.Compiler.Types':'mkTVar'(call 'erlang':'-'(999))
      in apply _Oa0("_")}
      <"Boolean"> when 'true' ->
        call 'Nova.Compiler.Types':'tBool'()
      <_W0> when 'true' ->
        {'TyCon', let <_Oa0> = call 'Nova.Compiler.Types':'mkTCon'(Name)
      in apply _Oa0([])}
    end
      <{VarMap, {'TyExprApp', F, Arg}}> when 'true' ->
        let <ArgTy> = apply 'typeExprToType'/2(VarMap, Arg)
      in case apply 'typeExprToType'/2(VarMap, F) of
      <{'TyCon', Tc}> when 'true' ->
        {'TyCon', ь犴濮骄汜祆ы狃螫骇珏臾ě钺礤К糟┈п蜱螫骄汜祆尼翎硫蜥Ш箢镢Ж汜祆ы狃螫骇珏臾ě狎珞К糟┈硫缭
      <Other> when 'true' ->
        call 'Nova.Compiler.Types':'mkTyApp'(Other, ArgTy)
    end
      <{VarMap, {'TyExprArrow', A, B}}> when 'true' ->
        let <_Oa0> = call 'Nova.Compiler.Types':'tArrow'(apply 'typeExprToType'/2(VarMap, A))
      in apply _Oa0(apply 'typeExprToType'/2(VarMap, B))
      <{VarMap, {'TyExprRecord', Fields, MaybeRow}}> when 'true' ->
        let <FieldMap> = call 'Data.Map':'fromFoldable'(call 'lists':'map'(fun (_L0) ->
      case {_L0} of
        <{{'Tuple', L, T}}> when 'true' -> call 'Data.Tuple':'Tuple'(L, apply 'typeExprToType'/2(VarMap, T))
      end, Fields))
      in let <Row> = case MaybeRow of
      <{'Just', R}> when 'true' ->
        case call 'Data.Map':'lookup'(R, VarMap) of
      <{'Just', Tv}> when 'true' ->
        {'Just', Tv}
      <'Nothing'> when 'true' ->
        'Nothing'
    end
      <'Nothing'> when 'true' ->
        'Nothing'
    end
      in {'TyRecord', ф殄熹螫骄崎屐渫狃蝻鳔骄绎鼾
      <{VarMap, {'TyExprForAll', Vars, T}}> when 'true' ->
        let <VarList> = apply 'listMapWithIndex'/2(fun (I, Name) ->
      call 'Data.Tuple':'Tuple'(Name, let <_Oa0> = call 'Nova.Compiler.Types':'mkTVar'(call 'erlang':'-'(call 'erlang':'+'(I, 1)))
      in apply _Oa0(Name)), Vars)
      in let <NewVarMap> = call 'Data.Map':'union'(call 'Data.Map':'fromFoldable'(VarList), VarMap)
      in apply 'typeExprToType'/2(NewVarMap, T)
      <{VarMap, {'TyExprConstrained', _W0, T}}> when 'true' ->
        apply 'typeExprToType'/2(VarMap, T)
      <{VarMap, {'TyExprParens', T}}> when 'true' ->
        apply 'typeExprToType'/2(VarMap, T)
      <{VarMap, {'TyExprTuple', Ts}}> when 'true' ->
        call 'Nova.Compiler.Types':'tTuple'(call 'Data.Array':'fromFoldable'(call 'lists':'map'(fun (_Pc0) -> apply 'typeExprToType'/2(VarMap, _Pc0), Ts)))
    end

'checkTypeAlias'/2 =
  fun (Env, Ta) ->
    let <Ty> = apply 'typeExprToTypeWithEnv'/5(Env, call 'Data.Map':'empty'(), call 'Data.Map':'empty'(), call 'Data.Map':'empty'(), call 'maps':'get'('ty', Ta))
      in let <Scheme> = let <_Oa0> = call 'Nova.Compiler.Types':'mkScheme'([])
      in apply _Oa0(Ty)
      in let <Env_> = let <_Oa0> = call 'Nova.Compiler.Types':'extendEnv'(Env)
      in apply apply _Oa0(call 'maps':'get'('name', Ta))(Scheme)
      in call 'Nova.Compiler.Types':'extendTypeAlias'(Env_, call 'maps':'get'('name', Ta), Ty)

'isRecordType'/1 =
  fun (_P0) ->
    case {_P0} of
      <{{'TyRecord', _W0}}> when 'true' ->
        'true'
      <{_W0}> when 'true' ->
        'false'
    end

'collectTypeNames'/1 =
  fun (_P0) ->
    case {_P0} of
      <{{'TyVar', _W0}}> when 'true' ->
        call 'Data.Set':'empty'()
      <{{'TyCon', Tc}}> when 'true' ->
        let <ArgsNames> = call 'Data.Array':'foldl'(fun (S, T) ->
      call 'Data.Set':'union'(S, apply 'collectTypeNames'/1(T)), call 'Data.Set':'empty'(), call 'maps':'get'('args', Tc))
      in call 'Data.Set':'insert'(call 'maps':'get'('name', Tc), ArgsNames)
      <{{'TyRecord', R}}> when 'true' ->
        let <FieldNames> = call 'Data.Map':'values'(call 'maps':'get'('fields', R))
      in let <FieldsSet> = call 'Data.Array':'foldl'(fun (S, T) ->
      call 'Data.Set':'union'(S, apply 'collectTypeNames'/1(T)), call 'Data.Set':'empty'(), call 'Data.Array':'fromFoldable'(FieldNames))
      in FieldsSet
      <{{'TyApp', F, Arg}}> when 'true' ->
        call 'Data.Set':'union'(apply 'collectTypeNames'/1(F), apply 'collectTypeNames'/1(Arg))
    end

'collectTypeExprNames'/1 =
  fun (_P0) ->
    case {_P0} of
      <{{'TyExprVar', _W0}}> when 'true' ->
        call 'Data.Set':'empty'()
      <{{'TyExprCon', Name}}> when 'true' ->
        call 'Data.Set':'singleton'(Name)
      <{{'TyExprApp', F, Arg}}> when 'true' ->
        call 'Data.Set':'union'(apply 'collectTypeExprNames'/1(F), apply 'collectTypeExprNames'/1(Arg))
      <{{'TyExprArrow', A, B}}> when 'true' ->
        call 'Data.Set':'union'(apply 'collectTypeExprNames'/1(A), apply 'collectTypeExprNames'/1(B))
      <{{'TyExprRecord', Fields, _W0}}> when 'true' ->
        call 'Data.Array':'foldl'(fun (_L0, _L1) ->
      case {_L0, _L1} of
        <{S, {'Tuple', _W0, T}}> when 'true' -> call 'Data.Set':'union'(S, apply 'collectTypeExprNames'/1(T))
      end, call 'Data.Set':'empty'(), call 'Data.Array':'fromFoldable'(Fields))
      <{{'TyExprForAll', _W0, T}}> when 'true' ->
        apply 'collectTypeExprNames'/1(T)
      <{{'TyExprConstrained', _W0, T}}> when 'true' ->
        apply 'collectTypeExprNames'/1(T)
      <{{'TyExprParens', T}}> when 'true' ->
        apply 'collectTypeExprNames'/1(T)
      <{{'TyExprTuple', Ts}}> when 'true' ->
        call 'Data.List':'foldl'(fun (S, T) ->
      call 'Data.Set':'union'(S, apply 'collectTypeExprNames'/1(T)), call 'Data.Set':'empty'(), Ts)
    end

'checkModuleSimple'/2 =
  fun (Env, Decls) ->
    apply 'checkModule'/3(call 'Nova.Compiler.Types':'defaultRegistry'(), Env, Decls)

'checkModule'/3 =
  fun (Registry, Env, Decls) ->
    let <ImportedAliases> = apply 'collectImportedAliases'/2(Registry, Decls)
      in let <Env1> = call 'Nova.Compiler.ImportProcessor':'processImports'(Registry, Env, Decls)
      in let <Env2> = apply 'processNonFunctionsWithAliases'/3(ImportedAliases, Env1, Decls)
      in let <Env3> = apply 'addFunctionPlaceholdersWithAliases'/3(ImportedAliases, Env2, Decls)
      in let <Env4> = apply 'processInfixDeclarations'/2(Env3, Decls)
      in apply 'withContext'/2("checkFunctionBodies", apply 'checkFunctionBodies'/2(Env4, Decls))

'typeCheckModule'/3 =
  fun (Registry, Env, Mod) ->
    let <Decls> = call 'Data.Array':'fromFoldable'(call 'maps':'get'('declarations', Mod))
      in case apply 'checkModule'/3(Registry, Env, Decls) of
      <{'Left', Err}> when 'true' ->
        {'Left', Err}
      <{'Right', Env_}> when 'true' ->
        {'Right', let <_Oa0> = call 'Nova.Compiler.Types':'mkTypedModule'(Mod)
      in apply _Oa0(Env_)}
    end

'processImports'/3 =
  fun (Registry, Env, Decls) ->
    letrec 'processImport'/2 = fun (_L0, _L1) ->
      case {_L0, _L1} of
        <{E, {'DeclImport', Imp}}> when 'true' -> apply 'processImportDecl'/3(Registry, E, Imp)
        <{E, _W0}> when 'true' -> E
      end
      in call 'Data.Array':'foldl'(fun (_Mf0, _Mf1) -> apply 'processImport'/2(_Mf0, _Mf1), Env, Decls)

'mergeExportsWithTypeAliases'/2 =
  fun (Env, Exports) ->
    let <Env1> = call 'Nova.Compiler.Types':'mergeExportsToEnv'(Env, Exports)
      in let <ModuleAliases> = case call 'Data.Map':'isEmpty'(call 'maps':'get'('expandedTypeAliases', Exports)) of
      <'true'> when 'true' -> apply 'expandModuleAliases'/1(call 'maps':'get'('typeAliases', Exports))
      <'false'> when 'true' -> call 'maps':'get'('expandedTypeAliases', Exports)
    end
      in letrec 'addIfRecordAlias'/2 = fun (_L0, _L1) ->
      case {_L0, _L1} of
        <{E, {'Tuple', Name, Ty}}> when 'true' -> case apply 'isRecordType'/1(Ty) of
      <'true'> when 'true' -> let <_Oa0> = call 'Nova.Compiler.Types':'extendTypeAlias'(E)
      in apply apply _Oa0(Name)(Ty)
      <'false'> when 'true' -> E
    end
      end
      in let <Env2> = call 'Data.Array':'foldl'(fun (_Mf0, _Mf1) -> apply 'addIfRecordAlias'/2(_Mf0, _Mf1), Env1, call 'Data.Map':'toUnfoldable'(ModuleAliases))
      in Env2

'processImportDecl'/3 =
  fun (Registry, Env, Imp) ->
    case let <_Oa0> = call 'Nova.Compiler.Types':'lookupModule'(Registry)
      in apply _Oa0(call 'maps':'get'('moduleName', Imp)) of
      <'Nothing'> when 'true' ->
        Env
      <{'Just', Exports}> when 'true' ->
        let <EnvWithQualified> = case call 'maps':'get'('alias', Imp) of
      <{'Just', Alias}> when 'true' ->
        call 'Nova.Compiler.Types':'mergeExportsToEnvWithPrefix'(Env, Exports, Alias)
      <'Nothing'> when 'true' ->
        let <LastPart> = case call 'Data.String':'lastIndexOf'(call 'Data.String':'Pattern'("."), call 'maps':'get'('moduleName', Imp)) of
      <'Nothing'> when 'true' ->
        call 'maps':'get'('moduleName', Imp)
      <{'Just', Idx}> when 'true' ->
        call 'Data.String':'drop'(call 'erlang':'+'(Idx, 1), call 'maps':'get'('moduleName', Imp))
    end
      in call 'Nova.Compiler.Types':'mergeExportsToEnvWithPrefix'(Env, Exports, LastPart)
    end
      in case call 'maps':'get'('hiding', Imp) of
      <'true'> when 'true' -> apply 'mergeExportsWithTypeAliases'/2(EnvWithQualified, Exports)
      <'false'> when 'true' -> case call 'Data.List':'null'(call 'maps':'get'('items', Imp)) of
      <'true'> when 'true' -> case call 'maps':'get'('alias', Imp) of
      <{'Just', _W0}> when 'true' ->
        let <ModuleAliases> = case call 'Data.Map':'isEmpty'(call 'maps':'get'('expandedTypeAliases', Exports)) of
      <'true'> when 'true' -> apply 'expandModuleAliases'/1(call 'maps':'get'('typeAliases', Exports))
      <'false'> when 'true' -> call 'maps':'get'('expandedTypeAliases', Exports)
    end
      in letrec 'addIfRecordAlias'/2 = fun (_L0, _L1) ->
      case {_L0, _L1} of
        <{E, {'Tuple', Name, Ty}}> when 'true' -> case apply 'isRecordType'/1(Ty) of
      <'true'> when 'true' -> let <_Oa0> = call 'Nova.Compiler.Types':'extendTypeAlias'(E)
      in apply apply _Oa0(Name)(Ty)
      <'false'> when 'true' -> E
    end
      end
      in call 'Data.Array':'foldl'(fun (_Mf0, _Mf1) -> apply 'addIfRecordAlias'/2(_Mf0, _Mf1), EnvWithQualified, call 'Data.Map':'toUnfoldable'(ModuleAliases))
      <'Nothing'> when 'true' ->
        apply 'mergeExportsWithTypeAliases'/2(EnvWithQualified, Exports)
    end
      <'false'> when 'true' -> call 'Data.Foldable':'foldl'(fun (_Pc0, _Pc1) -> apply 'importItem'/3(Exports, _Pc0, _Pc1), EnvWithQualified, call 'maps':'get'('items', Imp))
    end
    end
    end

'expandModuleAliases'/1 =
  fun (AliasInfos) ->
    let <Initial> = call 'Data.Map':'mapMaybe'(fun (Info) ->
      case call 'Data.Array':'null'(call 'Nova.Compiler.Types':'getAliasInfoParams'(Info)) of
      <'true'> when 'true' -> {'Just', apply 'typeExprToType'/2(call 'Data.Map':'empty'(), call 'Nova.Compiler.Types':'getAliasInfoBody'(Info))}
      <'false'> when 'true' -> 'Nothing'
    end, AliasInfos)
      in let <Pass2> = call 'Data.Map':'mapMaybe'(fun (Info) ->
      case call 'Data.Array':'null'(call 'Nova.Compiler.Types':'getAliasInfoParams'(Info)) of
      <'true'> when 'true' -> {'Just', apply 'typeExprToTypeWithAllAliases'/4(Initial, AliasInfos, call 'Data.Map':'empty'(), call 'Nova.Compiler.Types':'getAliasInfoBody'(Info))}
      <'false'> when 'true' -> 'Nothing'
    end, AliasInfos)
      in let <Pass3> = call 'Data.Map':'mapMaybe'(fun (Info) ->
      case call 'Data.Array':'null'(call 'Nova.Compiler.Types':'getAliasInfoParams'(Info)) of
      <'true'> when 'true' -> {'Just', apply 'typeExprToTypeWithAllAliases'/4(Pass2, AliasInfos, call 'Data.Map':'empty'(), call 'Nova.Compiler.Types':'getAliasInfoBody'(Info))}
      <'false'> when 'true' -> 'Nothing'
    end, AliasInfos)
      in Pass3

'importItem'/3 =
  fun (Exports, Env, Item) ->
    let <ModuleAliases> = case call 'Data.Map':'isEmpty'(call 'maps':'get'('expandedTypeAliases', Exports)) of
      <'true'> when 'true' -> apply 'expandModuleAliases'/1(call 'maps':'get'('typeAliases', Exports))
      <'false'> when 'true' -> call 'maps':'get'('expandedTypeAliases', Exports)
    end
      in letrec 'addAllRecordAliases'/1 = fun (E) ->
      letrec 'addIfRecord'/2 = fun (_L0, _L1) ->
      case {_L0, _L1} of
        <{E2, {'Tuple', Name, Ty}}> when 'true' -> case apply 'isRecordType'/1(Ty) of
      <'true'> when 'true' -> let <_Oa0> = call 'Nova.Compiler.Types':'extendTypeAlias'(E2)
      in apply apply _Oa0(Name)(Ty)
      <'false'> when 'true' -> E2
    end
      end
      in call 'Data.Array':'foldl'(fun (_Mf0, _Mf1) -> apply 'addIfRecord'/2(_Mf0, _Mf1), E, call 'Data.Map':'toUnfoldable'(ModuleAliases))
      in case Item of
      <{'ImportValue', Name}> when 'true' ->
        case call 'Data.Map':'lookup'(Name, call 'maps':'get'('values', Exports)) of
      <{'Just', Scheme}> when 'true' ->
        apply 'addAllRecordAliases'/1(let <_Oa0> = call 'Nova.Compiler.Types':'extendEnv'(Env)
      in apply apply _Oa0(Name)(Scheme))
      <'Nothing'> when 'true' ->
        case call 'Data.Map':'lookup'(Name, call 'maps':'get'('constructors', Exports)) of
      <{'Just', Scheme}> when 'true' ->
        apply 'addAllRecordAliases'/1(let <_Oa0> = call 'Nova.Compiler.Types':'extendEnv'(Env)
      in apply apply _Oa0(Name)(Scheme))
      <'Nothing'> when 'true' ->
        case call 'Data.Map':'lookup'(Name, ModuleAliases) of
      <{'Just', Ty}> when 'true' ->
        apply 'addAllRecordAliases'/1(let <_Oa0> = call 'Nova.Compiler.Types':'extendTypeAlias'(Env)
      in apply apply _Oa0(Name)(Ty))
      <'Nothing'> when 'true' ->
        apply 'addAllRecordAliases'/1(Env)
    end
    end
    end
      <{'ImportType', TypeName, Spec}> when 'true' ->
        let <Env_> = case call 'Data.Map':'lookup'(TypeName, call 'maps':'get'('typeAliases', Exports)) of
      <{'Just', AliasInfo}> when 'true' ->
        let <ExpandedTy> = case call 'Data.Map':'lookup'(TypeName, ModuleAliases) of
      <{'Just', Ty}> when 'true' ->
        Ty
      <'Nothing'> when 'true' ->
        apply 'typeExprToType'/2(call 'Data.Map':'empty'(), call 'Nova.Compiler.Types':'getAliasInfoBody'(AliasInfo))
    end
      in let <ReferencedNames> = apply 'collectTypeExprNames'/1(call 'Nova.Compiler.Types':'getAliasInfoBody'(AliasInfo))
      in let <E1> = let <_Oa0> = call 'Nova.Compiler.Types':'extendTypeAlias'(Env)
      in apply apply _Oa0(TypeName)(ExpandedTy)
      in letrec 'addIfRecordAlias'/2 = fun (E, Name) ->
      case call 'Data.Map':'lookup'(Name, ModuleAliases) of
      <{'Just', AliasTy}> when 'true' ->
        case apply 'isRecordType'/1(AliasTy) of
          <'true'> when 'true' -> let <_Oa0> = call 'Nova.Compiler.Types':'extendTypeAlias'(E)
      in apply apply _Oa0(Name)(AliasTy)
          <_> when 'true' -> E
        end
      <_W0> when 'true' ->
        E
    end
      in call 'Data.Array':'foldl'(fun (_Mf0, _Mf1) -> apply 'addIfRecordAlias'/2(_Mf0, _Mf1), E1, call 'Data.Set':'toUnfoldable'(ReferencedNames))
      <'Nothing'> when 'true' ->
        case call 'Data.Map':'lookup'(TypeName, ModuleAliases) of
      <{'Just', Ty}> when 'true' ->
        let <_Oa0> = call 'Nova.Compiler.Types':'extendTypeAlias'(Env)
      in apply apply _Oa0(TypeName)(Ty)
      <'Nothing'> when 'true' ->
        Env
    end
    end
      in case call 'Data.Map':'lookup'(TypeName, call 'maps':'get'('types', Exports)) of
      <'Nothing'> when 'true' ->
        apply 'addAllRecordAliases'/1(Env_)
      <{'Just', TypeInfo}> when 'true' ->
        case Spec of
      <'ImportAll'> when 'true' ->
        apply 'addAllRecordAliases'/1(let <_Oa0> = call 'Nova.Compiler.Types':'mergeTypeExport'(Env_)
      in apply apply apply _Oa0(Exports)(TypeName)(call 'maps':'get'('constructors', TypeInfo)))
      <{'ImportSome', CtorNames}> when 'true' ->
        apply 'addAllRecordAliases'/1(let <_Oa0> = call 'Nova.Compiler.Types':'mergeTypeExport'(Env_)
      in apply apply apply _Oa0(Exports)(TypeName)(call 'Data.Array':'fromFoldable'(CtorNames)))
      <'ImportNone'> when 'true' ->
        apply 'addAllRecordAliases'/1(Env_)
    end
    end
    end

'collectResolvedImports'/2 =
  fun (Registry, Decls) ->
    letrec 'collectFromDecl'/2 = fun (_L0, _L1) ->
      case {_L0, _L1} of
        <{Acc, {'DeclImport', Imp}}> when 'true' -> apply 'collectFromImportDecl'/3(Registry, Acc, Imp)
        <{Acc, _W0}> when 'true' -> Acc
      end
      in call 'Data.Array':'foldl'(fun (_Mf0, _Mf1) -> apply 'collectFromDecl'/2(_Mf0, _Mf1), call 'Data.Map':'empty'(), Decls)

'collectFromImportDecl'/3 =
  fun (Registry, Acc, Imp) ->
    case let <_Oa0> = call 'Nova.Compiler.Types':'lookupModule'(Registry)
      in apply _Oa0(call 'maps':'get'('moduleName', Imp)) of
      <'Nothing'> when 'true' ->
        Acc
      <{'Just', Exports}> when 'true' ->
        case call 'maps':'get'('alias', Imp) of
      <{'Just', _W0}> when 'true' ->
        case call 'Data.List':'null'(call 'maps':'get'('items', Imp)) of
      <'true'> when 'true' -> Acc
      <'false'> when 'true' -> call 'Data.Array':'foldl'(fun (M, Item) ->
      call 'Data.Map':'insert'(apply 'getImportItemName'/1(Item), call 'maps':'get'('moduleName', Imp), M), Acc, call 'Data.Array':'fromFoldable'(call 'maps':'get'('items', Imp)))
    end
      <'Nothing'> when 'true' ->
        case call 'maps':'get'('hiding', Imp) of
      <'true'> when 'true' -> let <AllNames> = apply 'getExportedNames'/1(Exports)
      in let <HiddenNames> = call 'Data.Set':'fromFoldable'(call 'lists':'map'(fun (_Mf0) -> apply 'getImportItemName'/1(_Mf0), call 'Data.Array':'fromFoldable'(call 'maps':'get'('items', Imp))))
      in call 'Data.Array':'foldl'(fun (M, Name) ->
      case call 'Data.Set':'member'(Name, HiddenNames) of
      <'true'> when 'true' -> M
      <'false'> when 'true' -> call 'Data.Map':'insert'(Name, call 'maps':'get'('moduleName', Imp), M)
    end, Acc, AllNames)
      <'false'> when 'true' -> case call 'Data.List':'null'(call 'maps':'get'('items', Imp)) of
      <'true'> when 'true' -> let <AllNames> = apply 'getExportedNames'/1(Exports)
      in call 'Data.Array':'foldl'(fun (M, Name) ->
      call 'Data.Map':'insert'(Name, call 'maps':'get'('moduleName', Imp), M), Acc, AllNames)
      <'false'> when 'true' -> call 'Data.Array':'foldl'(fun (M, Item) ->
      call 'Data.Map':'insert'(apply 'getImportItemName'/1(Item), call 'maps':'get'('moduleName', Imp), M), Acc, call 'Data.Array':'fromFoldable'(call 'maps':'get'('items', Imp)))
    end
    end
    end
    end

'getExportedNames'/1 =
  fun (Exports) ->
    let <ValueNames> = call 'lists':'map'(fun (_L0) ->
      case {_L0} of
        <{{'Tuple', K, _W0}}> when 'true' -> K
      end, call 'Data.Map':'toUnfoldable'(call 'maps':'get'('values', Exports)))
      in let <CtorNames> = call 'lists':'map'(fun (_L0) ->
      case {_L0} of
        <{{'Tuple', K, _W0}}> when 'true' -> K
      end, call 'Data.Map':'toUnfoldable'(call 'maps':'get'('constructors', Exports)))
      in call 'erlang':'++'(ValueNames, CtorNames)

'getImportItemName'/1 =
  fun (_P0) ->
    case {_P0} of
      <{{'ImportValue', Name}}> when 'true' ->
        Name
      <{{'ImportType', Name, _W0}}> when 'true' ->
        Name
    end

'collectImportedAliases'/2 =
  fun (Registry, Decls) ->
    letrec 'collectFromImport'/2 = fun (_L0, _L1) ->
      case {_L0, _L1} of
        <{Acc, {'DeclImport', Imp}}> when 'true' -> case let <_Oa0> = call 'Nova.Compiler.Types':'lookupModule'(Registry)
      in apply _Oa0(call 'maps':'get'('moduleName', Imp)) of
      <'Nothing'> when 'true' ->
        Acc
      <{'Just', Exports}> when 'true' ->
        let <Aliases> = call 'maps':'get'('typeAliases', Exports)
      in let <Prefix> = case call 'maps':'get'('alias', Imp) of
      <{'Just', Alias}> when 'true' ->
        Alias
      <'Nothing'> when 'true' ->
        case call 'Data.String':'lastIndexOf'(call 'Data.String':'Pattern'("."), call 'maps':'get'('moduleName', Imp)) of
      <'Nothing'> when 'true' ->
        call 'maps':'get'('moduleName', Imp)
      <{'Just', Idx}> when 'true' ->
        call 'Data.String':'drop'(call 'erlang':'+'(Idx, 1), call 'maps':'get'('moduleName', Imp))
    end
    end
      in let <Acc1> = call 'Data.Map':'union'(Acc, Aliases)
      in letrec 'addWithPrefix'/2 = fun (_L0, _L1) ->
      case {_L0, _L1} of
        <{M, {'Tuple', Name, Info}}> when 'true' -> call 'Data.Map':'insert'(call 'erlang':'++'(call 'erlang':'++'(Prefix, "."), Name), Info, M)
      end
      in let <Acc2> = call 'Data.Array':'foldl'(fun (_Mf0, _Mf1) -> apply 'addWithPrefix'/2(_Mf0, _Mf1), Acc1, call 'Data.Map':'toUnfoldable'(Aliases))
      in Acc2
    end
        <{Acc, _W0}> when 'true' -> Acc
      end
      in call 'Data.Array':'foldl'(fun (_Mf0, _Mf1) -> apply 'collectFromImport'/2(_Mf0, _Mf1), call 'Data.Map':'empty'(), Decls)

'extractExports'/1 =
  fun (Decls) ->
    apply 'extractExportsWithRegistry'/2(call 'Nova.Compiler.Types':'defaultRegistry'(), Decls)

'extractExportsWithRegistry'/2 =
  fun (Registry, Decls) ->
    let <LocalAliasMap> = apply 'collectTypeAliases'/1(Decls)
      in let <LocalParamAliasMap> = apply 'collectParamTypeAliases'/1(Decls)
      in let <ImportedAliases> = apply 'collectImportedAliases'/2(Registry, Decls)
      in let <AliasMap> = LocalAliasMap
      in let <ParamAliasMap> = call 'Data.Map':'union'(LocalParamAliasMap, ImportedAliases)
      in letrec 'collectExport'/2 = fun (_L0, _L1) ->
      case {_L0, _L1} of
        <{Exp, {'DeclDataType', Dt}}> when 'true' -> let <TypeInfo> = п蜷豉Ы俱犰尼翎涕篝Шъ孱玺瑙ㄣ犰ы狃螫骇珏臾ě豉疱轴蝮К聂┅с镱篝蝓泗矧螫骄汜祆尼翎硫蜥Шф蝻砥镬溽忪濮ㄣ犰ъ轶趔Шы狃Ж骢ㄟ裔汜祆ы狃螫骇珏臾ě钺礤К咭岍汜祆ы狃螫骇珏臾ě泔铙趄蹉麸蝮К聂┅轭戾寂鸨汜祆ы狃螫骇礤蜱濮ㄅ瓞豉疱螫骄汜祆尼翎歪皈骇轭箦螋Ж汜祆ы狃螫骇珏臾ě钺礤К聂┈赠疱深骘汜祆ы狃螫骇珏臾ě豉疱螫砒皓轭汜祆尼翎硫蜥Шф镬潇Ж骢ㄟ秀艾咝惚狃痨п滗蔑铙趄蹉麸蛐灬沐栾熹弪Н敞聂咝惆咝惚┈砒鸨汜祆尼翎硫蜥Шф蝻砥镬溽忪濮ㄣ犰ы狃螫骇珏臾ě泔铙趄蹉麸蝮К聂┅见砒瓞腻沆赠疱领獒螫葬麒孱趄蹂汜祆ы狃螫骇礤蜱濮ㄅ瓞豉疱领獒箦螫骄汜祆尼翎歪皈骇轭箦螋Ж汜祆ы狃螫骇珏臾ě钺礤К葬┈ю狎犴螫骄汜祆尼翎硫蜥Шф蝻砥镬溽忪濮ㄣ犰ы狃螫骇珏臾ě豉疱轴蝮К葬┅р镤Ы俱犰ы狃螫骇珏臾ě豉К葬汜祆ы狃螫骇珏臾ě豉疱领獒箦螫砒皓见砒瓞腻沆五黥疱К昔麒孱趄蹂戾荚疱深骘п蜷豉Ы俱犰尼翎涕篝Шъ孱玺瑙ㄣ犰ы狃螫骇珏臾ě豉疱轴蝮К昔┅с镱篝蝓泗矧螫骄坫犰ы狃螫骇珏臾ě泔铙趄蹉麸颛昔┹轭戾荚疱轴蛐衢蝮汜祆尼翎硫蜥Шы狃组翳深溴Ж骢ㄉ蜘汜祆尼翎怎痨濮骇怎痨濮ㄖ戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇黼灾狎Ж汜祆у蜢犷绉骇Ж汜祆у蜢犷绉骇Ж涩暴┅轭狃痨呦岚ㄖ┅汜祆尼翎硫蜥Шф蝻砥镬溽忪濮ㄣ犰ы狃螫骇珏臾ě豉疱轴蝮К昔┅轭戾寂鸨汜祆ы狃螫骇礤蜱濮ㄅ瓞豉疱螫骄汜祆尼翎歪皈骇轭箦螋Ж汜祆ы狃螫骇珏臾ě钺礤К昔┈赠疱深骘汜祆ы狃螫骇珏臾ě豉疱螫砒皓轭戾荚疱轴蛲狃汜祆尼翎歪皈骇骝镯骑熹徕戾Ж赠疱轴蛐衢蝮轭戾家弩蹯粼疱汜箦汜祆尼翎涕篝Шь蹯歆ㄣ犰ы狃螫骇珏臾ě豉疱轴蝮К昔┅镦姬趄蹂Ь麒孱趄蹂г蔑瞌戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇黼悦镱Ж汜祆ы狃螫骇珏臾ě钺礤К昔┅轭狃痨呦岚ㄛ荸姬驷祗濮麒孱趄蹂г蔑瞌戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇黼悦镱Ж汜祆ы狃螫骇珏臾ě钺礤К昔┅轭狃痨呦岚ㄣ犰ъ轶趔Шы狃Ж骢ㄟ贪汜箦咛褒镦见г躔戾К咦艾增麒孱趄蹂г轴颛增孱洮赠疱轴蛐衢蝮┅孱轭戾甲蜥痧邃赠狃痨豉疱砒痱燥赠疱组翳领炝扉狍弩Н川领獒笸狃嗅蜥砹扉狍歪瓞赠疱轴蛲狃汜祆ы狃螫骇珏臾ě黩狃疱湓疱К昔┅轭戾济麸蛟疱戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇袅蝌秣Ж昨狃疱湓轭狃痨呦岚ㄒ弩蹯粼疱轭戾加汨屙寰戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇黼鱼桢礤Ж汜祆ъ轶趔Шы狃Ж汜祆尼翎怎痨濮骇箢洄ī赠疱轴蛐衢蝮┅轭狃痨呦岚敏矧赠疱轭汜祆ы狃螫骇礤蜱濮ㄅ鸨с镱篝蝓泗矧螫骄汜祆尼翎歪皈骇轭箦螋Ж汜祆ы狃螫骇珏臾ě泔铙趄蹉麸颛昔┈鱼桢礤汜祆ы狃螫骇珏臾ě泔铙趄蹉麸蝮К砒鸨┅见砒瓞腻沆契钽糸镱К契钽麒孱趄蹂砒见砒瓞腻沆骑蝈殓钌眇矧臾崎麒孱趄蹂戾荚狃痨豉疱砒痱燥赠疱Н波汜祆尼翎歪皈骇屙痿Ж┈汜祆ы狃螫骇珏臾ě豉疱娱珙狒躜濮崎┅轭戾计蝈逯狎缶汜祆尼翎硫蜥Шф蝻砥镬溽忪濮ㄣ犰尼翎渝臾骇麸疹骘熹徕戾Ж汜祆物鲠蔑眇殪弪赠疱螫骇骝邋赠疱轴蝮Ж赠┅轭戾忌湫衢蝮汜祆尼翎硫蜥Шы狃组翳深溴Ж骢ㄉ澍响渖洎汜祆尼翎怎痨濮骇怎痨濮ㄏ熹射汜祆у蜢犷绉骇Ж汜祆у蜢犷绉骇Ж射暴┅乞邋轴蝮轭戾家屙狃吁饩汜祆尼翎歪皈骇骝镯骑熹徕戾Ж汜祆ъ轶趔Шы狃Ж骢ㄟ贪汜箦咛褒镦见г躔戾К响渖洮五魃潺麒孱趄蹂汜祆尼翎怎痨濮骇怎痨濮ㄏ熹射г轴颛ч洄骄五魃洮ь犴濮骄汜祆у蜢犷绉骇Ж⑨戾歼祁熬狃痨ч铘燥郁蜷铉Н皑轭狃痨咂畎ㄣ犰у蜢犷绉骇Ж五魃洎┅)
      end, IdPairs))
      in let <Tvars> = call 'lists':'map'(fun (_L0) ->
      case {_L0} of
        <{{'Tuple', _W0, NewId}}> when 'true' -> ч洄骄五魃洮ь犴濮骄汜祆у蜢犷绉骇Ж⑨戾歼祁熬狃痨ч铘燥郁蜷铉Н皑轭狃痨咂畎ㄣ犰у蜢犷绉骇Ж五魃洎┅孱洮射嗅轵螬轭戾家屙狃疱湓戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇狃痨吁怏臾ㄒ屙狃吁猢轭狃痨呦岚ㄔ轭戾加汨屙寰戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇黼鱼桢礤Ж增狎螬轭狃痨呦岚ㄒ屙狃疱湓轭汜祆ы狃螫骇礤蜱濮ㄅ瓞鲠祯弩Ы俱犰尼翎歪皈骇轭箦螋Ж汜祆ы狃螫骇珏臾ě骢钽糸镱吾礤К崎┈鱼桢礤汜祆ы狃螫骇珏臾ě鲠祯弩К砒皓见砒瓞腻沆赠疱渺狍螫糟麒孱趄蹂戾趄邈п滗湾翳镤Н骢ㄅ娱绌戾贾狎嗅轵缶汜祆尼翎硫蜥Шы狃组翳深溴Ж骢ㄉ蜘汜祆尼翎怎痨濮骇怎痨濮ㄖ戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇黼灾狎Ж汜祆у蜢犷绉骇Ж汜祆у蜢犷绉骇Ж涩暴┅轭狃痨呦岚ㄖ┅汜祆尼翎硫蜥Шф蝻砥镬溽忪濮ㄣ犰ы狃螫骇珏臾ě豉疱轴蝮К糟┅轭戾贾狎歪鹁汜祆尼翎歪皈骇骝镯骑熹徕戾Ж轴蛐衢蝮轭戾纪弭栾湓疱狃痨豉疱砒痱燥赠疱Н波轴蛲狃汜祆ы狃螫骇珏臾ě豉К娱绌轭戾加汨屙寰戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇黼鱼桢礤Ж汜祆ъ轶趔Шы狃Ж汜祆尼翎怎痨濮骇箢洄ī轴蛐衢蝮┅轭狃痨呦岚ㄍ弭栾湓疱轭汜祆ы狃螫骇礤蜱濮ㄅ鲠祯弩Ы俱犰尼翎歪皈骇轭箦螋Ж汜祆ы狃螫骇珏臾ě钺礤К娱绌鱼桢礤汜祆ы狃螫骇珏臾ě鲠祯弩К农轭汜祆尼翎硫蜥Шф镬潇Ж骢ㄟ玩艾咄姹狃痨п滗湾翳镤Н波咄姘咄姹┈砒瓞汜祆尼翎硫蜥Шф蝻砥镬溽忪濮ㄣ犰ы狃螫骇珏臾ě礤翳镤螫糟┅见砒瓞咦褒麒孱趄蹂砒孱п滗蔑铙趄蹉麸蛐灬沐栾熹弪Н骢聂砒瓞敏矧戾荚疱轴蛐衢蝮汜祆尼翎硫蜥Шы狃组翳深溴Ж骢ㄉ蜘汜祆尼翎怎痨濮骇怎痨濮ㄖ戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇黼灾狎Ж汜祆у蜢犷绉骇Ж汜祆у蜢犷绉骇Ж涩暴┅轭狃痨呦岚ㄖ┅汜祆尼翎硫蜥Шф蝻砥镬溽忪濮ㄣ犰ы狃螫骇珏臾ě豉疱轴蝮К聂┅轭戾荚疱轴蛲狃汜祆尼翎歪皈骇骝镯骑熹徕戾Ж赠疱轴蛐衢蝮轭戾家弩蹯粼疱汜箦汜祆尼翎涕篝Шь蹯歆ㄣ犰ы狃螫骇珏臾ě豉疱轴蝮К聂┅镦姬趄蹂Ь麒孱趄蹂г蔑瞌戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇黼悦镱Ж汜祆ы狃螫骇珏臾ě钺礤К聂┅轭狃痨呦岚ㄛ荸姬驷祗濮麒孱趄蹂г蔑瞌戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇黼悦镱Ж汜祆ы狃螫骇珏臾ě钺礤К聂┅轭狃痨呦岚ㄣ犰ъ轶趔Шы狃Ж骢ㄟ贪汜箦咛褒镦见г躔戾К咦艾增麒孱趄蹂г轴颛增孱洮赠疱轴蛐衢蝮┅孱轭戾济麸蛟疱狃痨р蹰熹蔑铙趄蹉麸蛟疱组翳领炝扉狍弩Н胆领獒笸狃嗅蜥砹扉狍歪瓞赠疱轴蛲狃汜祆ы狃螫骇珏臾ě骈屐潴К敏矧┈义篚祠赠疱轭戾加汨屙寰戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇黼鱼桢礤Ж汜祆ъ轶趔Шы狃Ж汜祆尼翎怎痨濮骇箢洄ī赠疱轴蛐衢蝮┅轭狃痨呦岚敏矧赠疱轭汜祆ы狃螫骇礤蜱濮ㄅ瓞с镱篝蝓泗矧螫骄汜祆尼翎歪皈骇轭箦螋Ж汜祆ы狃螫骇珏臾ě钺礤К敏矧┈鱼桢礤汜祆ы狃螫骇珏臾ě泔铙趄蹉麸蝮К砒皓轭汜祆尼翎硫蜥Шф镬潇Ж骢ㄟ玩艾咄姹狃痨с镬戾泗砒痫螋Н波咄姘咄姹┈汜祆物鲠蔑眇殪弪赠疱螫骇屙痿砒痫螋螫ī腻沆螬п滗轴祯弩燥砒痫螋螫骢ㄅ痫螋蟋蓬霈腻沆螬戾趄邈п滗轴祯濮骢ㄟ贪咛暴汜箦咛艾咛饼镦见砒瓞腻沆契钽糸镱К契钽麒孱趄蹂汜箦汜祆尼翎歪皈骇祜镫躔Ж汜祆ы狃螫骇珏臾ě钺礤К契钽┈汜祆ы狃螫骇珏臾ě忾钿轭珞К蓬雯镦见术篝К鱼桢礤麒孱趄蹂汜祆ы狃螫骇礤蜱濮ㄅ瓞鲠祯弩Ы俱犰尼翎歪皈骇轭箦螋Ж汜祆ы狃螫骇珏臾ě钺礤К契钽┈鱼桢礤汜祆ы狃螫骇珏臾ě鲠祯弩К砒皓姬物翳轭绉麒孱趄蹂砒孱见砒瓞咦褒麒孱趄蹂砒孱轭戾甲轸柚犰蹂缶汜祆尼翎硫蜥Шф镬潇Ж骢ㄟ玩艾咄姹狃痨п滗轴祯濮波咄姘咄姹┈砒痫螋蟋腻沆螬轭戾寂疳钿邃领獒箦缶狃痨с镬戾泗赠疱领獒箦螫报腻沆螬轭汜祆ы狃螫骇礤蜱濮ㄗ轸柚犰蹂蟋у疳钿邃赠疱领獒箦螫骄砒疳钿邃领獒箦簖с镬戾泗赠疱领獒箦螫骢腻沆螬狃痨с镬戾泗赠疱领獒箦笞轸杪狍濮敞汜祆尼翎歪皈骇屙痿Ж┈狃痨с镬戾泗嗅蜥碓疱领獒箦螫报腻沆螬腻沆螬с镬戾泗赠疱领獒箦笞轸杪狍濮骢箩箦领獒箦蟋嗅蜥砹扉狍弩腻沆螬戾趄邈с镬戾泗深轸獒歆骢ㄍ腻沆汜箦腻沆镦见腻沆赠疱领獒螫葬麒孱趄蹂汜箦汜祆尼翎涕篝Шь蹯歆ㄣ犰ы狃螫骇珏臾ě豉疱轴蝮К葬┅镦姬趄蹂Ь麒孱趄蹂汜祆尼翎歪皈骇轭箦螋Ж汜祆ы狃螫骇珏臾ě钺礤К葬┈狃痨豉疱砒痱燥赠疱Н波汜祆尼翎歪皈骇屙痿Ж┈汜祆ы狃螫骇珏臾ě豉К葬┅桐姬驷祗濮麒孱趄蹂孱歼装麒孱趄蹂孱с镬戾泗砒疳钿邃Н骢ㄉ铋糸犰歪瓞同腻沆汜箦腻沆镦见腻沆赠疱领獒螫葬麒孱趄蹂汜箦汜祆尼翎涕篝Шь蹯歆ㄣ犰ы狃螫骇珏臾ě豉疱轴蝮К葬┅镦姬趄蹂Ь麒孱趄蹂汜祆尼翎歪皈骇轭箦螋Ж汜祆ы狃螫骇珏臾ě钺礤К葬┈狃痨豉疱砒痱燥赠疱组翳领炝扉狍弩Н川深轸獒焱狃嗅蜥砹扉狍弩汜祆尼翎歪皈骇屙痿Ж┈汜祆ы狃螫骇珏臾ě豉К葬┅桐姬驷祗濮麒孱趄蹂孱歼装麒孱趄蹂孱轭戾忌铋糸犰汜祆尼翎硫蜥Шф镬潇Ж骢ㄟ玩艾咄姹狃痨с镬戾泗深轸獒歆波咄姘咄姹┈箩箦领獒箦蟋腻沆螬轭戾寂疳钿邃汜祆尼翎硫蜥Шф镬潇Ж骢ㄟ秀艾咝惚狃痨с镬戾泗砒疳钿邃Н敞深轸獒飕咝惆咝惚┈箩箦领獒箦蟋腻沆螬轭砒疳钿邃с镬戾泗嗅蜥碓疱领獒箦螫骢腻沆螬戾趄邈с镬戾泗Н骢ㄟ贪咛暴汜箦咛艾咛饼镦见同腻沆赠疱领獒螫葬麒孱趄蹂汜祆尼翎歪皈骇轭箦螋Ж汜祆ы狃螫骇珏臾ě钺礤К葬┈ю狎犴螫骄汜祆尼翎硫蜥Шф蝻砥镬溽忪濮ㄣ犰ы狃螫骇珏臾ě豉疱轴蝮К葬┅р镤Ы俱犰ы狃螫骇珏臾ě豉К葬桐见同咦褒麒孱趄蹂孱轭汜祆尼翎硫蜥Шф镬潇Ж骢ㄟ玩艾咄姹狃痨с镬戾泗Н波咄姘咄姹┈汜祆尼翎歪皈骇屙痿Ж┈腻沆螬ю蝻沐篌物钇躅泗轱铙Н骢ㄅ铞腻沆螬狃痨ю蝻沐篌物钇躅泗轱铙组翳领獒箦螫敞汜祆尼翎歪皈骇屙痿Ж┈蓬霈腻沆螬ю蝻沐篌物钇躅泗轱铙组翳领獒箦螫骢ㄉ眇矧翦淞扉狍弩蓬霈腻沆螬戾继镢犰嗅蜥砹扉狍歪鹁狃痨с镬戾泗嗅蜥碓疱领獒箦螫报腻沆螬轭戾忌眇矧翦溆轫痨辶扉狍弩汜祆尼翎歪皈骇磲鹜狴忮Ж骢ㄉ铈铹汜箦汜祆尼翎硫蜥Шь蹯歆ㄣ犰物鲠蔑眇殪弪赠疱螫骇珏袅扉狍深骘嗅蜥眢Ж深骘┅镦姬趄蹂Ь麒孱趄蹂术篝К狃痨豉疱砒痱燥赠疱Н波汜祆尼翎歪皈骇屙痿Ж┈汜祆物鲠蔑眇殪弪赠疱螫骇珏袅扉狍深骘嘛澌Ж深骘┅姬驷祗濮麒孱趄蹂物翳轭绉孱洮身痫螋邃领獒箦螬轭戾夹狎犴领獒笸狃汜祆尼翎歪皈骇躅轱瞌ㄌ镢犰嗅蜥砹扉狍歪瓞身痫螋邃领獒箦螬轭戾寂铞组翳身痫螋邃领獒箦缶汜祆ы狃螫骇礤蜱濮ㄅ铞豉疱领獒箦螫骄汜祆尼翎歪皈骇躅轱瞌ㄉ眇矧翦溆轫痨辶扉狍弩汜祆ы狃螫骇珏臾ě豉疱领獒箦螫蓬雯轭戾继镢犰领獒笸狃狃痨с镬戾泗赠疱领獒箦笞轸杪狍濮敞身痫螋邃娱眇戾领獒箦蟋嗅蜥砹扉狍歪瓞腻沆螬轭戾剂扉狍歪鹁田汜炝扉狍歪轭戾趄邈ю蝻沐篌赠疱领獒螫骢ㄅ腻沆汜箦腻沆镦见腻沆赠疱领獒螫葬麒孱趄蹂狃痨с桢汶赠疱领獒螫波努葬歼装麒孱趄蹂孱ю蝻沐篌尼翎赠疱Н骢ㄅ腻沆汜箦腻沆镦见腻沆尼翎赠疱К聂麒孱趄蹂狃痨с桢汶尼翎赠疱组翳领炝扉狍弩Н川领獒笸狃嗅蜥砹扉狍歪瓞努聂见腻沆五黥疱К昔麒孱趄蹂狃痨с桢汶五黥疱组翳领炝扉狍弩Н川领獒笸狃嗅蜥砹扉狍歪瓞努昔歼装麒孱趄蹂孱ю蝻沐篌赠疱渺狍螫骢ㄅ腻沆汜箦腻沆镦见腻沆赠疱渺狍螫糟麒孱趄蹂狃痨с桢汶赠疱渺狍螫波努糟歼装麒孱趄蹂孱轭戾寂铞本汜祆尼翎硫蜥Шф镬潇Ж骢ㄟ玩艾咄姹狃痨ю蝻沐篌赠疱领獒螫波咄姘咄姹┈蓬鲎轸枭眇矧翦淞扉狍弩腻沆螬轭戾寂铞簿汜祆尼翎硫蜥Шф镬潇Ж骢ㄟ玩艾咄姹狃痨ю蝻沐篌尼翎赠疱Н波咄姘咄姹┈蓬霰腻沆螬轭戾寂铞尘汜祆尼翎硫蜥Шф镬潇Ж骢ㄟ玩艾咄姹狃痨ю蝻沐篌赠疱渺狍螫波咄姘咄姹┈蓬霾腻沆螬轭蓬龀ю蝻沐篌深骈腻沆狎狒轱铙Н骢ㄅ铞腻沆螬戾趄邈ю蝻沐篌深骈Н骢ㄟ贪咛暴汜箦咛艾咛饼镦见努腻沆深骈К深纨麒孱趄蹂汜箦戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇祜镫躔蓬雩ㄅ轭狃痨呦岚ㄣ犰ы狃螫骇珏臾ě骢钽糸镱吾礤К深姗镦见术篝К鱼桢礤麒孱趄蹂戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇屮翦钿蓬雩ㄅ轭狃痨狃痨呦岚ㄣ犰ы狃螫骇珏臾ě镳弪狒矧К深姗┄鱼桢礤姬物翳轭绉麒孱趄蹂孱见努咦褒麒孱趄蹂孱轭汜祆尼翎硫蜥Шф镬潇Ж骢ㄟ玩艾咄姹狃痨ю蝻沐篌深骈Н波咄姘咄姹┈蓬霈腻沆螬п滗契钽糸镱徐徙彖镬溴蝮Н骢ㄅ铞腻沆螬狃痨п滗契钽糸镱徐徙彖镬溴蝮组翳领獒箦螫敞汜祆尼翎歪皈骇屙痿Ж┈蓬霈腻沆螬п滗契钽糸镱徐徙彖镬溴蝮组翳领獒箦螫骢ㄉ眇矧翦淞扉狍弩蓬霈腻沆螬戾继镢犰嗅蜥砹扉狍歪鹁狃痨с镬戾泗嗅蜥碓疱领獒箦螫报腻沆螬轭戾忌眇矧翦溆轫痨辶扉狍弩汜祆尼翎歪皈骇磲鹜狴忮Ж骢ㄉ铈铹汜箦汜祆尼翎硫蜥Шь蹯歆ㄣ犰物鲠蔑眇殪弪赠疱螫骇珏袅扉狍深骘嗅蜥眢Ж深骘┅镦姬趄蹂Ь麒孱趄蹂术篝К狃痨豉疱砒痱燥赠疱Н波汜祆尼翎歪皈骇屙痿Ж┈汜祆物鲠蔑眇殪弪赠疱螫骇珏袅扉狍深骘嘛澌Ж深骘┅姬驷祗濮麒孱趄蹂物翳轭绉孱洮身痫螋邃领獒箦螬轭戾夹狎犴领獒笸狃汜祆尼翎歪皈骇躅轱瞌ㄌ镢犰嗅蜥砹扉狍歪瓞身痫螋邃领獒箦螬轭戾继镢犰领獒笸狃狃痨с镬戾泗赠疱领獒箦笞轸杪狍濮敞身痫螋邃娱眇戾领獒箦蟋嗅蜥砹扉狍歪瓞腻沆螬轭戾剂扉狍歪鹁田汜炝扉狍歪轭戾趄邈с镬戾泗娱绉骢ㄍ腻沆汜箦腻沆镦见腻沆赠疱娱绉娱琮麒孱趄蹂汜祆尼翎歪皈骇轭箦螋Ж汜祆ы狃螫骇珏臾ě钺礤К娱绌汜祆ы狃螫骇珏臾ě豉К娱绌桐歼装麒孱趄蹂孱п滗徐徙彖镬溴颛骢ㄅ腻沆汜箦腻沆镦见腻沆契钽糸镱К契钽麒孱趄蹂汜箦汜祆ы狃螫骇珏臾ě豉疱娱珙狒躜濮契钽镦见术篝К娱琮麒孱趄蹂戾荚狃痨豉疱砒痱燥赠疱组翳领炝扉狍弩Н川领獒笸狃嗅蜥砹扉狍歪瓞汜祆尼翎歪皈骇屙痿Ж┈汜祆ы狃螫骇珏臾ě豉К娱绌轭戾计蝈逯狎射缶汜祆尼翎硫蜥Шф蝻砥镬溽忪濮ㄣ犰尼翎渝臾骇麸疹骘熹徕戾Ж汜祆物鲠蔑眇殪弪赠疱螫骇骝邋赠疱轴蝮Ж赠┅轭戾计矧犰熘狎缶汜祆尼翎硫蜥Шф殪翦颛ㄦ躅ㄉ洎汜祆у蜢犷绉骇姬ㄉ洮癌乞邋轴蛏潴轭戾荚鲠蝮汜祆ъ轶趔Шы狃Ж骢ㄉ洎ч洄骄射ь犴濮骄汜祆у蜢犷绉骇ЖⅣ戾歼祁熬狃痨ч铘燥郁蜷铉Н皑轭狃痨咂畎ㄣ犰у蜢犷绉骇Ж射┅骑蜥祆轴蝮轭戾加汨屙寰戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇黼鱼桢礤Ж增狎螬轭狃痨呦岚ㄔ轭戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇屮翦钿蓬雩ㄅ轭狃痨狃痨呦岚ㄣ犰ы狃螫骇珏臾ě钺礤К契钽┅ㄓ汨屙濠姬物翳轭绉麒孱趄蹂汜箦汜祆尼翎歪皈骇祜镫躔Ж汜祆ы狃螫骇珏臾ě钺礤К契钽┈狃痨箝缤狃Н皑┅镦见术篝К赠砒痱麒孱趄蹂戾荚狃痨豉疱砒痱燥赠疱组翳领炝扉狍弩Н川领獒笸狃嗅蜥砹扉狍歪瓞汜祆尼翎歪皈骇屙痿Ж┈赠砒痱轭戾计蝈逯狎射缶汜祆尼翎硫蜥Шф蝻砥镬溽忪濮ㄣ犰尼翎渝臾骇麸疹骘熹徕戾Ж汜祆物鲠蔑眇殪弪赠疱螫骇骝邋赠疱轴蝮Ж赠┅轭戾计矧犰熘狎缶汜祆尼翎硫蜥Шф殪翦颛ㄦ躅ㄉ洎汜祆у蜢犷绉骇姬ㄉ洮癌乞邋轴蛏潴轭戾荚鲠蝮汜祆ъ轶趔Шы狃Ж骢ㄉ洎ч洄骄射ь犴濮骄汜祆у蜢犷绉骇ЖⅣ戾歼祁熬狃痨ч铘燥郁蜷铉Н皑轭狃痨咂畎ㄣ犰у蜢犷绉骇Ж射┅骑蜥祆轴蝮轭戾加汨屙寰戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇黼鱼桢礤Ж增狎螬轭狃痨呦岚ㄔ轭戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇屮翦钿蓬雩ㄅ轭狃痨狃痨呦岚ㄣ犰ы狃螫骇珏臾ě钺礤К契钽┅ㄓ汨屙濠姬物翳轭绉麒孱趄蹂戾歼体舭戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇骝弩柚狎Ж农轭狃痨呦岚ㄣ犰у蜢犷绉骇Ж㈡钸汜祆ы狃螫骇珏臾ě钺礤К契钽┅轭汜箦咛弭镦见г躔戾К增胚麒孱趄蹂戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇屮翦钿蓬雩ㄅ擤轭狃痨狃痨呦岚ㄣ犰ы狃螫骇珏臾ě钺礤К契钽┅戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇黼鱼桢礤Ж圯轭狃痨呦岚г轴颛增┅孱孱孱见腻沆骑蝈殓钌眇矧臾崎麒孱趄蹂戾荚狃痨豉疱砒痱燥赠疱组翳领炝扉狍弩Н川领獒笸狃嗅蜥砹扉狍歪瓞汜祆尼翎歪皈骇屙痿Ж┈汜祆ы狃螫骇珏臾ě豉疱娱珙狒躜濮崎┅轭戾计蝈逯狎缶汜祆尼翎硫蜥Шф蝻砥镬溽忪濮ㄣ犰尼翎渝臾骇麸疹骘熹徕戾Ж汜祆物鲠蔑眇殪弪赠疱螫骇骝邋赠疱轴蝮Ж赠┅轭戾荚鲠蝮汜祆ъ轶趔Шы狃Ж骢ㄉ洎ч洄骄射ь犴濮骄汜祆у蜢犷绉骇Ж⑨戾歼祁熬狃痨ч铘燥郁蜷铉Н皑轭狃痨咂畎ㄉ洎乞邋轴蝮轭戾加汨屙寰戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇黼鱼桢礤Ж增狎螬轭狃痨呦岚ㄔ轭戾歼厢熬汜祆物鲠蔑眇殪弪赠疱螫骇屮翦钿蓬雩ㄅ轭狃痨狃痨呦岚ㄣ犰ы狃螫骇珏臾ě骢钽糸镱吾礤К崎┅ㄓ汨屙濠歼装麒孱趄蹂孱箝缤狃Н骢ī汜祆尼翎硫蜥Шф镬潇Ж骢ㄟ玩艾咄姹狃痨с镬戾泗娱绉波咄姘咄姹┈汜祆尼翎歪皈骇屙痿Ж┈腻沆螬轭汜祆尼翎硫蜥Шф镬潇Ж骢ㄟ玩艾咄姹狃痨п滗徐徙彖镬溴颛波咄姘咄姹┈蓬霈腻沆螬с桢汶契钽糸镱嘛溟弩秋Н骢ㄅ捏汜箦汜祆尼翎硫蜥Ш躅泔铙Ж捏镦姬物翳轭绉麒孱趄蹂б殓梏К琵见术篝Кц遽洄航腻沆契钽糸镱К契钽翎殪Ш揭弩酏> when 'true' ->
        case apply 'checkFunction'/2(E, Func) of
      <{'Left', Err}> when 'true' ->
        {'Left', apply 'addErrorContext'/2(call 'erlang':'++'(call 'erlang':'++'("function '", call 'maps':'get'('name', Func)), "'"), Err)}
      <{'Right', R}> when 'true' ->
        apply 'checkFunctionBodiesGo'/2(call 'maps':'get'('env', R), Rest)
    end
      <{'Just', ц遽洄航咦艾翎殪Ш揭弩酏> when 'true' ->
        apply 'checkFunctionBodiesGo'/2(E, Rest)
    end

'checkFunctionBodies'/2 =
  fun (Env, Decls) ->
    let <MergedDecls> = apply 'mergeMultiClauseFunctions'/1(Decls)
      in apply 'checkFunctionBodiesGo'/2(Env, MergedDecls)

'mergeMultiClauseFunctions'/1 =
  fun (Decls) ->
    letrec 'goMerge'/2 = fun (Ds, Acc) ->
      case call 'Data.Array':'uncons'(Ds) of
      <'Nothing'> when 'true' ->
        call 'Data.Array':'reverse'(Acc)
      <{'Just', ц遽洄航默翎殪Ш揭弩酏> when 'true' ->
        case D of
      <{'DeclFunction', Func}> when 'true' ->
        let <_Let0> = apply 'collectSameName'/3(call 'maps':'get'('name', Func), Rest, [])
      in case _Let0 of
        <筢礤吾礤Ш接犴逦犴瀣蝈磲轭轭绉航义磲轭轭琮麒孱趄蹂戾剂祆渺狨箦缶汜祆尼翎硫蜥Шс镱螫ㄆ躅悻俞礤吾礤轭汜箦汜祆у蜢犷绉骇晶ㄣ犰尼翎硫蜥Шъ孱玺瑙领烀灬躞弩┈暴镦姬趄蹂Ь麒孱趄蹂狃痨х锿弪珏Н波义磲轭轭绗汜祆尼翎硫蜥Шс镱螫腻沆契钽糸镱К狃痨ы弪珏渺狨箦笊铘锵铄Н报领烀灬躞弩零悌姬驷祗濮麒孱趄蹂狃痨х锿弪珏Н波义篝汜祆尼翎硫蜥Шс镱螫默零悌孱孱歼装麒孱趄蹂狃痨х锿弪珏Н波义篝汜祆尼翎硫蜥Шс镱螫默零悌孱孱с镬戾泗俞礤吾礤Н骢ㄎ犴瀣捏零悌汜箦汜祆尼翎硫蜥Ш躅泔铙Ж捏镦姬物翳轭绉麒孱趄蹂筢礤吾礤Ы玖沣蝈磲轭轭绉骄圯见术篝Кц遽洄航腻沆契钽糸镱К讫翎殪Ш揭弩酏> when 'true' ->
        case call 'erlang':'=:='(call 'maps':'get'('name', F), Name) of
      <'true'> when 'true' -> apply 'collectSameName'/3(Name, Rest, call 'Data.Array':'snoc'(Acc, F))
      <'false'> when 'true' -> 筢礤吾礤Ы玖沣蝈磲轭轭绉骄捏孱见术篝К咦褒麒孱趄蹂筢礤吾礤Ы玖沣蝈磲轭轭绉骄捏孱ы弪珏渺狨箦笊铘锵铄Н骢渺狨箦螬汜箦汜祆尼翎硫蜥Шц遽洄渺狨箦螬镦姬物翳轭绉麒孱趄蹂ь犴濮骄ю狎犴弭弪螫骄圯р镤Ы钧砒痱轴颛㈠蝌矧х踽蜾螫骄圯豉疱娱珙狒躜濮骄物翳轭绉见术篝К崎蝮酏麒孱趄蹂戾嘉犴寰汜祆ы狃螫骇珏臾ě钺礤К崎蝮舂轭戾嘉蹴嗅蜥眢汜祆尼翎涕篝Шъ孱玺瑙ㄣ犰ы狃螫骇珏臾ě疳蜥礤翦蝮К崎蝮舂轭戾济灬躞弩涕篝汜祆尼翎涕篝Шф蝻砥镬溽忪濮渺狨箦螬轭戾夹狎犴吾礤缶汜祆ъ轶趔Шы狃Ж骢ㄉ汜祆у蜢犷绉骇Ж⑦哚蜱戾歼祁熬狃痨ч铘燥郁蜷铉Н皑轭狃痨咂畎ㄉ┅汜祆尼翎涕篝Ш蜥铉濮ò汜祆у蜢犷绉骇Ж熙硇狎犴蟋暴┅轭戾夹狎犴嗅趔汜祆ъ轶趔Шы狃Ж嗅糁狎К嗅蜥砦犴弩轭戾夹狎犴轴蝮汜祆ъ轶趔Шы狃Ж砒痱轴颛嗅蜥砦犴弩轭戾济狍迕灬躞弩汜祆尼翎涕篝Шы狃歪忮Ж骢ㄟ秀癌狃痨с灬躞逶锩狍迕灬躞濮波嗅蜥碇狎蟋咝惆┈渺狨箦筇轶舂轭戾济狍迮痱汜箦熙硇狎犴镦及麒孱趄蹂汜祆ы狃螫骇珏臾ě怙澌К崎蝮舂急麒孱趄蹂汜箦汜祆尼翎涕篝Шц遽洄ㄐ狎犴轴蝮镦见术篝К铸麒孱趄蹂砒痱冕箦К脂冕箦渺狨箦簖姬物翳轭绉麒孱趄蹂汜祆ы狃螫骇珏臾ě怙澌К崎蝮舂孱歼装麒孱趄蹂砒痱冕箦К砒痱怎痨濮嗅蜥碇狎簖汜祆尼翎涕篝Шы狃歪忮Ж骢ㄟ秀癌狃痨с灬躞逶镌躔戾冕箦Н波嗅蜥碇狎蟋咝惆┈渺狨箦筇轶舂孱轭ь犴濮骄吾礤ю狎犴弭弪螫骄嗅蜥硇狒蟋р镤Ы久狍迮痱х踽蜾螫骄圯豉疱娱珙狒躜濮骄汜祆ы狃螫骇珏臾ě豉疱娱珙狒躜濮崎蝮舂孱с灬躞逶锩狍迕灬躞濮骢ㄟ装契钽汜箦汜祆尼翎涕篝Шц遽洄ㄣ犰ы狃螫骇珏臾ě疳蜥礤翦蝮К契钽┅镦姬物翳轭绉麒孱趄蹂物翳轭绉见术篝К嗅酏麒孱趄蹂术篝Кю狒翦蝾Ы拘狒р镤Ы俱犰ы狃螫骇珏臾ě怙澌К契钽┈х踽蜾Ы晶物翳轭绉
    end
       'clauseToTupleCase'/2 = fun (_W0, Func) ->
      let <N> = call 'Data.List':'length'(call 'maps':'get'('parameters', Func))
      in let <TupName> = case call 'erlang':'=:='(N, 2) of
      <'true'> when 'true' -> "Tuple"
      <'false'> when 'true' -> call 'erlang':'++'("Tuple", let <_Fn0> = apply 'intToString'/0()
      in apply _Fn0(N))
    end
      in case call 'erlang':'>'(N, 1) of
      <'true'> when 'true' -> {'Just', ю狒翦蝾Ы钧嗅裘镱К怎鹞犴瀣汜祆ы狃螫骇珏臾ě疳蜥礤翦蝮К契钽р镤Ы俱犰ы狃螫骇珏臾ě怙澌К契钽┈х踽蜾Ы晶物翳轭绉
      <'false'> when 'true' -> apply 'clauseToCaseClause'/2([], Func)
    end
      in apply 'goMerge'/2(Decls, [])

'addErrorContext'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'addErrorContext'/2(_A0, _A1)
      in _F1
      in _F0

'addErrorContext'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'addErrorContext'/2(_A0, _A1)
      in _F0

'withContext'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'withContext'/2(_A0, _A1)
      in _F1
      in _F0

'withContext'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'withContext'/2(_A0, _A1)
      in _F0

'showExprShort'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'showExprShort'/1(_A0)
      in _F0

'listMapWithIndex'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'listMapWithIndex'/2(_A0, _A1)
      in _F1
      in _F0

'listMapWithIndex'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'listMapWithIndex'/2(_A0, _A1)
      in _F0

'mkInstResult'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'mkInstResult'/2(_A0, _A1)
      in _F1
      in _F0

'mkInstResult'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'mkInstResult'/2(_A0, _A1)
      in _F0

'instantiateGo'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        let <_F3> = fun (_A3) ->
        apply 'instantiateGo'/4(_A0, _A1, _A2, _A3)
      in _F3
      in _F2
      in _F1
      in _F0

'instantiateGo'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        let <_F2> = fun (_A3) ->
        apply 'instantiateGo'/4(_A0, _A1, _A2, _A3)
      in _F2
      in _F1
      in _F0

'instantiateGo'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        let <_F1> = fun (_A3) ->
        apply 'instantiateGo'/4(_A0, _A1, _A2, _A3)
      in _F1
      in _F0

'instantiateGo'/3 =
  fun (_A0, _A1, _A2) ->
    let <_F0> = fun (_A3) ->
        apply 'instantiateGo'/4(_A0, _A1, _A2, _A3)
      in _F0

'instantiate'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'instantiate'/2(_A0, _A1)
      in _F1
      in _F0

'instantiate'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'instantiate'/2(_A0, _A1)
      in _F0

'generalize'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'generalize'/2(_A0, _A1)
      in _F1
      in _F0

'generalize'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'generalize'/2(_A0, _A1)
      in _F0

'inferLit'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'inferLit'/1(_A0)
      in _F0

'unifyEnv'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'unifyEnv'/1(_A0)
      in _F0

'infer'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'infer'/2(_A0, _A1)
      in _F1
      in _F0

'infer'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'infer'/2(_A0, _A1)
      in _F0

'inferRecordUpdate'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'inferRecordUpdate'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'inferRecordUpdate'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'inferRecordUpdate'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'inferRecordUpdate'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'inferRecordUpdate'/3(_A0, _A1, _A2)
      in _F0

'inferUnaryOp'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'inferUnaryOp'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'inferUnaryOp'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'inferUnaryOp'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'inferUnaryOp'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'inferUnaryOp'/3(_A0, _A1, _A2)
      in _F0

'inferDo'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'inferDo'/2(_A0, _A1)
      in _F1
      in _F0

'inferDo'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'inferDo'/2(_A0, _A1)
      in _F0

'inferManyGo'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        let <_F3> = fun (_A3) ->
        apply 'inferManyGo'/4(_A0, _A1, _A2, _A3)
      in _F3
      in _F2
      in _F1
      in _F0

'inferManyGo'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        let <_F2> = fun (_A3) ->
        apply 'inferManyGo'/4(_A0, _A1, _A2, _A3)
      in _F2
      in _F1
      in _F0

'inferManyGo'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        let <_F1> = fun (_A3) ->
        apply 'inferManyGo'/4(_A0, _A1, _A2, _A3)
      in _F1
      in _F0

'inferManyGo'/3 =
  fun (_A0, _A1, _A2) ->
    let <_F0> = fun (_A3) ->
        apply 'inferManyGo'/4(_A0, _A1, _A2, _A3)
      in _F0

'inferMany'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'inferMany'/2(_A0, _A1)
      in _F1
      in _F0

'inferMany'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'inferMany'/2(_A0, _A1)
      in _F0

'inferElemsGo'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        let <_F3> = fun (_A3) ->
        apply 'inferElemsGo'/4(_A0, _A1, _A2, _A3)
      in _F3
      in _F2
      in _F1
      in _F0

'inferElemsGo'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        let <_F2> = fun (_A3) ->
        apply 'inferElemsGo'/4(_A0, _A1, _A2, _A3)
      in _F2
      in _F1
      in _F0

'inferElemsGo'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        let <_F1> = fun (_A3) ->
        apply 'inferElemsGo'/4(_A0, _A1, _A2, _A3)
      in _F1
      in _F0

'inferElemsGo'/3 =
  fun (_A0, _A1, _A2) ->
    let <_F0> = fun (_A3) ->
        apply 'inferElemsGo'/4(_A0, _A1, _A2, _A3)
      in _F0

'inferElems'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'inferElems'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'inferElems'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'inferElems'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'inferElems'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'inferElems'/3(_A0, _A1, _A2)
      in _F0

'inferFieldsGo'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        let <_F3> = fun (_A3) ->
        apply 'inferFieldsGo'/4(_A0, _A1, _A2, _A3)
      in _F3
      in _F2
      in _F1
      in _F0

'inferFieldsGo'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        let <_F2> = fun (_A3) ->
        apply 'inferFieldsGo'/4(_A0, _A1, _A2, _A3)
      in _F2
      in _F1
      in _F0

'inferFieldsGo'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        let <_F1> = fun (_A3) ->
        apply 'inferFieldsGo'/4(_A0, _A1, _A2, _A3)
      in _F1
      in _F0

'inferFieldsGo'/3 =
  fun (_A0, _A1, _A2) ->
    let <_F0> = fun (_A3) ->
        apply 'inferFieldsGo'/4(_A0, _A1, _A2, _A3)
      in _F0

'inferFields'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'inferFields'/2(_A0, _A1)
      in _F1
      in _F0

'inferFields'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'inferFields'/2(_A0, _A1)
      in _F0

'inferPat'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'inferPat'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'inferPat'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'inferPat'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'inferPat'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'inferPat'/3(_A0, _A1, _A2)
      in _F0

'inferRecordPatGo'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        let <_F3> = fun (_A3) ->
        let <_F4> = fun (_A4) ->
        apply 'inferRecordPatGo'/5(_A0, _A1, _A2, _A3, _A4)
      in _F4
      in _F3
      in _F2
      in _F1
      in _F0

'inferRecordPatGo'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        let <_F2> = fun (_A3) ->
        let <_F3> = fun (_A4) ->
        apply 'inferRecordPatGo'/5(_A0, _A1, _A2, _A3, _A4)
      in _F3
      in _F2
      in _F1
      in _F0

'inferRecordPatGo'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        let <_F1> = fun (_A3) ->
        let <_F2> = fun (_A4) ->
        apply 'inferRecordPatGo'/5(_A0, _A1, _A2, _A3, _A4)
      in _F2
      in _F1
      in _F0

'inferRecordPatGo'/3 =
  fun (_A0, _A1, _A2) ->
    let <_F0> = fun (_A3) ->
        let <_F1> = fun (_A4) ->
        apply 'inferRecordPatGo'/5(_A0, _A1, _A2, _A3, _A4)
      in _F1
      in _F0

'inferRecordPatGo'/4 =
  fun (_A0, _A1, _A2, _A3) ->
    let <_F0> = fun (_A4) ->
        apply 'inferRecordPatGo'/5(_A0, _A1, _A2, _A3, _A4)
      in _F0

'inferRecordPat'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'inferRecordPat'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'inferRecordPat'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'inferRecordPat'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'inferRecordPat'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'inferRecordPat'/3(_A0, _A1, _A2)
      in _F0

'inferListPat'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'inferListPat'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'inferListPat'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'inferListPat'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'inferListPat'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'inferListPat'/3(_A0, _A1, _A2)
      in _F0

'inferConsPat'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        let <_F3> = fun (_A3) ->
        apply 'inferConsPat'/4(_A0, _A1, _A2, _A3)
      in _F3
      in _F2
      in _F1
      in _F0

'inferConsPat'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        let <_F2> = fun (_A3) ->
        apply 'inferConsPat'/4(_A0, _A1, _A2, _A3)
      in _F2
      in _F1
      in _F0

'inferConsPat'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        let <_F1> = fun (_A3) ->
        apply 'inferConsPat'/4(_A0, _A1, _A2, _A3)
      in _F1
      in _F0

'inferConsPat'/3 =
  fun (_A0, _A1, _A2) ->
    let <_F0> = fun (_A3) ->
        apply 'inferConsPat'/4(_A0, _A1, _A2, _A3)
      in _F0

'inferConPatsGo'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        let <_F3> = fun (_A3) ->
        let <_F4> = fun (_A4) ->
        apply 'inferConPatsGo'/5(_A0, _A1, _A2, _A3, _A4)
      in _F4
      in _F3
      in _F2
      in _F1
      in _F0

'inferConPatsGo'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        let <_F2> = fun (_A3) ->
        let <_F3> = fun (_A4) ->
        apply 'inferConPatsGo'/5(_A0, _A1, _A2, _A3, _A4)
      in _F3
      in _F2
      in _F1
      in _F0

'inferConPatsGo'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        let <_F1> = fun (_A3) ->
        let <_F2> = fun (_A4) ->
        apply 'inferConPatsGo'/5(_A0, _A1, _A2, _A3, _A4)
      in _F2
      in _F1
      in _F0

'inferConPatsGo'/3 =
  fun (_A0, _A1, _A2) ->
    let <_F0> = fun (_A3) ->
        let <_F1> = fun (_A4) ->
        apply 'inferConPatsGo'/5(_A0, _A1, _A2, _A3, _A4)
      in _F1
      in _F0

'inferConPatsGo'/4 =
  fun (_A0, _A1, _A2, _A3) ->
    let <_F0> = fun (_A4) ->
        apply 'inferConPatsGo'/5(_A0, _A1, _A2, _A3, _A4)
      in _F0

'inferConPats'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        let <_F3> = fun (_A3) ->
        apply 'inferConPats'/4(_A0, _A1, _A2, _A3)
      in _F3
      in _F2
      in _F1
      in _F0

'inferConPats'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        let <_F2> = fun (_A3) ->
        apply 'inferConPats'/4(_A0, _A1, _A2, _A3)
      in _F2
      in _F1
      in _F0

'inferConPats'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        let <_F1> = fun (_A3) ->
        apply 'inferConPats'/4(_A0, _A1, _A2, _A3)
      in _F1
      in _F0

'inferConPats'/3 =
  fun (_A0, _A1, _A2) ->
    let <_F0> = fun (_A3) ->
        apply 'inferConPats'/4(_A0, _A1, _A2, _A3)
      in _F0

'inferBinds'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'inferBinds'/2(_A0, _A1)
      in _F1
      in _F0

'inferBinds'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'inferBinds'/2(_A0, _A1)
      in _F0

'exprToPattern'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'exprToPattern'/1(_A0)
      in _F0

'inferGuardExpr'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'inferGuardExpr'/2(_A0, _A1)
      in _F1
      in _F0

'inferGuardExpr'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'inferGuardExpr'/2(_A0, _A1)
      in _F0

'inferGuard'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'inferGuard'/2(_A0, _A1)
      in _F1
      in _F0

'inferGuard'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'inferGuard'/2(_A0, _A1)
      in _F0

'inferClausesGo'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        let <_F3> = fun (_A3) ->
        let <_F4> = fun (_A4) ->
        apply 'inferClausesGo'/5(_A0, _A1, _A2, _A3, _A4)
      in _F4
      in _F3
      in _F2
      in _F1
      in _F0

'inferClausesGo'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        let <_F2> = fun (_A3) ->
        let <_F3> = fun (_A4) ->
        apply 'inferClausesGo'/5(_A0, _A1, _A2, _A3, _A4)
      in _F3
      in _F2
      in _F1
      in _F0

'inferClausesGo'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        let <_F1> = fun (_A3) ->
        let <_F2> = fun (_A4) ->
        apply 'inferClausesGo'/5(_A0, _A1, _A2, _A3, _A4)
      in _F2
      in _F1
      in _F0

'inferClausesGo'/3 =
  fun (_A0, _A1, _A2) ->
    let <_F0> = fun (_A3) ->
        let <_F1> = fun (_A4) ->
        apply 'inferClausesGo'/5(_A0, _A1, _A2, _A3, _A4)
      in _F1
      in _F0

'inferClausesGo'/4 =
  fun (_A0, _A1, _A2, _A3) ->
    let <_F0> = fun (_A4) ->
        apply 'inferClausesGo'/5(_A0, _A1, _A2, _A3, _A4)
      in _F0

'inferClauses'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        let <_F3> = fun (_A3) ->
        let <_F4> = fun (_A4) ->
        apply 'inferClauses'/5(_A0, _A1, _A2, _A3, _A4)
      in _F4
      in _F3
      in _F2
      in _F1
      in _F0

'inferClauses'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        let <_F2> = fun (_A3) ->
        let <_F3> = fun (_A4) ->
        apply 'inferClauses'/5(_A0, _A1, _A2, _A3, _A4)
      in _F3
      in _F2
      in _F1
      in _F0

'inferClauses'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        let <_F1> = fun (_A3) ->
        let <_F2> = fun (_A4) ->
        apply 'inferClauses'/5(_A0, _A1, _A2, _A3, _A4)
      in _F2
      in _F1
      in _F0

'inferClauses'/3 =
  fun (_A0, _A1, _A2) ->
    let <_F0> = fun (_A3) ->
        let <_F1> = fun (_A4) ->
        apply 'inferClauses'/5(_A0, _A1, _A2, _A3, _A4)
      in _F1
      in _F0

'inferClauses'/4 =
  fun (_A0, _A1, _A2, _A3) ->
    let <_F0> = fun (_A4) ->
        apply 'inferClauses'/5(_A0, _A1, _A2, _A3, _A4)
      in _F0

'guardedExprsToIf'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'guardedExprsToIf'/1(_A0)
      in _F0

'guardsToCondition'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'guardsToCondition'/1(_A0)
      in _F0

'guardClauseToCondExpr'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'guardClauseToCondExpr'/1(_A0)
      in _F0

'wrapWithPatternGuards'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'wrapWithPatternGuards'/2(_A0, _A1)
      in _F1
      in _F0

'wrapWithPatternGuards'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'wrapWithPatternGuards'/2(_A0, _A1)
      in _F0

'buildPatternGuardCases'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'buildPatternGuardCases'/2(_A0, _A1)
      in _F1
      in _F0

'buildPatternGuardCases'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'buildPatternGuardCases'/2(_A0, _A1)
      in _F0

'checkFunction'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'checkFunction'/2(_A0, _A1)
      in _F1
      in _F0

'checkFunction'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'checkFunction'/2(_A0, _A1)
      in _F0

'checkDecl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'checkDecl'/2(_A0, _A1)
      in _F1
      in _F0

'checkDecl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'checkDecl'/2(_A0, _A1)
      in _F0

'checkTypeClass'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'checkTypeClass'/2(_A0, _A1)
      in _F1
      in _F0

'checkTypeClass'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'checkTypeClass'/2(_A0, _A1)
      in _F0

'checkDataType'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'checkDataType'/2(_A0, _A1)
      in _F1
      in _F0

'checkDataType'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'checkDataType'/2(_A0, _A1)
      in _F0

'checkDataTypeWithAliases'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'checkDataTypeWithAliases'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'checkDataTypeWithAliases'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'checkDataTypeWithAliases'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'checkDataTypeWithAliases'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'checkDataTypeWithAliases'/3(_A0, _A1, _A2)
      in _F0

'checkDataTypeWithAllAliases'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        let <_F3> = fun (_A3) ->
        apply 'checkDataTypeWithAllAliases'/4(_A0, _A1, _A2, _A3)
      in _F3
      in _F2
      in _F1
      in _F0

'checkDataTypeWithAllAliases'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        let <_F2> = fun (_A3) ->
        apply 'checkDataTypeWithAllAliases'/4(_A0, _A1, _A2, _A3)
      in _F2
      in _F1
      in _F0

'checkDataTypeWithAllAliases'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        let <_F1> = fun (_A3) ->
        apply 'checkDataTypeWithAllAliases'/4(_A0, _A1, _A2, _A3)
      in _F1
      in _F0

'checkDataTypeWithAllAliases'/3 =
  fun (_A0, _A1, _A2) ->
    let <_F0> = fun (_A3) ->
        apply 'checkDataTypeWithAllAliases'/4(_A0, _A1, _A2, _A3)
      in _F0

'checkNewtypeWithAliases'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'checkNewtypeWithAliases'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'checkNewtypeWithAliases'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'checkNewtypeWithAliases'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'checkNewtypeWithAliases'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'checkNewtypeWithAliases'/3(_A0, _A1, _A2)
      in _F0

'checkNewtypeWithAllAliases'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        let <_F3> = fun (_A3) ->
        apply 'checkNewtypeWithAllAliases'/4(_A0, _A1, _A2, _A3)
      in _F3
      in _F2
      in _F1
      in _F0

'checkNewtypeWithAllAliases'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        let <_F2> = fun (_A3) ->
        apply 'checkNewtypeWithAllAliases'/4(_A0, _A1, _A2, _A3)
      in _F2
      in _F1
      in _F0

'checkNewtypeWithAllAliases'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        let <_F1> = fun (_A3) ->
        apply 'checkNewtypeWithAllAliases'/4(_A0, _A1, _A2, _A3)
      in _F1
      in _F0

'checkNewtypeWithAllAliases'/3 =
  fun (_A0, _A1, _A2) ->
    let <_F0> = fun (_A3) ->
        apply 'checkNewtypeWithAllAliases'/4(_A0, _A1, _A2, _A3)
      in _F0

'buildConstructorTypeGo'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'buildConstructorTypeGo'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'buildConstructorTypeGo'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'buildConstructorTypeGo'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'buildConstructorTypeGo'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'buildConstructorTypeGo'/3(_A0, _A1, _A2)
      in _F0

'buildConstructorType'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'buildConstructorType'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'buildConstructorType'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'buildConstructorType'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'buildConstructorType'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'buildConstructorType'/3(_A0, _A1, _A2)
      in _F0

'buildConstructorTypeWithAliasesGo'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        let <_F3> = fun (_A3) ->
        apply 'buildConstructorTypeWithAliasesGo'/4(_A0, _A1, _A2, _A3)
      in _F3
      in _F2
      in _F1
      in _F0

'buildConstructorTypeWithAliasesGo'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        let <_F2> = fun (_A3) ->
        apply 'buildConstructorTypeWithAliasesGo'/4(_A0, _A1, _A2, _A3)
      in _F2
      in _F1
      in _F0

'buildConstructorTypeWithAliasesGo'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        let <_F1> = fun (_A3) ->
        apply 'buildConstructorTypeWithAliasesGo'/4(_A0, _A1, _A2, _A3)
      in _F1
      in _F0

'buildConstructorTypeWithAliasesGo'/3 =
  fun (_A0, _A1, _A2) ->
    let <_F0> = fun (_A3) ->
        apply 'buildConstructorTypeWithAliasesGo'/4(_A0, _A1, _A2, _A3)
      in _F0

'buildConstructorTypeWithAliases'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        let <_F3> = fun (_A3) ->
        apply 'buildConstructorTypeWithAliases'/4(_A0, _A1, _A2, _A3)
      in _F3
      in _F2
      in _F1
      in _F0

'buildConstructorTypeWithAliases'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        let <_F2> = fun (_A3) ->
        apply 'buildConstructorTypeWithAliases'/4(_A0, _A1, _A2, _A3)
      in _F2
      in _F1
      in _F0

'buildConstructorTypeWithAliases'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        let <_F1> = fun (_A3) ->
        apply 'buildConstructorTypeWithAliases'/4(_A0, _A1, _A2, _A3)
      in _F1
      in _F0

'buildConstructorTypeWithAliases'/3 =
  fun (_A0, _A1, _A2) ->
    let <_F0> = fun (_A3) ->
        apply 'buildConstructorTypeWithAliases'/4(_A0, _A1, _A2, _A3)
      in _F0

'buildConstructorTypeWithAllAliasesGo'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        let <_F3> = fun (_A3) ->
        let <_F4> = fun (_A4) ->
        apply 'buildConstructorTypeWithAllAliasesGo'/5(_A0, _A1, _A2, _A3, _A4)
      in _F4
      in _F3
      in _F2
      in _F1
      in _F0

'buildConstructorTypeWithAllAliasesGo'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        let <_F2> = fun (_A3) ->
        let <_F3> = fun (_A4) ->
        apply 'buildConstructorTypeWithAllAliasesGo'/5(_A0, _A1, _A2, _A3, _A4)
      in _F3
      in _F2
      in _F1
      in _F0

'buildConstructorTypeWithAllAliasesGo'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        let <_F1> = fun (_A3) ->
        let <_F2> = fun (_A4) ->
        apply 'buildConstructorTypeWithAllAliasesGo'/5(_A0, _A1, _A2, _A3, _A4)
      in _F2
      in _F1
      in _F0

'buildConstructorTypeWithAllAliasesGo'/3 =
  fun (_A0, _A1, _A2) ->
    let <_F0> = fun (_A3) ->
        let <_F1> = fun (_A4) ->
        apply 'buildConstructorTypeWithAllAliasesGo'/5(_A0, _A1, _A2, _A3, _A4)
      in _F1
      in _F0

'buildConstructorTypeWithAllAliasesGo'/4 =
  fun (_A0, _A1, _A2, _A3) ->
    let <_F0> = fun (_A4) ->
        apply 'buildConstructorTypeWithAllAliasesGo'/5(_A0, _A1, _A2, _A3, _A4)
      in _F0

'buildConstructorTypeWithAllAliases'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        let <_F3> = fun (_A3) ->
        let <_F4> = fun (_A4) ->
        apply 'buildConstructorTypeWithAllAliases'/5(_A0, _A1, _A2, _A3, _A4)
      in _F4
      in _F3
      in _F2
      in _F1
      in _F0

'buildConstructorTypeWithAllAliases'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        let <_F2> = fun (_A3) ->
        let <_F3> = fun (_A4) ->
        apply 'buildConstructorTypeWithAllAliases'/5(_A0, _A1, _A2, _A3, _A4)
      in _F3
      in _F2
      in _F1
      in _F0

'buildConstructorTypeWithAllAliases'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        let <_F1> = fun (_A3) ->
        let <_F2> = fun (_A4) ->
        apply 'buildConstructorTypeWithAllAliases'/5(_A0, _A1, _A2, _A3, _A4)
      in _F2
      in _F1
      in _F0

'buildConstructorTypeWithAllAliases'/3 =
  fun (_A0, _A1, _A2) ->
    let <_F0> = fun (_A3) ->
        let <_F1> = fun (_A4) ->
        apply 'buildConstructorTypeWithAllAliases'/5(_A0, _A1, _A2, _A3, _A4)
      in _F1
      in _F0

'buildConstructorTypeWithAllAliases'/4 =
  fun (_A0, _A1, _A2, _A3) ->
    let <_F0> = fun (_A4) ->
        apply 'buildConstructorTypeWithAllAliases'/5(_A0, _A1, _A2, _A3, _A4)
      in _F0

'typeExprToTypeWithAliases'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'typeExprToTypeWithAliases'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'typeExprToTypeWithAliases'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'typeExprToTypeWithAliases'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'typeExprToTypeWithAliases'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'typeExprToTypeWithAliases'/3(_A0, _A1, _A2)
      in _F0

'typeExprToTypeWithAllAliases'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        let <_F3> = fun (_A3) ->
        apply 'typeExprToTypeWithAllAliases'/4(_A0, _A1, _A2, _A3)
      in _F3
      in _F2
      in _F1
      in _F0

'typeExprToTypeWithAllAliases'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        let <_F2> = fun (_A3) ->
        apply 'typeExprToTypeWithAllAliases'/4(_A0, _A1, _A2, _A3)
      in _F2
      in _F1
      in _F0

'typeExprToTypeWithAllAliases'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        let <_F1> = fun (_A3) ->
        apply 'typeExprToTypeWithAllAliases'/4(_A0, _A1, _A2, _A3)
      in _F1
      in _F0

'typeExprToTypeWithAllAliases'/3 =
  fun (_A0, _A1, _A2) ->
    let <_F0> = fun (_A3) ->
        apply 'typeExprToTypeWithAllAliases'/4(_A0, _A1, _A2, _A3)
      in _F0

'typeExprToTypeWithEnv'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        let <_F3> = fun (_A3) ->
        let <_F4> = fun (_A4) ->
        apply 'typeExprToTypeWithEnv'/5(_A0, _A1, _A2, _A3, _A4)
      in _F4
      in _F3
      in _F2
      in _F1
      in _F0

'typeExprToTypeWithEnv'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        let <_F2> = fun (_A3) ->
        let <_F3> = fun (_A4) ->
        apply 'typeExprToTypeWithEnv'/5(_A0, _A1, _A2, _A3, _A4)
      in _F3
      in _F2
      in _F1
      in _F0

'typeExprToTypeWithEnv'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        let <_F1> = fun (_A3) ->
        let <_F2> = fun (_A4) ->
        apply 'typeExprToTypeWithEnv'/5(_A0, _A1, _A2, _A3, _A4)
      in _F2
      in _F1
      in _F0

'typeExprToTypeWithEnv'/3 =
  fun (_A0, _A1, _A2) ->
    let <_F0> = fun (_A3) ->
        let <_F1> = fun (_A4) ->
        apply 'typeExprToTypeWithEnv'/5(_A0, _A1, _A2, _A3, _A4)
      in _F1
      in _F0

'typeExprToTypeWithEnv'/4 =
  fun (_A0, _A1, _A2, _A3) ->
    let <_F0> = fun (_A4) ->
        apply 'typeExprToTypeWithEnv'/5(_A0, _A1, _A2, _A3, _A4)
      in _F0

'collectTypeApp'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'collectTypeApp'/1(_A0)
      in _F0

'substituteTypeExpr'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        let <_F3> = fun (_A3) ->
        apply 'substituteTypeExpr'/4(_A0, _A1, _A2, _A3)
      in _F3
      in _F2
      in _F1
      in _F0

'substituteTypeExpr'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        let <_F2> = fun (_A3) ->
        apply 'substituteTypeExpr'/4(_A0, _A1, _A2, _A3)
      in _F2
      in _F1
      in _F0

'substituteTypeExpr'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        let <_F1> = fun (_A3) ->
        apply 'substituteTypeExpr'/4(_A0, _A1, _A2, _A3)
      in _F1
      in _F0

'substituteTypeExpr'/3 =
  fun (_A0, _A1, _A2) ->
    let <_F0> = fun (_A3) ->
        apply 'substituteTypeExpr'/4(_A0, _A1, _A2, _A3)
      in _F0

'typeExprToType'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'typeExprToType'/2(_A0, _A1)
      in _F1
      in _F0

'typeExprToType'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'typeExprToType'/2(_A0, _A1)
      in _F0

'checkTypeAlias'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'checkTypeAlias'/2(_A0, _A1)
      in _F1
      in _F0

'checkTypeAlias'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'checkTypeAlias'/2(_A0, _A1)
      in _F0

'isRecordType'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'isRecordType'/1(_A0)
      in _F0

'collectTypeNames'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'collectTypeNames'/1(_A0)
      in _F0

'collectTypeExprNames'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'collectTypeExprNames'/1(_A0)
      in _F0

'checkModuleSimple'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'checkModuleSimple'/2(_A0, _A1)
      in _F1
      in _F0

'checkModuleSimple'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'checkModuleSimple'/2(_A0, _A1)
      in _F0

'checkModule'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'checkModule'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'checkModule'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'checkModule'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'checkModule'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'checkModule'/3(_A0, _A1, _A2)
      in _F0

'typeCheckModule'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'typeCheckModule'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'typeCheckModule'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'typeCheckModule'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'typeCheckModule'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'typeCheckModule'/3(_A0, _A1, _A2)
      in _F0

'processImports'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'processImports'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'processImports'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'processImports'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'processImports'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'processImports'/3(_A0, _A1, _A2)
      in _F0

'mergeExportsWithTypeAliases'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'mergeExportsWithTypeAliases'/2(_A0, _A1)
      in _F1
      in _F0

'mergeExportsWithTypeAliases'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'mergeExportsWithTypeAliases'/2(_A0, _A1)
      in _F0

'processImportDecl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'processImportDecl'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'processImportDecl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'processImportDecl'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'processImportDecl'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'processImportDecl'/3(_A0, _A1, _A2)
      in _F0

'expandModuleAliases'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'expandModuleAliases'/1(_A0)
      in _F0

'importItem'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'importItem'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'importItem'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'importItem'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'importItem'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'importItem'/3(_A0, _A1, _A2)
      in _F0

'collectResolvedImports'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'collectResolvedImports'/2(_A0, _A1)
      in _F1
      in _F0

'collectResolvedImports'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'collectResolvedImports'/2(_A0, _A1)
      in _F0

'collectFromImportDecl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'collectFromImportDecl'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'collectFromImportDecl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'collectFromImportDecl'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'collectFromImportDecl'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'collectFromImportDecl'/3(_A0, _A1, _A2)
      in _F0

'getExportedNames'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'getExportedNames'/1(_A0)
      in _F0

'getImportItemName'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'getImportItemName'/1(_A0)
      in _F0

'collectImportedAliases'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'collectImportedAliases'/2(_A0, _A1)
      in _F1
      in _F0

'collectImportedAliases'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'collectImportedAliases'/2(_A0, _A1)
      in _F0

'extractExports'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'extractExports'/1(_A0)
      in _F0

'extractExportsWithRegistry'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'extractExportsWithRegistry'/2(_A0, _A1)
      in _F1
      in _F0

'extractExportsWithRegistry'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'extractExportsWithRegistry'/2(_A0, _A1)
      in _F0

'addValuesToExports'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'addValuesToExports'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'addValuesToExports'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'addValuesToExports'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'addValuesToExports'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'addValuesToExports'/3(_A0, _A1, _A2)
      in _F0

'collectTypeAliases'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'collectTypeAliases'/1(_A0)
      in _F0

'collectTypeAliasesWithBase'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'collectTypeAliasesWithBase'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'collectTypeAliasesWithBase'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'collectTypeAliasesWithBase'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'collectTypeAliasesWithBase'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'collectTypeAliasesWithBase'/3(_A0, _A1, _A2)
      in _F0

'collectParamTypeAliases'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'collectParamTypeAliases'/1(_A0)
      in _F0

'processNonFunctions'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'processNonFunctions'/2(_A0, _A1)
      in _F1
      in _F0

'processNonFunctions'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'processNonFunctions'/2(_A0, _A1)
      in _F0

'processNonFunctionsWithAliases'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'processNonFunctionsWithAliases'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'processNonFunctionsWithAliases'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'processNonFunctionsWithAliases'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'processNonFunctionsWithAliases'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'processNonFunctionsWithAliases'/3(_A0, _A1, _A2)
      in _F0

'processInfixDeclarations'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'processInfixDeclarations'/2(_A0, _A1)
      in _F1
      in _F0

'processInfixDeclarations'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'processInfixDeclarations'/2(_A0, _A1)
      in _F0

'addFunctionPlaceholders'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'addFunctionPlaceholders'/2(_A0, _A1)
      in _F1
      in _F0

'addFunctionPlaceholders'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'addFunctionPlaceholders'/2(_A0, _A1)
      in _F0

'addFunctionPlaceholdersWithAliases'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'addFunctionPlaceholdersWithAliases'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'addFunctionPlaceholdersWithAliases'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'addFunctionPlaceholdersWithAliases'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'addFunctionPlaceholdersWithAliases'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'addFunctionPlaceholdersWithAliases'/3(_A0, _A1, _A2)
      in _F0

'checkFunctionBodiesGo'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'checkFunctionBodiesGo'/2(_A0, _A1)
      in _F1
      in _F0

'checkFunctionBodiesGo'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'checkFunctionBodiesGo'/2(_A0, _A1)
      in _F0

'checkFunctionBodies'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'checkFunctionBodies'/2(_A0, _A1)
      in _F1
      in _F0

'checkFunctionBodies'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'checkFunctionBodies'/2(_A0, _A1)
      in _F0

'mergeMultiClauseFunctions'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'mergeMultiClauseFunctions'/1(_A0)
      in _F0

'UnifyErr'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'UnifyErr'/1(_A0)
      in _F0

'UnifyErrWithContext'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'UnifyErrWithContext'/2(_A0, _A1)
      in _F1
      in _F0

'UnifyErrWithContext'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'UnifyErrWithContext'/2(_A0, _A1)
      in _F0

'UnboundVariable'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'UnboundVariable'/1(_A0)
      in _F0

'UndefinedQualifiedImport'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'UndefinedQualifiedImport'/2(_A0, _A1)
      in _F1
      in _F0

'UndefinedQualifiedImport'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'UndefinedQualifiedImport'/2(_A0, _A1)
      in _F0

'NotImplemented'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'NotImplemented'/1(_A0)
      in _F0
end
