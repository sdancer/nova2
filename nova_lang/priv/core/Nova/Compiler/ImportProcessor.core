module 'Nova.Compiler.ImportProcessor' ['collectTypeApp'/1, 'collectTypeExprNames'/1, 'expandModuleAliases'/1, 'getAllExportedNames'/1, 'getExportsConstructors'/1, 'getExportsExpandedTypeAliases'/1, 'getExportsTypeAliases'/1, 'getExportsTypes'/1, 'getExportsValues'/1, 'getItemName'/1, 'isRecordType'/1, 'arrayMap'/2, 'listMap'/2, 'mapMapMaybe'/2, 'mergeExportsWithTypeAliases'/2, 'resolveImports'/2, 'typeExprToType'/2, 'extendEnv'/3, 'extendTypeAlias'/3, 'importItem'/3, 'processImportDecl'/3, 'processImports'/3, 'resolveImportDecl'/3, 'mergeTypeExport'/4, 'typeExprToTypeWithAllAliases'/4, 'collectTypeApp'/0, 'collectTypeExprNames'/0, 'expandModuleAliases'/0, 'getAllExportedNames'/0, 'getExportsConstructors'/0, 'getExportsExpandedTypeAliases'/0, 'getExportsTypeAliases'/0, 'getExportsTypes'/0, 'getExportsValues'/0, 'getItemName'/0, 'isRecordType'/0, 'arrayMap'/0, 'arrayMap'/1, 'listMap'/0, 'listMap'/1, 'mapMapMaybe'/0, 'mapMapMaybe'/1, 'mergeExportsWithTypeAliases'/0, 'mergeExportsWithTypeAliases'/1, 'resolveImports'/0, 'resolveImports'/1, 'typeExprToType'/0, 'typeExprToType'/1, 'extendEnv'/0, 'extendEnv'/1, 'extendEnv'/2, 'extendTypeAlias'/0, 'extendTypeAlias'/1, 'extendTypeAlias'/2, 'importItem'/0, 'importItem'/1, 'importItem'/2, 'processImportDecl'/0, 'processImportDecl'/1, 'processImportDecl'/2, 'processImports'/0, 'processImports'/1, 'processImports'/2, 'resolveImportDecl'/0, 'resolveImportDecl'/1, 'resolveImportDecl'/2, 'mergeTypeExport'/0, 'mergeTypeExport'/1, 'mergeTypeExport'/2, 'mergeTypeExport'/3, 'typeExprToTypeWithAllAliases'/0, 'typeExprToTypeWithAllAliases'/1, 'typeExprToTypeWithAllAliases'/2, 'typeExprToTypeWithAllAliases'/3, 'module_info'/0, 'module_info'/1]
  attributes []
'collectTypeApp'/1 =
  fun (_P0) ->
    case {_P0} of
      <{{'TyExprCon', Name}}> when 'true' ->
        call 'Data.Tuple':'Tuple'(Name, [])
      <{{'TyExprApp', Base, Arg}}> when 'true' ->
        let <_Let0> = apply 'collectTypeApp'/1(Base)
      in case _Let0 of
        <{'Tuple', Name, Args}> when 'true' -> call 'Data.Tuple':'Tuple'(Name, call 'Nova.Prelude':'semigroupAppendImpl'(Args, [Arg]))
      end
      <{_W0}> when 'true' ->
        call 'Data.Tuple':'Tuple'(#{#<85>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<107>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<119>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']])}#, [])
    end

'collectTypeExprNames'/1 =
  fun (Expr) ->
    case Expr of
      <{'TyExprVar', _W0}> when 'true' ->
        call 'Data.Set':'empty'()
      <{'TyExprCon', Name}> when 'true' ->
        call 'Data.Set':'singleton'(Name)
      <{'TyExprArrow', From, To}> when 'true' ->
        call 'Data.Set':'union'(apply 'collectTypeExprNames'/1(From), apply 'collectTypeExprNames'/1(To))
      <{'TyExprRecord', Fields, _W0}> when 'true' ->
        let <FieldsAsArray> = call 'Data.List':'toUnfoldable'(Fields)
      in let <FieldsSets> = apply 'arrayMap'/2(fun (_L0) ->
      case {_L0} of
        <{{'Tuple', _W0, Ty}}> when 'true' -> apply 'collectTypeExprNames'/1(Ty)
      end, FieldsAsArray)
      in call 'Data.Set':'unions'(FieldsSets)
      <{'TyExprForAll', _W0, Inner}> when 'true' ->
        apply 'collectTypeExprNames'/1(Inner)
      <{'TyExprParens', Inner}> when 'true' ->
        apply 'collectTypeExprNames'/1(Inner)
      <{'TyExprApp', Base, Arg}> when 'true' ->
        call 'Data.Set':'union'(apply 'collectTypeExprNames'/1(Base), apply 'collectTypeExprNames'/1(Arg))
      <{'TyExprConstrained', _W0, Inner}> when 'true' ->
        apply 'collectTypeExprNames'/1(Inner)
      <{'TyExprTuple', Items}> when 'true' ->
        let <ItemsAsArray> = call 'Data.List':'toUnfoldable'(Items)
      in let <ItemsSets> = apply 'arrayMap'/2(fun (_Mf0) -> apply 'collectTypeExprNames'/1(_Mf0), ItemsAsArray)
      in call 'Data.Set':'unions'(ItemsSets)
    end

'expandModuleAliases'/1 =
  fun (AliasInfos) ->
    let <Initial> = apply 'mapMapMaybe'/2(fun (Info) ->
      case call 'Data.Array':'null'(call 'maps':'get'('params', Info)) of
      <'true'> when 'true' -> {'Just', apply 'typeExprToType'/2(call 'Data.Map':'empty'(), call 'maps':'get'('body', Info))}
      <'false'> when 'true' -> 'Nothing'
    end, AliasInfos)
      in let <Pass2> = apply 'mapMapMaybe'/2(fun (Info) ->
      case call 'Data.Array':'null'(call 'maps':'get'('params', Info)) of
      <'true'> when 'true' -> {'Just', apply 'typeExprToTypeWithAllAliases'/4(Initial, AliasInfos, call 'Data.Map':'empty'(), call 'maps':'get'('body', Info))}
      <'false'> when 'true' -> 'Nothing'
    end, AliasInfos)
      in let <Pass3> = apply 'mapMapMaybe'/2(fun (Info) ->
      case call 'Data.Array':'null'(call 'maps':'get'('params', Info)) of
      <'true'> when 'true' -> {'Just', apply 'typeExprToTypeWithAllAliases'/4(Pass2, AliasInfos, call 'Data.Map':'empty'(), call 'maps':'get'('body', Info))}
      <'false'> when 'true' -> 'Nothing'
    end, AliasInfos)
      in Pass3

'getAllExportedNames'/1 =
  fun (Exports) ->
    let <ValueNames> = call 'Data.Set':'fromFoldable'(call 'Data.Map':'keys'(call 'maps':'get'('values', Exports)))
      in let <CtorNames> = call 'Data.Set':'fromFoldable'(call 'Data.Map':'keys'(call 'maps':'get'('constructors', Exports)))
      in let <TypeNames> = call 'Data.Set':'fromFoldable'(call 'Data.Map':'keys'(call 'maps':'get'('types', Exports)))
      in let <AliasNames> = call 'Data.Set':'fromFoldable'(call 'Data.Map':'keys'(call 'maps':'get'('typeAliases', Exports)))
      in call 'Data.Set':'unions'([ValueNames, CtorNames, TypeNames, AliasNames])

'getExportsConstructors'/1 =
  fun (Exports) ->
    call 'maps':'get'('constructors', Exports)

'getExportsExpandedTypeAliases'/1 =
  fun (Exports) ->
    call 'maps':'get'('expandedTypeAliases', Exports)

'getExportsTypeAliases'/1 =
  fun (Exports) ->
    call 'maps':'get'('typeAliases', Exports)

'getExportsTypes'/1 =
  fun (Exports) ->
    call 'maps':'get'('types', Exports)

'getExportsValues'/1 =
  fun (Exports) ->
    call 'maps':'get'('values', Exports)

'getItemName'/1 =
  fun (_P0) ->
    case {_P0} of
      <{{'ImportValue', Name}}> when 'true' ->
        Name
      <{{'ImportType', Name, _W0}}> when 'true' ->
        Name
    end

'isRecordType'/1 =
  fun (_P0) ->
    case {_P0} of
      <{{'TyRecord', _W0}}> when 'true' ->
        'true'
      <{_W0}> when 'true' ->
        'false'
    end

'arrayMap'/2 =
  fun (F, Arr) ->
    call 'lists':'map'(F, Arr)

'listMap'/2 =
  fun (F, Xs) ->
    call 'lists':'map'(F, Xs)

'mapMapMaybe'/2 =
  fun (F, M) ->
    let <Pairs> = call 'Data.Map':'toUnfoldable'(M)
      in let <Filtered> = call 'Data.Array':'mapMaybe'(fun (_L0) ->
      case {_L0} of
        <{{'Tuple', K, V}}> when 'true' -> case apply F(V) of
      <{'Just', W}> when 'true' ->
        {'Just', call 'Data.Tuple':'Tuple'(K, W)}
      <'Nothing'> when 'true' ->
        'Nothing'
    end
      end, Pairs)
      in call 'Data.Map':'fromFoldable'(Filtered)

'mergeExportsWithTypeAliases'/2 =
  fun (Env, Exports) ->
    let <ExportsExpandedTypeAliases> = apply 'getExportsExpandedTypeAliases'/1(Exports)
      in let <ExportsTypeAliases> = apply 'getExportsTypeAliases'/1(Exports)
      in let <Env1> = call 'Nova.Compiler.Types':'mergeExportsToEnv'(Env, Exports)
      in let <ModuleAliases> = case call 'Data.Map':'isEmpty'(ExportsExpandedTypeAliases) of
      <'true'> when 'true' -> apply 'expandModuleAliases'/1(ExportsTypeAliases)
      <'false'> when 'true' -> ExportsExpandedTypeAliases
    end
      in letrec 'addIfRecordAlias'/2 = fun (_L0, _L1) ->
      case {_L0, _L1} of
        <{E, {'Tuple', Name, Ty}}> when 'true' -> case apply 'isRecordType'/1(Ty) of
      <'true'> when 'true' -> apply 'extendTypeAlias'/3(E, Name, Ty)
      <'false'> when 'true' -> E
    end
      end
      in let <Env2> = call 'Data.Array':'foldl'(fun (_Mf0, _Mf1) -> apply 'addIfRecordAlias'/2(_Mf0, _Mf1), Env1, call 'Data.Map':'toUnfoldable'(ModuleAliases))
      in Env2

'resolveImports'/2 =
  fun (Registry, Decls) ->
    letrec 'processDecl'/2 = fun (_L0, _L1) ->
      case {_L0, _L1} of
        <{Resolved, {'DeclImport', Imp}}> when 'true' -> apply 'resolveImportDecl'/3(Registry, Resolved, Imp)
        <{Resolved, _W0}> when 'true' -> Resolved
      end
      in call 'Data.Array':'foldl'(fun (_Mf0, _Mf1) -> apply 'processDecl'/2(_Mf0, _Mf1), call 'Data.Map':'empty'(), Decls)

'typeExprToType'/2 =
  fun (Aliases, Expr) ->
    case Expr of
      <{'TyExprVar', Name}> when 'true' ->
        case call 'Data.Map':'lookup'(Name, Aliases) of
      <{'Just', Ty}> when 'true' ->
        Ty
      <'Nothing'> when 'true' ->
        {'TyVar', ч洄骄艾ь犴濮骄吾礤
    end
      <{'TyExprCon', Name}> when 'true' ->
        {'TyCon', ь犴濮骄吾礤п蜱螫骄圯
      <{'TyExprArrow', From, To}> when 'true' ->
        let <_Oa0> = call 'Nova.Compiler.Types':'tArrow'(apply 'typeExprToType'/2(Aliases, From))
      in apply _Oa0(apply 'typeExprToType'/2(Aliases, To))
      <{'TyExprRecord', Fields, MaybeRow}> when 'true' ->
        let <FieldsAsArray> = call 'Data.List':'toUnfoldable'(Fields)
      in let <RowVar> = case MaybeRow of
      <{'Just', RowName}> when 'true' ->
        {'Just', ч洄骄艾ь犴濮骄绎魑犴妪
      <'Nothing'> when 'true' ->
        'Nothing'
    end
      in let <FieldMap> = call 'Data.Map':'fromFoldable'(apply 'arrayMap'/2(fun (_L0) ->
      case {_L0} of
        <{{'Tuple', Label, Ty}}> when 'true' -> call 'Data.Tuple':'Tuple'(Label, apply 'typeExprToType'/2(Aliases, Ty))
      end, FieldsAsArray))
      in {'TyRecord', ф殄熹螫骄崎屐渫狃蝻鳔骄绎髦狎
      <{'TyExprForAll', _W0, Inner}> when 'true' ->
        apply 'typeExprToType'/2(Aliases, Inner)
      <{'TyExprParens', Inner}> when 'true' ->
        apply 'typeExprToType'/2(Aliases, Inner)
      <{'TyExprApp', Base, Arg}> when 'true' ->
        case apply 'typeExprToType'/2(Aliases, Base) of
      <{'TyCon', Tc}> when 'true' ->
        {'TyCon', ь犴濮骄汜祆ы狃螫骇珏臾ě钺礤К糟┈п蜱螫骄汜祆物鲠序屐蹁濮骇箦黹珧秕鹆痧孱渖眇歆ㄣ犰ы狃螫骇珏臾ě狎珞К糟┈坩痧禊豉疱砒痱燥赠疱Н波领獒箦蟋硫绌荸
      <Other> when 'true' ->
        Other
    end
      <{'TyExprConstrained', _W0, Inner}> when 'true' ->
        apply 'typeExprToType'/2(Aliases, Inner)
      <{'TyExprTuple', Items}> when 'true' ->
        let <ItemsAsArray> = call 'Data.List':'toUnfoldable'(Items)
      in let <ArgTypes> = apply 'arrayMap'/2(fun (_Pc0) -> apply 'typeExprToType'/2(Aliases, _Pc0), ItemsAsArray)
      in {'TyCon', ь犴濮骄｛＜复鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北肪ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北簿ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑妇ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺，п蜱螫骄硫缭疱簖
    end

'extendEnv'/3 =
  fun (Env, Name, Scheme) ->
    call 'maps':'merge'(Env, р轭溟铉螫骄汜祆尼翎歪皈骇轭箦螋Ж吾礤鱼桢礤汜祆ы狃螫骇珏臾ě忾钿轭珞К蓬雯у翦钿赠疱领獒螫骢ㄅ铞吾礤赠汜祆ы狃螫骇礤蜱濮ㄅ铞豉疱领獒箦螫骄汜祆尼翎歪皈骇轭箦螋Ж吾礤赠汜祆ы狃螫骇珏臾ě豉疱领獒箦螫蓬雯ч眇矧羯翦恣骢ㄅ痫螋蟋蓬霈婶屙戾寂痫螋笈疳钿邃赠疱领獒箦缶狃痨х弭砒痫螋笈疳钿邃赠疱领獒箦螫报砒痫螋螬轭戾寂痫螋笤疱领獒箦缶狃痨х弭砒痫螋笤疱领獒箦螫报砒痫螋螬轭戾寂痫螋笾犰蹂缶狃痨х弭砒痫螋笾犰蹂螫报砒痫螋螬轭戾寂痫螋竺镱篝蝓泗矧缶狃痨х弭砒痫螋竺镱篝蝓泗矧螫报砒痫螋螬轭戾寂痫螋笤疱缶狃痨х弭砒痫螋笤疱螫报砒痫螋螬轭戾纪镤蹯辶扉狍弩汜箦汜祆尼翎歪皈骇轶彭痿Ж砒痫螋笈疳钿邃赠疱领獒箦螬镦姬趄蹂Ь麒孱趄蹂狃痨у疳钿惋漉戾领獒箦螫报砒痫螋笤疱领獒箦螬姬驷祗濮麒孱趄蹂砒痫螋笈疳钿邃赠疱领獒箦孱轭戾趄邈п滗领煲邈矧淞扉狍弩Н骢ㄅ戾趄邈п滗涉义泔蜾Н骢ㄟ贪咛暴汜箦咛艾咛饼镦见挪г躔戾К吾礤赠麒孱趄蹂汜箦狃痨ч笠邈矧湓疱Н报赠镦姬趄蹂Ь麒孱趄蹂狃痨у翦钿赠疱领獒螫敞挪吾礤赠姬驷祗濮麒孱趄蹂挪孱孱轭汜祆尼翎硫蜥Шф镬潇Ж骢ㄟ玩艾咄姹狃痨п滗涉义泔蜾Н波咄姘咄姹┈努汜祆尼翎歪皈骇麸疹骘熹徕戾Ж惋漉戾领獒箦螬轭汜箦婶屙镦见身痫螋轴祯濮吾礤麒孱趄蹂汜箦汜祆尼翎歪皈骇祜镫躔Ж吾礤砒痫螋笾犰蹂螬镦见术篝К鱼桢礤麒孱趄蹂狃痨п滗领煲邈矧淞扉狍弩Н报狃痨у翦钿蓬雩敞蓬霈吾礤鱼桢礤┅姬物翳轭绉麒孱趄蹂汜箦汜祆尼翎歪皈骇祜镫躔Ж吾礤砒痫螋竺镱篝蝓泗矧螬镦见术篝К鱼桢礤麒孱趄蹂狃痨п滗领煲邈矧淞扉狍弩Н报狃痨у翦钿蓬雩敞蓬霈吾礤鱼桢礤┅姬物翳轭绉麒孱趄蹂汜箦汜祆尼翎歪皈骇祜镫躔Ж吾礤惋漉戾领獒箦螬镦见术篝К赠麒孱趄蹂狃痨п滗领煲邈矧淞扉狍弩Н报狃痨у翦钿赠疱领獒螫敞蓬霈吾礤赠┅姬物翳轭绉麒孱趄蹂狃痨п滗领煲邈矧淞扉狍弩Н报蓬雯孱孱孱见身痫螋赠疱К赠疱吾礤羽邈麒孱趄蹂戾寂铞呔汜箦汜祆尼翎歪皈骇祜镫躔Ж赠疱吾礤砒痫螋笤疱领獒箦螬镦见术篝К领獒笊铈稞麒孱趄蹂戾寂疳钿邃赠汜箦汜祆尼翎歪皈骇祜镫躔Ж赠疱吾礤惋漉戾领獒箦螬镦见术篝К赠麒孱趄蹂赠姬物翳轭绉麒孱趄蹂狃痨豉疱砒痱燥赠疱Н波汜祆尼翎歪皈骇屙痿Ж┈汜祆ы狃螫骇珏臾ě怙澌К领獒笊铈铹孱轭戾家彐弪孱沐湮犴弩狃痨с镬戾泗赠疱砒痱吾礤螫报汜祆ы狃螫骇珏臾ě怙澌К领獒笊铈铹轭戾寂本狃痨у翦钿赠疱领獒螫敞蓬霈赠疱吾礤砒疳钿邃赠轭戾趄邈п滗涉义泔蜾领獒螫骢ㄅ吾礤汜箦汜祆尼翎歪皈骇祜镫躔Ж吾礤惋漉戾领獒箦螬镦见术篝К领獒笤麒孱趄蹂汜箦狃痨ч笠邈矧湓疱Н报领獒笤镦姬趄蹂Ь麒孱趄蹂狃痨у翦钿赠疱领獒螫敞努吾礤领獒笤歼麒孱趄蹂孱歼装麒孱趄蹂孱轭汜祆尼翎硫蜥Шф镬潇Ж骢ㄟ玩艾咄姹狃痨п滗涉义泔蜾领獒螫波咄姘咄姹┈疟汜祆尼翎渝臾骇麸疹骘熹徕戾Ж义驽蝈钽邃吾礤螬姬物翳轭绉麒孱趄蹂汜箦汜祆尼翎歪皈骇祜镫躔Ж赠疱吾礤惋漉戾领獒箦螬镦见术篝К赠麒孱趄蹂狃痨у翦钿赠疱领獒螫敞蓬霈赠疱吾礤赠姬物翳轭绉麒孱趄蹂蓬孱孱轭汜箦汜祆尼翎歪皈骇祜镫躔Ж赠疱吾礤砒痫螋笤疱螬镦姬物翳轭绉麒孱趄蹂狃痨п滗领煲邈矧淞扉狍弩Н报蓬鲞见术篝К赠疱深骘麒孱趄蹂汜箦羽邈镦姬身痫螋领歆麒孱趄蹂狃痨п滗领煲邈矧淞扉狍弩Н报狃痨ы弪珏赠疱砒痫螋Н川蓬鲞砒痫螋蟋赠疱吾礤汜祆ы狃螫骇珏臾ě泔铙趄蹉麸蝮К赠疱深骘┅见身痫螋语礤К敏矧吾礤簖麒孱趄蹂狃痨п滗领煲邈矧淞扉狍弩Н报狃痨ы弪珏赠疱砒痫螋Н川蓬鲞砒痫螋蟋赠疱吾礤汜祆尼翎涕篝Ш麸疹骘熹徕戾Ж敏矧吾礤螬┅姬身痫螋物铄Ь麒孱趄蹂狃痨п滗领煲邈矧淞扉狍弩Н报蓬鲞孱孱孱ю蝻沐篌身痫螋腻沆Н骢ㄒ彗轶趄蓬霈身皓汜箦汜祆物鲠蔑眇殪弪赠疱螫骇祜镫躔惋漉戾Ж义玳篝蝙汜祆ы狃螫骇珏臾ě盹漉戾吾礤К身皓镦姬物翳轭绉麒孱趄蹂蓬见术篝К砒痫螋簖麒孱趄蹂戾寂痫螋笈疳钿邃赠疱领獒箦缶狃痨х弭砒痫螋笈疳钿邃赠疱领獒箦螫报砒痫螋螬轭戾寂痫螋笤疱领獒箦缶狃痨х弭砒痫螋笤疱领獒箦螫报砒痫螋螬轭戾寂铞组翳氧犰殒殄渚汜箦汜祆ы狃螫骇珏臾ě犰獒螫身皓镦见术篝К领獒簖麒孱趄蹂汜祆物鲠蔑眇殪弪赠疱螫骇礤蜱迮痫螋笤锱铞组翳序彐轼Ж蓬霈砒痫螋蟋领獒螬姬物翳轭绉麒孱趄蹂戾继狍粜狎艟汜箦汜祆尼翎郁蜷铉Шъ狍羯钿屮湘Ж汜祆尼翎郁蜷铉Ш嗅趑弪瞌ǎ＜炊鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺）汜祆ы狃螫骇珏臾ě盹漉戾吾礤К身皓镦姬物翳轭绉麒孱趄蹂汜祆ы狃螫骇珏臾ě盹漉戾吾礤К身皓见术篝К射麒孱趄蹂汜祆尼翎郁蜷铉Шт蝻皈ㄣ犰у蜢犷绉骇Ж射癌汜祆ы狃螫骇珏臾ě盹漉戾吾礤К身皓孱轭汜祆物鲠蔑眇殪弪赠疱螫骇礤蜱迮痫螋笤锱铞组翳序彐轼Ж蓬霈砒痫螋蟋提篝嗅螋孱轭汜箦汜祆ы狃螫骇珏臾ě栝溟铉К身皓镦姬趄蹂Ь麒孱趄蹂狃痨ы弪珏砒痫螋笞轸柙疱领獒箦螫波蓬鲎轸柩踽扉骈邃砒痫螋螬姬驷祗濮麒孱趄蹂汜箦汜祆尼翎涕篝Шь蹯歆ㄣ犰ы狃螫骇珏臾ě轸屙螫身皓镦姬趄蹂Ь麒孱趄蹂汜箦汜祆ы狃螫骇珏臾ě犰獒螫身皓镦见术篝К咦褒麒孱趄蹂戾纪镤蹯辶扉狍弩汜箦汜祆尼翎歪皈骇轶彭痿Ж砒痫螋笈疳钿邃赠疱领獒箦螬镦姬趄蹂Ь麒孱趄蹂狃痨у疳钿惋漉戾领獒箦螫报砒痫螋笤疱领獒箦螬姬驷祗濮麒孱趄蹂砒痫螋笈疳钿邃赠疱领獒箦孱轭戾趄邈п滗涉义泔蜾领獒螫骢ㄟ贪咛暴汜箦咛艾咛饼镦见努г躔戾К吾礤赠麒孱趄蹂汜箦狃痨ч笠邈矧湓疱Н报赠镦姬趄蹂Ь麒孱趄蹂狃痨у翦钿赠疱领獒螫敞努吾礤赠姬驷祗濮麒孱趄蹂孱孱轭汜祆尼翎硫蜥Шф镬潇Ж骢ㄟ玩艾咄姹狃痨п滗涉义泔蜾领獒螫波咄姘咄姹┈蓬鲎轸柩踽扉骈邃汜祆尼翎歪皈骇麸疹骘熹徕戾Ж惋漉戾领獒箦螬姬物翳轭绉麒孱趄蹂狃痨ы弪珏砒痫螋笞轸柙疱领獒箦螫波蓬鲎轸柩踽扉骈邃砒痫螋螬孱姬驷祗濮麒孱趄蹂汜祆尼翎涕篝Шф镬潇Ж骢ㄟ秀艾咝惚狃痨ч眇矧羯翦恣敞砒痫螋蟋咝惆咝惚┈蓬鲎轸柩踽扉骈邃汜祆ы狃螫骇珏臾ě轸屙螫身皓孱孱孱ю蝻沐篌身痫螋螫骢ㄒ彗轶趄蓬霈腻沆螬戾趄邈ю蝻沐篌腻沆Н骢ㄟ贪咛暴汜箦咛艾咛饼镦见努腻沆身痫螋К身瘕麒孱趄蹂狃痨ю蝻沐篌身痫螋腻沆Н敞义玳篝蝙努身皓见努咦褒麒孱趄蹂孱轭汜祆尼翎硫蜥Шф镬潇Ж骢ㄟ玩艾咄姹狃痨ю蝻沐篌腻沆Н波咄姘咄姹┈蓬霈腻沆螬蝈箫祧迳眇矧裟邈歆骢ㄒ彗轶趄义箫祧邃身皓汜箦汜祆物鲠蔑眇殪弪赠疱螫骇祜镫躔惋漉戾Ж义玳篝蝙汜祆ы狃螫骇珏臾ě盹漉戾吾礤К身皓镦姬物翳轭绉麒孱趄蹂义箫祧邃见术篝К砒痫螋簖麒孱趄蹂汜箦汜祆ы狃螫骇珏臾ě栝溟铉К身皓镦姬趄蹂Ь麒孱趄蹂戾剂祆吾礤缶狃痨х弭领炫痫螋邃吾礤螫报砒痫螋螬轭戾忌翦眢馏硫蜥汜祆尼翎涕篝Ш麸疹骘熹徕戾Ж汜祆ы狃螫骇珏臾ě轸屙螫身皓轭戾既殇溴钗犴弩汜祆尼翎渝臾骇骝镯骑熹徕戾Ж狃痨п蝌狴歪皈波骢ㄟ玩癌狃痨х弭婶屙吾礤Н报咄姘┈婶屙罅罅蝌狴┅轭戾忌眇矧翦湮犴弩汜祆尼翎渝臾骇溟骀弪孱沐Ж领煳犴弩乳滗孱吾礤螬轭戾忌眇矧翦淞蝌狴汜祆尼翎渝臾骇麸疹骘熹徕戾Ж身痫螋邃吾礤螬轭汜祆尼翎硫蜥Шф镬潇Ж骢ㄍ吾礤汜祆尼翎歪皈骇轭箦螋Ж吾礤汜祆ы狃螫骇珏臾ě盹漉戾吾礤К身皓桐义箫祧邃身痫螋邃硫蜥姬驷祗濮麒孱趄蹂汜箦汜祆尼翎涕篝Шь蹯歆ㄣ犰ы狃螫骇珏臾ě轸屙螫身皓镦姬趄蹂Ь麒孱趄蹂戾剂祆吾礤缶狃痨х弭领炫痫螋邃吾礤螫报砒痫螋螬轭戾剂祆吾礤罅蝌狴汜祆尼翎渝臾骇麸疹骘熹徕戾Ж领煳犴弩轭汜祆尼翎硫蜥Шф镬潇Ж骢ㄍ吾礤汜祆尼翎歪皈骇轭箦螋Ж吾礤汜祆ы狃螫骇珏臾ě盹漉戾吾礤К身皓桐义箫祧邃领煳犴弩硫蜥姬驷祗濮麒孱趄蹂戾忌翦眢硫蜥汜祆尼翎涕篝Ш麸疹骘熹徕戾Ж汜祆ы狃螫骇珏臾ě轸屙螫身皓轭汜祆尼翎硫蜥Шф镬潇Ж骢ㄍ婶屙汜祆尼翎歪皈骇轭箦螋Ж狃痨х弭婶屙吾礤Н报婶屙┈汜祆ы狃螫骇珏臾ě盹漉戾吾礤К身皓桐义箫祧邃婶屙罅蝌狴孱孱孱ы弪珏赠疱砒痫螋Н骢ㄅ铞砒痫螋蟋咦艾敏矧吾礤螬戾趄邈п滗敏矧Н骢ㄅ敏矧吾礤汜箦汜祆尼翎歪皈骇祜镫躔Ж敏矧吾礤汜祆ы狃螫骇珏臾ě泔铙趄蹉麸蝮К砒痫螋螬镦见术篝К鱼桢礤麒孱趄蹂狃痨у翦钿蓬雩敞努敏矧吾礤鱼桢礤姬物翳轭绉麒孱趄蹂孱轭汜祆尼翎硫蜥Шф镬潇Ж骢ㄟ玩艾咄姹狃痨п滗敏矧Н波咄姘咄姹┈蓬霈敏矧吾礤螬豉疱砒痱燥赠疱组翳领炝扉狍弩Н骢ㄓ轫痨辶扉狍弩契祆领獒箦蟋嗅蜥砹扉狍弩砒痱汜箦砒痱镦见г砒痱轴颛吾礤麒孱趄蹂汜箦汜祆尼翎歪皈骇祜镫躔Ж吾礤嗅蜥砹扉狍弩镦见术篝К赠麒孱趄蹂赠姬物翳轭绉麒孱趄蹂汜箦汜祆尼翎歪皈骇祜镫躔Ж吾礤娱眇戾领獒箦螬镦见术篝К赠麒孱趄蹂赠姬物翳轭绉麒孱趄蹂г轴颛ч洄骄艾ь犴濮骄吾礤
    end
    end
      <{'TyExprCon', Name}> when 'true' ->
        case call 'Data.Map':'lookup'(Name, FullAliases) of
      <{'Just', AliasInfo}> when 'true' ->
        case call 'Data.Array':'null'(call 'maps':'get'('params', AliasInfo)) of
          <'true'> when 'true' -> apply 'typeExprToTypeWithAllAliases'/4(SimpleAliases, FullAliases, ParamAliases, call 'maps':'get'('body', AliasInfo))
          <_> when 'true' -> {'TyCon', ь犴濮骄吾礤п蜱螫骄圯
        end
      <_W0> when 'true' ->
        {'TyCon', ь犴濮骄吾礤п蜱螫骄圯
    end
      <{'TyExprArrow', From, To}> when 'true' ->
        let <_Oa0> = call 'Nova.Compiler.Types':'tArrow'(apply 'typeExprToTypeWithAllAliases'/4(SimpleAliases, FullAliases, ParamAliases, From))
      in apply _Oa0(apply 'typeExprToTypeWithAllAliases'/4(SimpleAliases, FullAliases, ParamAliases, To))
      <{'TyExprRecord', Fields, MaybeRow}> when 'true' ->
        let <FieldsAsArray> = call 'Data.List':'toUnfoldable'(Fields)
      in let <RowVar> = case MaybeRow of
      <{'Just', RowName}> when 'true' ->
        case call 'Data.Map':'lookup'(RowName, ParamAliases) of
      <{'Just', {'TyVar', V}}> when 'true' ->
        {'Just', V}
      <{'Just', _W0}> when 'true' ->
        'Nothing'
      <'Nothing'> when 'true' ->
        {'Just', ч洄骄艾ь犴濮骄绎魑犴妪
    end
      <'Nothing'> when 'true' ->
        'Nothing'
    end
      in let <FieldMap> = call 'Data.Map':'fromFoldable'(apply 'arrayMap'/2(fun (_L0) ->
      case {_L0} of
        <{{'Tuple', Label, Ty}}> when 'true' -> call 'Data.Tuple':'Tuple'(Label, apply 'typeExprToTypeWithAllAliases'/4(SimpleAliases, FullAliases, ParamAliases, Ty))
      end, FieldsAsArray))
      in {'TyRecord', ф殄熹螫骄崎屐渫狃蝻鳔骄绎髦狎
      <{'TyExprForAll', _W0, Inner}> when 'true' ->
        apply 'typeExprToTypeWithAllAliases'/4(SimpleAliases, FullAliases, ParamAliases, Inner)
      <{'TyExprParens', Inner}> when 'true' ->
        apply 'typeExprToTypeWithAllAliases'/4(SimpleAliases, FullAliases, ParamAliases, Inner)
      <{'TyExprApp', _W0, _W1}> when 'true' ->
        let <_Let0> = apply 'collectTypeApp'/1(Expr)
      in case _Let0 of
        <{'Tuple', ConName, Args}> when 'true' -> let <ArgTypes> = apply 'arrayMap'/2(fun (_Pc0) -> apply 'typeExprToTypeWithAllAliases'/4(SimpleAliases, FullAliases, ParamAliases, _Pc0), Args)
      in case call 'Data.Map':'lookup'(ConName, FullAliases) of
      <{'Just', AliasInfo}> when 'true' ->
        case call 'erlang':'=:='(call 'Data.Array':'length'(ArgTypes), call 'Data.Array':'length'(call 'maps':'get'('params', AliasInfo))) of
          <'true'> when 'true' -> let <ParamMap> = call 'Data.Map':'fromFoldable'(call 'Data.Array':'zip'(call 'maps':'get'('params', AliasInfo), ArgTypes))
      in apply 'typeExprToTypeWithAllAliases'/4(SimpleAliases, FullAliases, ParamMap, call 'maps':'get'('body', AliasInfo))
          <_> when 'true' -> {'TyCon', ь犴濮骄蔑钗犴瀣п蜱螫骄硫缭疱簖
        end
      <_W0> when 'true' ->
        {'TyCon', ь犴濮骄蔑钗犴瀣п蜱螫骄硫缭疱簖
    end
      end
      <{'TyExprConstrained', _W0, Inner}> when 'true' ->
        apply 'typeExprToTypeWithAllAliases'/4(SimpleAliases, FullAliases, ParamAliases, Inner)
      <{'TyExprTuple', Items}> when 'true' ->
        let <ItemsAsArray> = call 'Data.List':'toUnfoldable'(Items)
      in let <ArgTypes> = apply 'arrayMap'/2(fun (_Pc0) -> apply 'typeExprToTypeWithAllAliases'/4(SimpleAliases, FullAliases, ParamAliases, _Pc0), ItemsAsArray)
      in {'TyCon', ь犴濮骄｛＜复鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北肪ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北簿ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑妇ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺，п蜱螫骄硫缭疱簖
    end

'collectTypeApp'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'collectTypeApp'/1(_A0)
      in _F0

'collectTypeExprNames'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'collectTypeExprNames'/1(_A0)
      in _F0

'expandModuleAliases'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'expandModuleAliases'/1(_A0)
      in _F0

'getAllExportedNames'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'getAllExportedNames'/1(_A0)
      in _F0

'getExportsConstructors'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'getExportsConstructors'/1(_A0)
      in _F0

'getExportsExpandedTypeAliases'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'getExportsExpandedTypeAliases'/1(_A0)
      in _F0

'getExportsTypeAliases'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'getExportsTypeAliases'/1(_A0)
      in _F0

'getExportsTypes'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'getExportsTypes'/1(_A0)
      in _F0

'getExportsValues'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'getExportsValues'/1(_A0)
      in _F0

'getItemName'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'getItemName'/1(_A0)
      in _F0

'isRecordType'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'isRecordType'/1(_A0)
      in _F0

'arrayMap'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'arrayMap'/2(_A0, _A1)
      in _F1
      in _F0

'arrayMap'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'arrayMap'/2(_A0, _A1)
      in _F0

'listMap'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'listMap'/2(_A0, _A1)
      in _F1
      in _F0

'listMap'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'listMap'/2(_A0, _A1)
      in _F0

'mapMapMaybe'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'mapMapMaybe'/2(_A0, _A1)
      in _F1
      in _F0

'mapMapMaybe'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'mapMapMaybe'/2(_A0, _A1)
      in _F0

'mergeExportsWithTypeAliases'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'mergeExportsWithTypeAliases'/2(_A0, _A1)
      in _F1
      in _F0

'mergeExportsWithTypeAliases'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'mergeExportsWithTypeAliases'/2(_A0, _A1)
      in _F0

'resolveImports'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'resolveImports'/2(_A0, _A1)
      in _F1
      in _F0

'resolveImports'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'resolveImports'/2(_A0, _A1)
      in _F0

'typeExprToType'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'typeExprToType'/2(_A0, _A1)
      in _F1
      in _F0

'typeExprToType'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'typeExprToType'/2(_A0, _A1)
      in _F0

'extendEnv'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'extendEnv'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'extendEnv'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'extendEnv'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'extendEnv'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'extendEnv'/3(_A0, _A1, _A2)
      in _F0

'extendTypeAlias'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'extendTypeAlias'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'extendTypeAlias'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'extendTypeAlias'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'extendTypeAlias'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'extendTypeAlias'/3(_A0, _A1, _A2)
      in _F0

'importItem'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'importItem'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'importItem'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'importItem'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'importItem'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'importItem'/3(_A0, _A1, _A2)
      in _F0

'processImportDecl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'processImportDecl'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'processImportDecl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'processImportDecl'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'processImportDecl'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'processImportDecl'/3(_A0, _A1, _A2)
      in _F0

'processImports'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'processImports'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'processImports'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'processImports'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'processImports'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'processImports'/3(_A0, _A1, _A2)
      in _F0

'resolveImportDecl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'resolveImportDecl'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'resolveImportDecl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'resolveImportDecl'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'resolveImportDecl'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'resolveImportDecl'/3(_A0, _A1, _A2)
      in _F0

'mergeTypeExport'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        let <_F3> = fun (_A3) ->
        apply 'mergeTypeExport'/4(_A0, _A1, _A2, _A3)
      in _F3
      in _F2
      in _F1
      in _F0

'mergeTypeExport'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        let <_F2> = fun (_A3) ->
        apply 'mergeTypeExport'/4(_A0, _A1, _A2, _A3)
      in _F2
      in _F1
      in _F0

'mergeTypeExport'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        let <_F1> = fun (_A3) ->
        apply 'mergeTypeExport'/4(_A0, _A1, _A2, _A3)
      in _F1
      in _F0

'mergeTypeExport'/3 =
  fun (_A0, _A1, _A2) ->
    let <_F0> = fun (_A3) ->
        apply 'mergeTypeExport'/4(_A0, _A1, _A2, _A3)
      in _F0

'typeExprToTypeWithAllAliases'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        let <_F3> = fun (_A3) ->
        apply 'typeExprToTypeWithAllAliases'/4(_A0, _A1, _A2, _A3)
      in _F3
      in _F2
      in _F1
      in _F0

'typeExprToTypeWithAllAliases'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        let <_F2> = fun (_A3) ->
        apply 'typeExprToTypeWithAllAliases'/4(_A0, _A1, _A2, _A3)
      in _F2
      in _F1
      in _F0

'typeExprToTypeWithAllAliases'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        let <_F1> = fun (_A3) ->
        apply 'typeExprToTypeWithAllAliases'/4(_A0, _A1, _A2, _A3)
      in _F1
      in _F0

'typeExprToTypeWithAllAliases'/3 =
  fun (_A0, _A1, _A2) ->
    let <_F0> = fun (_A3) ->
        apply 'typeExprToTypeWithAllAliases'/4(_A0, _A1, _A2, _A3)
      in _F0

'module_info'/0 = fun () -> call 'erlang':'get_module_info'('Nova.Compiler.ImportProcessor')

'module_info'/1 = fun (_0) -> call 'erlang':'get_module_info'('Nova.Compiler.ImportProcessor', _0)
end
