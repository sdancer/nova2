module 'Nova.Compiler.CstLayout' ['rootLayoutDelim'/0, 'isIndented'/1, 'currentIndentGo'/1, 'currentIndent'/0, 'isTopDecl'/2, 'lytToken'/2, 'insertLayout'/3, 'LytRoot'/0, 'LytTopDecl'/0, 'LytTopDeclHead'/0, 'LytDeclGuard'/0, 'LytCase'/0, 'LytCaseBinders'/0, 'LytCaseGuard'/0, 'LytLambdaBinders'/0, 'LytParen'/0, 'LytBrace'/0, 'LytSquare'/0, 'LytIf'/0, 'LytThen'/0, 'LytProperty'/0, 'LytForall'/0, 'LytTick'/0, 'LytLet'/0, 'LytLetStmt'/0, 'LytWhere'/0, 'LytOf'/0, 'LytDo'/0, 'LytAdo'/0, 'isIndented'/0, 'currentIndentGo'/0, 'isTopDecl'/0, 'isTopDecl'/1, 'lytToken'/0, 'lytToken'/1, 'insertLayout'/0, 'insertLayout'/1, 'insertLayout'/2]
  attributes []
% Data type: LayoutDelim
% Constructors: LytRoot, LytTopDecl, LytTopDeclHead, LytDeclGuard, LytCase, LytCaseBinders, LytCaseGuard, LytLambdaBinders, LytParen, LytBrace, LytSquare, LytIf, LytThen, LytProperty, LytForall, LytTick, LytLet, LytLetStmt, LytWhere, LytOf, LytDo, LytAdo

'LytRoot'/0 =
  fun () ->
    'LytRoot'

'LytTopDecl'/0 =
  fun () ->
    'LytTopDecl'

'LytTopDeclHead'/0 =
  fun () ->
    'LytTopDeclHead'

'LytDeclGuard'/0 =
  fun () ->
    'LytDeclGuard'

'LytCase'/0 =
  fun () ->
    'LytCase'

'LytCaseBinders'/0 =
  fun () ->
    'LytCaseBinders'

'LytCaseGuard'/0 =
  fun () ->
    'LytCaseGuard'

'LytLambdaBinders'/0 =
  fun () ->
    'LytLambdaBinders'

'LytParen'/0 =
  fun () ->
    'LytParen'

'LytBrace'/0 =
  fun () ->
    'LytBrace'

'LytSquare'/0 =
  fun () ->
    'LytSquare'

'LytIf'/0 =
  fun () ->
    'LytIf'

'LytThen'/0 =
  fun () ->
    'LytThen'

'LytProperty'/0 =
  fun () ->
    'LytProperty'

'LytForall'/0 =
  fun () ->
    'LytForall'

'LytTick'/0 =
  fun () ->
    'LytTick'

'LytLet'/0 =
  fun () ->
    'LytLet'

'LytLetStmt'/0 =
  fun () ->
    'LytLetStmt'

'LytWhere'/0 =
  fun () ->
    'LytWhere'

'LytOf'/0 =
  fun () ->
    'LytOf'

'LytDo'/0 =
  fun () ->
    'LytDo'

'LytAdo'/0 =
  fun () ->
    'LytAdo'

'rootLayoutDelim'/0 =
  fun () ->
    apply 'LytRoot'/0()

'isIndented'/1 =
  fun (Lyt) ->
    case Lyt of
      <'LytLet'> when 'true' ->
        'true'
      <'LytLetStmt'> when 'true' ->
        'true'
      <'LytWhere'> when 'true' ->
        'true'
      <'LytOf'> when 'true' ->
        'true'
      <'LytDo'> when 'true' ->
        'true'
      <'LytAdo'> when 'true' ->
        'true'
      <_W0> when 'true' ->
        'false'
    end

'currentIndentGo'/1 =
  fun (Stk) ->
    case Stk of
      <[{'Tuple', Pos, Lyt} | Rest]> when 'true' ->
        case apply 'isIndented'/1(Lyt) of
      <'true'> when 'true' -> {'Just', Pos}
      <'false'> when 'true' -> apply 'currentIndentGo'/1(Rest)
    end
      <_W0> when 'true' ->
        'Nothing'
    end

'currentIndent'/0 =
  fun () ->
    fun (_Mf0) -> apply 'currentIndentGo'/1(_Mf0)

'isTopDecl'/2 =
  fun (TokPos, Stack) ->
    case Stack of
      <[{'Tuple', LytPos, Lyt1} | Rest]> when 'true' ->
        case call 'erlang':'=:='(Lyt1, apply 'LytWhere'/0()) of
      <'true'> when 'true' -> case Rest of
      <[{'Tuple', _W0, Lyt2} | []]> when 'true' ->
        case call 'erlang':'=:='(Lyt2, apply 'LytRoot'/0()) of <'true'> when 'true' -> call 'erlang':'=:='(call 'maps':'get'('column', TokPos), call 'maps':'get'('column', LytPos)) <_> when 'true' -> 'false' end
      <_W0> when 'true' ->
        'false'
    end
      <'false'> when 'true' -> 'false'
    end
      <_W0> when 'true' ->
        'false'
    end

'lytToken'/2 =
  fun (Pos, Value) ->
    ~{'range'=>~{'start'=>Pos,'end'=>Pos}~,'leadingComments'=>[],'trailingComments'=>[],'value'=>Value}~

'insertLayout'/3 =
  fun (Src, NextPos, Stack) ->
    let <TokPos> = call 'maps':'get'('start', call 'maps':'get'('range', Src))
      in let <Tok> = call 'maps':'get'('value', Src)
      in letrec 'insert'/1 = fun (State) ->
      case Tok of
      <{'TokLowerName', 'Nothing', "data"}> when 'true' ->
        case let <_HashF> = fun (_Mf0) -> apply 'insertDefault'/1(_Mf0) in apply _HashF(State) of
      <State_ = {'Tuple', Stk_, _W0}> when 'true' ->
        case apply 'isTopDecl'/2(TokPos, Stk_) of
          <'true'> when 'true' -> let <_HashF> = fun (_Pc0) -> apply 'pushStack'/3(TokPos, apply 'LytTopDecl'/0(), _Pc0) in apply _HashF(State_)
          <_> when 'true' -> let <_HashF> = fun (_Pc0) -> apply 'popStack'/2(fun (X) -> call 'erlang':'=:='(X, apply 'LytProperty'/0()), _Pc0) in apply _HashF(State_)
        end
      <State_> when 'true' ->
        let <_HashF> = fun (_Pc0) -> apply 'popStack'/2(fun (X) -> call 'erlang':'=:='(X, apply 'LytProperty'/0()), _Pc0) in apply _HashF(State_)
    end
      <{'TokLowerName', 'Nothing', "class"}> when 'true' ->
        case let <_HashF> = fun (_Mf0) -> apply 'insertDefault'/1(_Mf0) in apply _HashF(State) of
      <State_ = {'Tuple', Stk_, _W0}> when 'true' ->
        case apply 'isTopDecl'/2(TokPos, Stk_) of
          <'true'> when 'true' -> let <_HashF> = fun (_Pc0) -> apply 'pushStack'/3(TokPos, apply 'LytTopDeclHead'/0(), _Pc0) in apply _HashF(State_)
          <_> when 'true' -> let <_HashF> = fun (_Pc0) -> apply 'popStack'/2(fun (X) -> call 'erlang':'=:='(X, apply 'LytProperty'/0()), _Pc0) in apply _HashF(State_)
        end
      <State_> when 'true' ->
        let <_HashF> = fun (_Pc0) -> apply 'popStack'/2(fun (X) -> call 'erlang':'=:='(X, apply 'LytProperty'/0()), _Pc0) in apply _HashF(State_)
    end
      <{'TokLowerName', 'Nothing', "where"}> when 'true' ->
        case Stack of
      <[{'Tuple', _W0, 'LytTopDeclHead'} | Stk_]> when 'true' ->
        let <_HashF> = fun (_Pc0) -> apply 'insertStart'/2(apply 'LytWhere'/0(), _Pc0) in apply _HashF(let <_HashF> = fun (_Pc0) -> apply 'insertToken'/2(Src, _Pc0) in apply _HashF(call 'Data.Tuple':'Tuple'(Stk_, call 'Data.Tuple':'snd'(State))))
      <[{'Tuple', _W0, 'LytProperty'} | Stk_]> when 'true' ->
        let <_HashF> = fun (_Pc0) -> apply 'insertToken'/2(Src, _Pc0) in apply _HashF(call 'Data.Tuple':'Tuple'(Stk_, call 'Data.Tuple':'snd'(State)))
      <_W0> when 'true' ->
        let <_HashF> = fun (_Pc0) -> apply 'insertStart'/2(apply 'LytWhere'/0(), _Pc0) in apply _HashF(let <_HashF> = fun (_Pc0) -> apply 'insertToken'/2(Src, _Pc0) in apply _HashF(let <_HashF> = apply 'collapse'/1(fun (_Mf0, _Mf1) -> apply 'whereP'/2(_Mf0, _Mf1)) in apply _HashF(State)))
    end
      <{'TokLowerName', 'Nothing', "in"}> when 'true' ->
        case let <_Oa0> = apply 'collapse'/1(fun (_Mf0, _Mf1) -> apply 'inP'/2(_Mf0, _Mf1))
      in apply _Oa0(State) of
      <{'Tuple', [{'Tuple', Pos1, 'LytLetStmt'} | [{'Tuple', Pos2, 'LytAdo'} | Stk_]], Acc_}> when 'true' ->
        let <_HashF> = fun (_Pc0) -> apply 'insertToken'/2(Src, _Pc0) in apply _HashF(let <_HashF> = apply 'insertEnd'/1(call 'maps':'get'('column', Pos2)) in apply _HashF(let <_HashF> = apply 'insertEnd'/1(call 'maps':'get'('column', Pos1)) in apply _HashF(call 'Data.Tuple':'Tuple'(Stk_, Acc_))))
      <{'Tuple', [{'Tuple', Pos1, Lyt} | Stk_], Acc_}> when 'true' ->
        case apply 'isIndented'/1(Lyt) of
      <'true'> when 'true' -> let <_HashF> = fun (_Pc0) -> apply 'insertToken'/2(Src, _Pc0) in apply _HashF(let <_HashF> = apply 'insertEnd'/1(call 'maps':'get'('column', Pos1)) in apply _HashF(call 'Data.Tuple':'Tuple'(Stk_, Acc_)))
      <'false'> when 'true' -> let <_HashF> = fun (_Pc0) -> apply 'popStack'/2(fun (X) -> call 'erlang':'=:='(X, apply 'LytProperty'/0()), _Pc0) in apply _HashF(let <_HashF> = fun (_Mf0) -> apply 'insertDefault'/1(_Mf0) in apply _HashF(State))
    end
      <_W0> when 'true' ->
        let <_HashF> = fun (_Pc0) -> apply 'popStack'/2(fun (X) -> call 'erlang':'=:='(X, apply 'LytProperty'/0()), _Pc0) in apply _HashF(let <_HashF> = fun (_Mf0) -> apply 'insertDefault'/1(_Mf0) in apply _HashF(State))
    end
      <{'TokLowerName', 'Nothing', "let"}> when 'true' ->
        let <_HashF> = fun (_Pc0) -> apply 'insertKwProperty'/2(fun (_Mf0) -> apply 'letNext'/1(_Mf0), _Pc0) in apply _HashF(State)
      <{'TokLowerName', _W0, "do"}> when 'true' ->
        let <_HashF> = fun (_Pc0) -> apply 'insertKwProperty'/2(fun (_Pc0) -> apply 'insertStart'/2(apply 'LytDo'/0(), _Pc0), _Pc0) in apply _HashF(State)
      <{'TokLowerName', _W0, "ado"}> when 'true' ->
        let <_HashF> = fun (_Pc0) -> apply 'insertKwProperty'/2(fun (_Pc0) -> apply 'insertStart'/2(apply 'LytAdo'/0(), _Pc0), _Pc0) in apply _HashF(State)
      <{'TokLowerName', 'Nothing', "case"}> when 'true' ->
        let <_HashF> = fun (_Pc0) -> apply 'insertKwProperty'/2(fun (_Pc0) -> apply 'pushStack'/3(TokPos, apply 'LytCase'/0(), _Pc0), _Pc0) in apply _HashF(State)
      <{'TokLowerName', 'Nothing', "of"}> when 'true' ->
        case let <_Oa0> = apply 'collapse'/1(fun (_Mf0, _Mf1) -> apply 'indentedP'/2(_Mf0, _Mf1))
      in apply _Oa0(State) of
      <{'Tuple', [{'Tuple', _W0, 'LytCase'} | Stk_], Acc_}> when 'true' ->
        let <_HashF> = fun (_Pc0) -> apply 'pushStack'/3(NextPos, apply 'LytCaseBinders'/0(), _Pc0) in apply _HashF(let <_HashF> = fun (_Pc0) -> apply 'insertStart'/2(apply 'LytOf'/0(), _Pc0) in apply _HashF(let <_HashF> = fun (_Pc0) -> apply 'insertToken'/2(Src, _Pc0) in apply _HashF(call 'Data.Tuple':'Tuple'(Stk_, Acc_))))
      <State_> when 'true' ->
        let <_HashF> = fun (_Pc0) -> apply 'popStack'/2(fun (X) -> call 'erlang':'=:='(X, apply 'LytProperty'/0()), _Pc0) in apply _HashF(let <_HashF> = fun (_Mf0) -> apply 'insertDefault'/1(_Mf0) in apply _HashF(State_))
    end
      <{'TokLowerName', 'Nothing', "if"}> when 'true' ->
        let <_HashF> = fun (_Pc0) -> apply 'insertKwProperty'/2(fun (_Pc0) -> apply 'pushStack'/3(TokPos, apply 'LytIf'/0(), _Pc0), _Pc0) in apply _HashF(State)
      <{'TokLowerName', 'Nothing', "then"}> when 'true' ->
        case let <_HashF> = apply 'collapse'/1(fun (_Mf0, _Mf1) -> apply 'indentedP'/2(_Mf0, _Mf1)) in apply _HashF(State) of
      <{'Tuple', [{'Tuple', _W0, 'LytIf'} | Stk_], Acc_}> when 'true' ->
        let <_HashF> = fun (_Pc0) -> apply 'pushStack'/3(TokPos, apply 'LytThen'/0(), _Pc0) in apply _HashF(let <_HashF> = fun (_Pc0) -> apply 'insertToken'/2(Src, _Pc0) in apply _HashF(call 'Data.Tuple':'Tuple'(Stk_, Acc_)))
      <_W0> when 'true' ->
        let <_HashF> = fun (_Pc0) -> apply 'popStack'/2(fun (X) -> call 'erlang':'=:='(X, apply 'LytProperty'/0()), _Pc0) in apply _HashF(let <_HashF> = fun (_Mf0) -> apply 'insertDefault'/1(_Mf0) in apply _HashF(State))
    end
      <{'TokLowerName', 'Nothing', "else"}> when 'true' ->
        case let <_HashF> = apply 'collapse'/1(fun (_Mf0, _Mf1) -> apply 'indentedP'/2(_Mf0, _Mf1)) in apply _HashF(State) of
      <{'Tuple', [{'Tuple', _W0, 'LytThen'} | Stk_], Acc_}> when 'true' ->
        let <_HashF> = fun (_Pc0) -> apply 'insertToken'/2(Src, _Pc0) in apply _HashF(call 'Data.Tuple':'Tuple'(Stk_, Acc_))
      <_W0> when 'true' ->
        case let <_HashF> = apply 'collapse'/1(fun (_Mf0, _Mf1) -> apply 'offsideP'/2(_Mf0, _Mf1)) in apply _HashF(State) of
      <State_ = {'Tuple', Stk_, _W0}> when 'true' ->
        case apply 'isTopDecl'/2(TokPos, Stk_) of
          <'true'> when 'true' -> let <_HashF> = fun (_Pc0) -> apply 'insertToken'/2(Src, _Pc0) in apply _HashF(State_)
          <_> when 'true' -> let <_HashF> = fun (_Pc0) -> apply 'popStack'/2(fun (X) -> call 'erlang':'=:='(X, apply 'LytProperty'/0()), _Pc0) in apply _HashF(let <_HashF> = fun (_Pc0) -> apply 'insertToken'/2(Src, _Pc0) in apply _HashF(let <_HashF> = fun (_Mf0) -> apply 'insertSep'/1(_Mf0) in apply _HashF(State_)))
        end
      <State_> when 'true' ->
        let <_HashF> = fun (_Pc0) -> apply 'popStack'/2(fun (X) -> call 'erlang':'=:='(X, apply 'LytProperty'/0()), _Pc0) in apply _HashF(let <_HashF> = fun (_Pc0) -> apply 'insertToken'/2(Src, _Pc0) in apply _HashF(let <_HashF> = fun (_Mf0) -> apply 'insertSep'/1(_Mf0) in apply _HashF(State_)))
    end
    end
      <'TokForall'> when 'true' ->
        let <_HashF> = fun (_Pc0) -> apply 'insertKwProperty'/2(fun (_Pc0) -> apply 'pushStack'/3(TokPos, apply 'LytForall'/0(), _Pc0), _Pc0) in apply _HashF(State)
      <'TokBackslash'> when 'true' ->
        let <_HashF> = fun (_Pc0) -> apply 'pushStack'/3(TokPos, apply 'LytLambdaBinders'/0(), _Pc0) in apply _HashF(let <_HashF> = fun (_Mf0) -> apply 'insertDefault'/1(_Mf0) in apply _HashF(State))
      <'TokRightArrow'> when 'true' ->
        let <_HashF> = fun (_Pc0) -> apply 'insertToken'/2(Src, _Pc0) in apply _HashF(let <_HashF> = fun (_Pc0) -> apply 'popStack'/2(fun (_Mf0) -> apply 'guardP'/1(_Mf0), _Pc0) in apply _HashF(let <_HashF> = apply 'collapse'/1(fun (_Mf0, _Mf1) -> apply 'arrowP'/2(_Mf0, _Mf1)) in apply _HashF(State)))
      <'TokEquals'> when 'true' ->
        case let <_HashF> = apply 'collapse'/1(fun (_Mf0, _Mf1) -> apply 'equalsP'/2(_Mf0, _Mf1)) in apply _HashF(State) of
      <{'Tuple', [{'Tuple', _W0, 'LytDeclGuard'} | Stk_], Acc_}> when 'true' ->
        let <_HashF> = fun (_Pc0) -> apply 'insertToken'/2(Src, _Pc0) in apply _HashF(call 'Data.Tuple':'Tuple'(Stk_, Acc_))
      <_W0> when 'true' ->
        let <_HashF> = fun (_Mf0) -> apply 'insertDefault'/1(_Mf0) in apply _HashF(State)
    end
      <'TokPipe'> when 'true' ->
        case let <_Oa0> = apply 'collapse'/1(fun (_Mf0, _Mf1) -> apply 'offsideEndP'/2(_Mf0, _Mf1))
      in apply _Oa0(State) of
      <State_ = {'Tuple', [{'Tuple', _W0, 'LytOf'} | _W1], _W2}> when 'true' ->
        let <_HashF> = fun (_Pc0) -> apply 'insertToken'/2(Src, _Pc0) in apply _HashF(let <_HashF> = fun (_Pc0) -> apply 'pushStack'/3(TokPos, apply 'LytCaseGuard'/0(), _Pc0) in apply _HashF(State_))
      <State_ = {'Tuple', [{'Tuple', _W0, 'LytLet'} | _W1], _W2}> when 'true' ->
        let <_HashF> = fun (_Pc0) -> apply 'insertToken'/2(Src, _Pc0) in apply _HashF(let <_HashF> = fun (_Pc0) -> apply 'pushStack'/3(TokPos, apply 'LytDeclGuard'/0(), _Pc0) in apply _HashF(State_))
      <State_ = {'Tuple', [{'Tuple', _W0, 'LytLetStmt'} | _W1], _W2}> when 'true' ->
        let <_HashF> = fun (_Pc0) -> apply 'insertToken'/2(Src, _Pc0) in apply _HashF(let <_HashF> = fun (_Pc0) -> apply 'pushStack'/3(TokPos, apply 'LytDeclGuard'/0(), _Pc0) in apply _HashF(State_))
      <State_ = {'Tuple', [{'Tuple', _W0, 'LytWhere'} | _W1], _W2}> when 'true' ->
        let <_HashF> = fun (_Pc0) -> apply 'insertToken'/2(Src, _Pc0) in apply _HashF(let <_HashF> = fun (_Pc0) -> apply 'pushStack'/3(TokPos, apply 'LytDeclGuard'/0(), _Pc0) in apply _HashF(State_))
      <_W0> when 'true' ->
        let <_HashF> = fun (_Mf0) -> apply 'insertDefault'/1(_Mf0) in apply _HashF(State)
    end
      <'TokTick'> when 'true' ->
        case let <_HashF> = apply 'collapse'/1(fun (_Mf0, _Mf1) -> apply 'indentedP'/2(_Mf0, _Mf1)) in apply _HashF(State) of
      <{'Tuple', [{'Tuple', _W0, 'LytTick'} | Stk_], Acc_}> when 'true' ->
        let <_HashF> = fun (_Pc0) -> apply 'insertToken'/2(Src, _Pc0) in apply _HashF(call 'Data.Tuple':'Tuple'(Stk_, Acc_))
      <_W0> when 'true' ->
        let <_HashF> = fun (_Pc0) -> apply 'pushStack'/3(TokPos, apply 'LytTick'/0(), _Pc0) in apply _HashF(let <_HashF> = fun (_Pc0) -> apply 'insertToken'/2(Src, _Pc0) in apply _HashF(let <_HashF> = fun (_Mf0) -> apply 'insertSep'/1(_Mf0) in apply _HashF(let <_HashF> = apply 'collapse'/1(fun (_Mf0, _Mf1) -> apply 'offsideEndP'/2(_Mf0, _Mf1)) in apply _HashF(State))))
    end
      <'TokComma'> when 'true' ->
        case let <_HashF> = apply 'collapse'/1(fun (_Mf0, _Mf1) -> apply 'indentedP'/2(_Mf0, _Mf1)) in apply _HashF(State) of
      <State_ = {'Tuple', [{'Tuple', _W0, 'LytBrace'} | _W1], _W2}> when 'true' ->
        let <_HashF> = fun (_Pc0) -> apply 'pushStack'/3(TokPos, apply 'LytProperty'/0(), _Pc0) in apply _HashF(let <_HashF> = fun (_Pc0) -> apply 'insertToken'/2(Src, _Pc0) in apply _HashF(State_))
      <State_> when 'true' ->
        let <_HashF> = fun (_Pc0) -> apply 'insertToken'/2(Src, _Pc0) in apply _HashF(State_)
    end
      <'TokDot'> when 'true' ->
        case let <_HashF> = fun (_Mf0) -> apply 'insertDefault'/1(_Mf0) in apply _HashF(State) of
      <{'Tuple', [{'Tuple', _W0, 'LytForall'} | Stk_], Acc_}> when 'true' ->
        call 'Data.Tuple':'Tuple'(Stk_, Acc_)
      <State_> when 'true' ->
        let <_HashF> = fun (_Pc0) -> apply 'pushStack'/3(TokPos, apply 'LytProperty'/0(), _Pc0) in apply _HashF(State_)
    end
      <'TokLeftParen'> when 'true' ->
        let <_HashF> = fun (_Pc0) -> apply 'pushStack'/3(TokPos, apply 'LytParen'/0(), _Pc0) in apply _HashF(let <_HashF> = fun (_Mf0) -> apply 'insertDefault'/1(_Mf0) in apply _HashF(State))
      <'TokLeftBrace'> when 'true' ->
        let <_HashF> = fun (_Pc0) -> apply 'pushStack'/3(TokPos, apply 'LytProperty'/0(), _Pc0) in apply _HashF(let <_HashF> = fun (_Pc0) -> apply 'pushStack'/3(TokPos, apply 'LytBrace'/0(), _Pc0) in apply _HashF(let <_HashF> = fun (_Mf0) -> apply 'insertDefault'/1(_Mf0) in apply _HashF(State)))
      <'TokLeftSquare'> when 'true' ->
        let <_HashF> = fun (_Pc0) -> apply 'pushStack'/3(TokPos, apply 'LytSquare'/0(), _Pc0) in apply _HashF(let <_HashF> = fun (_Mf0) -> apply 'insertDefault'/1(_Mf0) in apply _HashF(State))
      <'TokRightParen'> when 'true' ->
        let <_HashF> = fun (_Pc0) -> apply 'insertToken'/2(Src, _Pc0) in apply _HashF(let <_HashF> = fun (_Pc0) -> apply 'popStack'/2(fun (X) -> call 'erlang':'=:='(X, apply 'LytParen'/0()), _Pc0) in apply _HashF(let <_HashF> = apply 'collapse'/1(fun (_Mf0, _Mf1) -> apply 'indentedP'/2(_Mf0, _Mf1)) in apply _HashF(State)))
      <'TokRightBrace'> when 'true' ->
        let <_HashF> = fun (_Pc0) -> apply 'insertToken'/2(Src, _Pc0) in apply _HashF(let <_HashF> = fun (_Pc0) -> apply 'popStack'/2(fun (X) -> call 'erlang':'=:='(X, apply 'LytBrace'/0()), _Pc0) in apply _HashF(let <_HashF> = fun (_Pc0) -> apply 'popStack'/2(fun (X) -> call 'erlang':'=:='(X, apply 'LytProperty'/0()), _Pc0) in apply _HashF(let <_HashF> = apply 'collapse'/1(fun (_Mf0, _Mf1) -> apply 'indentedP'/2(_Mf0, _Mf1)) in apply _HashF(State))))
      <'TokRightSquare'> when 'true' ->
        let <_HashF> = fun (_Pc0) -> apply 'insertToken'/2(Src, _Pc0) in apply _HashF(let <_HashF> = fun (_Pc0) -> apply 'popStack'/2(fun (X) -> call 'erlang':'=:='(X, apply 'LytSquare'/0()), _Pc0) in apply _HashF(let <_HashF> = apply 'collapse'/1(fun (_Mf0, _Mf1) -> apply 'indentedP'/2(_Mf0, _Mf1)) in apply _HashF(State)))
      <{'TokString', _W0, _W1}> when 'true' ->
        let <_HashF> = fun (_Pc0) -> apply 'popStack'/2(fun (X) -> call 'erlang':'=:='(X, apply 'LytProperty'/0()), _Pc0) in apply _HashF(let <_HashF> = fun (_Mf0) -> apply 'insertDefault'/1(_Mf0) in apply _HashF(State))
      <{'TokLowerName', 'Nothing', _W0}> when 'true' ->
        let <_HashF> = fun (_Pc0) -> apply 'popStack'/2(fun (X) -> call 'erlang':'=:='(X, apply 'LytProperty'/0()), _Pc0) in apply _HashF(let <_HashF> = fun (_Mf0) -> apply 'insertDefault'/1(_Mf0) in apply _HashF(State))
      <{'TokOperator', _W0, _W1}> when 'true' ->
        let <_HashF> = fun (_Pc0) -> apply 'insertToken'/2(Src, _Pc0) in apply _HashF(let <_HashF> = fun (_Mf0) -> apply 'insertSep'/1(_Mf0) in apply _HashF(let <_HashF> = apply 'collapse'/1(fun (_Mf0, _Mf1) -> apply 'offsideEndP'/2(_Mf0, _Mf1)) in apply _HashF(State)))
      <_W0> when 'true' ->
        let <_HashF> = fun (_Mf0) -> apply 'insertDefault'/1(_Mf0) in apply _HashF(State)
    end
       'insertDefault'/1 = fun (State) ->
      let <_HashF> = fun (_Pc0) -> apply 'insertToken'/2(Src, _Pc0) in apply _HashF(let <_HashF> = fun (_Mf0) -> apply 'insertSep'/1(_Mf0) in apply _HashF(let <_HashF> = apply 'collapse'/1(fun (_Mf0, _Mf1) -> apply 'offsideP'/2(_Mf0, _Mf1)) in apply _HashF(State)))
       'insertStart'/2 = fun (_L0, _L1) ->
      case {_L0, _L1} of
        <{Lyt, State = {'Tuple', Stk, _W0}}> when 'true' -> case apply 'findIndented'/1(Stk) of
      <{'Just', {'Tuple', Pos, _W0}}> when 'true' ->
        case call 'erlang':'=<'(call 'maps':'get'('column', NextPos), call 'maps':'get'('column', Pos)) of
      <'true'> when 'true' -> State
      <'false'> when 'true' -> let <_HashF> = fun (_Pc0) -> apply 'insertToken'/2(apply 'lytToken'/2(NextPos, call 'Nova.Compiler.Cst':'TokLayoutStart'(call 'maps':'get'('column', NextPos))), _Pc0) in apply _HashF(let <_HashF> = fun (_Pc0) -> apply 'pushStack'/3(NextPos, Lyt, _Pc0) in apply _HashF(State))
    end
      <_W0> when 'true' ->
        let <_HashF> = fun (_Pc0) -> apply 'insertToken'/2(apply 'lytToken'/2(NextPos, call 'Nova.Compiler.Cst':'TokLayoutStart'(call 'maps':'get'('column', NextPos))), _Pc0) in apply _HashF(let <_HashF> = fun (_Pc0) -> apply 'pushStack'/3(NextPos, Lyt, _Pc0) in apply _HashF(State))
    end
      end
       'findIndented'/1 = fun (_L0) ->
      case {_L0} of
        <{[]}> when 'true' -> 'Nothing'
        <{[Item = {'Tuple', _W0, Lyt} | Rest]}> when 'true' -> case apply 'isIndented'/1(Lyt) of
      <'true'> when 'true' -> {'Just', Item}
      <'false'> when 'true' -> apply 'findIndented'/1(Rest)
    end
      end
       'insertSep'/1 = fun (_L0) ->
      case {_L0} of
        <{State = {'Tuple', Stk, Acc}}> when 'true' -> let <SepTok> = apply 'lytToken'/2(TokPos, call 'Nova.Compiler.Cst':'TokLayoutSep'(call 'maps':'get'('column', TokPos)))
      in case Stk of
      <[{'Tuple', LytPos, 'LytTopDecl'} | Stk_]> when 'true' ->
        case apply 'sepP'/1(LytPos) of
      <'true'> when 'true' -> let <_HashF> = fun (_Pc0) -> apply 'insertToken'/2(SepTok, _Pc0) in apply _HashF(call 'Data.Tuple':'Tuple'(Stk_, Acc))
      <'false'> when 'true' -> State
    end
      <[{'Tuple', LytPos, 'LytTopDeclHead'} | Stk_]> when 'true' ->
        case apply 'sepP'/1(LytPos) of
      <'true'> when 'true' -> let <_HashF> = fun (_Pc0) -> apply 'insertToken'/2(SepTok, _Pc0) in apply _HashF(call 'Data.Tuple':'Tuple'(Stk_, Acc))
      <'false'> when 'true' -> State
    end
      <[{'Tuple', LytPos, Lyt} | _W0]> when 'true' ->
        case apply 'indentSepP'/2(LytPos, Lyt) of
      <'true'> when 'true' -> case Lyt of
      <'LytOf'> when 'true' ->
        let <_HashF> = fun (_Pc0) -> apply 'pushStack'/3(TokPos, apply 'LytCaseBinders'/0(), _Pc0) in apply _HashF(let <_HashF> = fun (_Pc0) -> apply 'insertToken'/2(SepTok, _Pc0) in apply _HashF(State))
      <_W0> when 'true' ->
        let <_HashF> = fun (_Pc0) -> apply 'insertToken'/2(SepTok, _Pc0) in apply _HashF(State)
    end
      <'false'> when 'true' -> State
    end
      <_W0> when 'true' ->
        State
    end
      end
       'insertKwProperty'/2 = fun (K, State) ->
      case let <_HashF> = fun (_Mf0) -> apply 'insertDefault'/1(_Mf0) in apply _HashF(State) of
      <{'Tuple', [{'Tuple', _W0, 'LytProperty'} | Stk_], Acc_}> when 'true' ->
        call 'Data.Tuple':'Tuple'(Stk_, Acc_)
      <State_> when 'true' ->
        apply K(State_)
    end
       'insertEnd'/1 = fun (Indent) ->
      fun (_Pc0) -> apply 'insertToken'/2(apply 'lytToken'/2(TokPos, call 'Nova.Compiler.Cst':'TokLayoutEnd'(Indent)), _Pc0)
       'insertToken'/2 = fun (_L0, _L1) ->
      case {_L0, _L1} of
        <{Token, {'Tuple', Stk, Acc}}> when 'true' -> call 'Data.Tuple':'Tuple'(Stk, call 'erlang':'++'(Acc, [call 'Data.Tuple':'Tuple'(Token, Stk) | []]))
      end
       'pushStack'/3 = fun (_L0, _L1, _L2) ->
      case {_L0, _L1, _L2} of
        <{LytPos, Lyt, {'Tuple', Stk, Acc}}> when 'true' -> call 'Data.Tuple':'Tuple'([call 'Data.Tuple':'Tuple'(LytPos, Lyt) | Stk], Acc)
      end
       'popStack'/2 = fun (P, State) ->
      case State of
      <{'Tuple', [{'Tuple', _W0, Lyt} | Stk_], Acc}> when 'true' ->
        case apply P(Lyt) of
      <'true'> when 'true' -> call 'Data.Tuple':'Tuple'(Stk_, Acc)
      <'false'> when 'true' -> State
    end
      <_W0> when 'true' ->
        State
    end
       'collapse'/1 = fun (P) ->
      letrec 'go'/1 = fun (State) ->
      case State of
      <{'Tuple', [{'Tuple', LytPos, Lyt} | Stk_], Acc}> when 'true' ->
        case apply P(LytPos, Lyt) of
      <'true'> when 'true' -> apply 'go'/1(let <_DollarF> = call 'Data.Tuple':'Tuple'(Stk_) in apply _DollarF(case apply 'isIndented'/1(Lyt) of
      <'true'> when 'true' -> call 'erlang':'++'(Acc, [call 'Data.Tuple':'Tuple'(apply 'lytToken'/2(TokPos, call 'Nova.Compiler.Cst':'TokLayoutEnd'(call 'maps':'get'('column', LytPos))), Stk_) | []])
      <'false'> when 'true' -> Acc
    end))
      <'false'> when 'true' -> State
    end
      <_W0> when 'true' ->
        State
    end
      in fun (_Mf0) -> apply 'go'/1(_Mf0)
       'indentedP'/2 = fun (_W0, Lyt) ->
      apply 'isIndented'/1(Lyt)
       'offsideP'/2 = fun (LytPos, Lyt) ->
      case apply 'isIndented'/1(Lyt) of <'true'> when 'true' -> call 'erlang':'<'(call 'maps':'get'('column', TokPos), call 'maps':'get'('column', LytPos)) <_> when 'true' -> 'false' end
       'offsideEndP'/2 = fun (LytPos, Lyt) ->
      case apply 'isIndented'/1(Lyt) of <'true'> when 'true' -> call 'erlang':'=<'(call 'maps':'get'('column', TokPos), call 'maps':'get'('column', LytPos)) <_> when 'true' -> 'false' end
       'indentSepP'/2 = fun (LytPos, Lyt) ->
      case apply 'isIndented'/1(Lyt) of <'true'> when 'true' -> apply 'sepP'/1(LytPos) <_> when 'true' -> 'false' end
       'sepP'/1 = fun (LytPos) ->
      case call 'erlang':'=:='(call 'maps':'get'('column', TokPos), call 'maps':'get'('column', LytPos)) of <'true'> when 'true' -> call 'erlang':'=/='(call 'maps':'get'('line', TokPos), call 'maps':'get'('line', LytPos)) <_> when 'true' -> 'false' end
       'whereP'/2 = fun (_L0, _L1) ->
      case {_L0, _L1} of
        <{_W0, 'LytDo'}> when 'true' -> 'true'
        <{LytPos, Lyt}> when 'true' -> apply 'offsideEndP'/2(LytPos, Lyt)
      end
       'inP'/2 = fun (_L0, _L1) ->
      case {_L0, _L1} of
        <{_W0, 'LytLet'}> when 'true' -> 'false'
        <{_W0, 'LytAdo'}> when 'true' -> 'false'
        <{_W0, Lyt}> when 'true' -> apply 'isIndented'/1(Lyt)
      end
       'letNext'/1 = fun (_L0) ->
      case {_L0} of
        <{State_ = {'Tuple', Stk_, _W0}}> when 'true' -> case Stk_ of
      <[{'Tuple', P, 'LytDo'} | _W0]> when 'true' ->
        case call 'erlang':'=:='(call 'maps':'get'('column', P), call 'maps':'get'('column', TokPos)) of
      <'true'> when 'true' -> let <_HashF> = fun (_Pc0) -> apply 'insertStart'/2(apply 'LytLetStmt'/0(), _Pc0) in apply _HashF(State_)
      <'false'> when 'true' -> let <_HashF> = fun (_Pc0) -> apply 'insertStart'/2(apply 'LytLet'/0(), _Pc0) in apply _HashF(State_)
    end
      <[{'Tuple', P, 'LytAdo'} | _W0]> when 'true' ->
        case call 'erlang':'=:='(call 'maps':'get'('column', P), call 'maps':'get'('column', TokPos)) of
      <'true'> when 'true' -> let <_HashF> = fun (_Pc0) -> apply 'insertStart'/2(apply 'LytLetStmt'/0(), _Pc0) in apply _HashF(State_)
      <'false'> when 'true' -> let <_HashF> = fun (_Pc0) -> apply 'insertStart'/2(apply 'LytLet'/0(), _Pc0) in apply _HashF(State_)
    end
      <_W0> when 'true' ->
        let <_HashF> = fun (_Pc0) -> apply 'insertStart'/2(apply 'LytLet'/0(), _Pc0) in apply _HashF(State_)
    end
      end
       'arrowP'/2 = fun (_L0, _L1) ->
      case {_L0, _L1} of
        <{_W0, 'LytDo'}> when 'true' -> 'true'
        <{_W0, 'LytOf'}> when 'true' -> 'false'
        <{LytPos, Lyt}> when 'true' -> apply 'offsideEndP'/2(LytPos, Lyt)
      end
       'guardP'/1 = fun (_L0) ->
      case {_L0} of
        <{'LytCaseBinders'}> when 'true' -> 'true'
        <{'LytCaseGuard'}> when 'true' -> 'true'
        <{'LytLambdaBinders'}> when 'true' -> 'true'
        <{_W0}> when 'true' -> 'false'
      end
       'equalsP'/2 = fun (_L0, _L1) ->
      case {_L0, _L1} of
        <{_W0, 'LytWhere'}> when 'true' -> 'true'
        <{_W0, 'LytLet'}> when 'true' -> 'true'
        <{_W0, 'LytLetStmt'}> when 'true' -> 'true'
        <{_W0, _W1}> when 'true' -> 'false'
      end
      in apply 'insert'/1(call 'Data.Tuple':'Tuple'(Stack, []))

'isIndented'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'isIndented'/1(_A0)
      in _F0

'currentIndentGo'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'currentIndentGo'/1(_A0)
      in _F0

'isTopDecl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'isTopDecl'/2(_A0, _A1)
      in _F1
      in _F0

'isTopDecl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'isTopDecl'/2(_A0, _A1)
      in _F0

'lytToken'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'lytToken'/2(_A0, _A1)
      in _F1
      in _F0

'lytToken'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'lytToken'/2(_A0, _A1)
      in _F0

'insertLayout'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'insertLayout'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'insertLayout'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'insertLayout'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'insertLayout'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'insertLayout'/3(_A0, _A1, _A2)
      in _F0
end
