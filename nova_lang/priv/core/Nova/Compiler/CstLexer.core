module 'Nova.Compiler.CstLexer' ['initLexState'/1, 'keywords'/0, 'isIndented'/1, 'lytToken'/2, 'closeLayouts'/1, 'closeLayoutsGo'/2, 'callInsertLayout'/3, 'insertLayoutGo'/3, 'insertLayoutTokens'/1, 'lexModule'/1, 'lexTokens'/1, 'lexTokensGo'/2, 'lexToken'/1, 'isDigit'/1, 'isUpper'/1, 'isLower'/1, 'isAlpha'/1, 'isAlphaNum'/1, 'isIdentStart'/1, 'isIdentChar'/1, 'isOperatorChar'/1, 'peek'/1, 'peekAt'/2, 'advance'/2, 'advanceNewline'/1, 'advanceTab'/1, 'makeToken'/2, 'makeTokenRange'/3, 'lexIdentOrKeyword'/1, 'makeKeywordToken'/3, 'makeIdentToken'/3, 'lexUpperIdentifier'/1, 'checkQualifiedChain'/2, 'consumeIdent'/2, 'consumeUpperIdent'/2, 'lexOperator'/1, 'consumeOperator'/2, 'lexDelimiter'/1, 'lexUnderscore'/1, 'lexNumber'/1, 'consumeNumber'/2, 'lexString'/1, 'consumeString'/2, 'lexRawString'/1, 'consumeRawString'/2, 'lexChar'/1, 'skipLineComment'/1, 'skipBlockComment'/2, 'initLexState'/0, 'isIndented'/0, 'lytToken'/0, 'lytToken'/1, 'closeLayouts'/0, 'closeLayoutsGo'/0, 'closeLayoutsGo'/1, 'callInsertLayout'/0, 'callInsertLayout'/1, 'callInsertLayout'/2, 'insertLayoutGo'/0, 'insertLayoutGo'/1, 'insertLayoutGo'/2, 'insertLayoutTokens'/0, 'lexModule'/0, 'lexTokens'/0, 'lexTokensGo'/0, 'lexTokensGo'/1, 'lexToken'/0, 'isDigit'/0, 'isUpper'/0, 'isLower'/0, 'isAlpha'/0, 'isAlphaNum'/0, 'isIdentStart'/0, 'isIdentChar'/0, 'isOperatorChar'/0, 'peek'/0, 'peekAt'/0, 'peekAt'/1, 'advance'/0, 'advance'/1, 'advanceNewline'/0, 'advanceTab'/0, 'makeToken'/0, 'makeToken'/1, 'makeTokenRange'/0, 'makeTokenRange'/1, 'makeTokenRange'/2, 'lexIdentOrKeyword'/0, 'makeKeywordToken'/0, 'makeKeywordToken'/1, 'makeKeywordToken'/2, 'makeIdentToken'/0, 'makeIdentToken'/1, 'makeIdentToken'/2, 'lexUpperIdentifier'/0, 'checkQualifiedChain'/0, 'checkQualifiedChain'/1, 'consumeIdent'/0, 'consumeIdent'/1, 'consumeUpperIdent'/0, 'consumeUpperIdent'/1, 'lexOperator'/0, 'consumeOperator'/0, 'consumeOperator'/1, 'lexDelimiter'/0, 'lexUnderscore'/0, 'lexNumber'/0, 'consumeNumber'/0, 'consumeNumber'/1, 'lexString'/0, 'consumeString'/0, 'consumeString'/1, 'lexRawString'/0, 'consumeRawString'/0, 'consumeRawString'/1, 'lexChar'/0, 'skipLineComment'/0, 'skipBlockComment'/0, 'skipBlockComment'/1]
  attributes []
'initLexState'/1 =
  fun (Input) ->
    ~{'input'=>Input,'chars'=>call 'Data.String.CodeUnits':'toCharArray'(Input),'pos'=>0,'line'=>1,'column'=>1}~

'keywords'/0 =
  fun () ->
    ["foreign", "module", "where", "import", "data", "type", "class", "instance", "let", "in", "if", "then", "else", "case", "of", "do", "ado", "derive", "newtype", "infixl", "infixr", "infix", "forall", "as", "hiding", "true", "false", "role", "nominal", "representational", "phantom"]

'isIndented'/1 =
  fun (Lyt) ->
    case Lyt of
      <'LytLet'> when 'true' ->
        'true'
      <'LytLetStmt'> when 'true' ->
        'true'
      <'LytWhere'> when 'true' ->
        'true'
      <'LytOf'> when 'true' ->
        'true'
      <'LytDo'> when 'true' ->
        'true'
      <'LytAdo'> when 'true' ->
        'true'
      <_W0> when 'true' ->
        'false'
    end

'lytToken'/2 =
  fun (Pos, Value) ->
    ~{'range'=>~{'start'=>Pos,'end'=>Pos}~,'leadingComments'=>[],'trailingComments'=>[],'value'=>Value}~

'closeLayouts'/1 =
  fun (Stack) ->
    apply 'closeLayoutsGo'/2([], Stack)

'closeLayoutsGo'/2 =
  fun (_P0, _P1) ->
    case {_P0, _P1} of
      <{Acc, []}> when 'true' ->
        Acc
      <{Acc, [{'Tuple', Pos, Lyt} | Rest]}> when 'true' ->
        case apply 'isIndented'/1(Lyt) of
      <'true'> when 'true' -> let <EndTok> = apply 'lytToken'/2(Pos, call 'Nova.Compiler.Cst':'TokLayoutEnd'(call 'maps':'get'('column', Pos)))
      in apply 'closeLayoutsGo'/2(call 'erlang':'++'(Acc, [EndTok | []]), Rest)
      <'false'> when 'true' -> apply 'closeLayoutsGo'/2(Acc, Rest)
    end
    end

'callInsertLayout'/3 =
  fun (Tok, Pos, Stk) ->
    call 'Nova.Compiler.CstLayout':'insertLayout'(Tok, Pos, Stk)

'insertLayoutGo'/3 =
  fun (Stack, Toks, Acc) ->
    case Toks of
      <[]> when 'true' ->
        call 'erlang':'++'(Acc, apply 'closeLayouts'/1(Stack))
      <[Tok | Rest]> when 'true' ->
        let <NextPos> = case Rest of
      <[Next | _W0]> when 'true' ->
        call 'maps':'get'('start', call 'maps':'get'('range', Next))
      <[]> when 'true' ->
        ~{'line'=>call 'erlang':'+'(call 'maps':'get'('line', call 'maps':'get'('end', call 'maps':'get'('range', Tok))), 1),'column'=>1}~
    end
      in case apply 'callInsertLayout'/3(Tok, NextPos, Stack) of
      <{'Tuple', NewStack, OutputTokens}> when 'true' ->
        let <NewToks> = call 'lists':'map'(call 'Data.Tuple':'fst'(), OutputTokens)
      in apply 'insertLayoutGo'/3(NewStack, Rest, call 'erlang':'++'(Acc, NewToks))
    end
    end

'insertLayoutTokens'/1 =
  fun (Tokens) ->
    letrec 'getRootLayout'/1 = fun (_W0) ->
      call 'Nova.Compiler.CstLayout':'rootLayoutDelim'()
      in let <InitPos> = ~{'line'=>1,'column'=>1}~
      in let <InitStack> = [call 'Data.Tuple':'Tuple'(InitPos, apply 'getRootLayout'/1(~{}~)) | []]
      in apply 'insertLayoutGo'/3(InitStack, Tokens, [])

'lexModule'/1 =
  fun (Source) ->
    let <RawTokens> = apply 'lexTokens'/1(Source)
      in apply 'insertLayoutTokens'/1(RawTokens)

'lexTokens'/1 =
  fun (Source) ->
    apply 'lexTokensGo'/2(apply 'initLexState'/1(Source), [])

'lexTokensGo'/2 =
  fun (State, Acc) ->
    case apply 'lexToken'/1(State) of
      <'Nothing'> when 'true' ->
        Acc
      <{'Just', {'Tuple', Tok, State_}}> when 'true' ->
        apply 'lexTokensGo'/2(State_, call 'erlang':'++'(Acc, [Tok | []]))
    end

'lexToken'/1 =
  fun (State) ->
    case apply 'peek'/1(State) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', C}> when 'true' ->
        case C of
      <$ > when 'true' ->
        apply 'lexToken'/1(apply 'advance'/2(State, 1))
      <$\t> when 'true' ->
        apply 'lexToken'/1(apply 'advanceTab'/1(State))
      <$\n> when 'true' ->
        apply 'lexToken'/1(apply 'advanceNewline'/1(apply 'advance'/2(State, 1)))
      <$\r> when 'true' ->
        case apply 'peekAt'/2(State, 1) of
      <{'Just', $\n}> when 'true' ->
        apply 'lexToken'/1(apply 'advanceNewline'/1(apply 'advance'/2(State, 2)))
      <_W0> when 'true' ->
        apply 'lexToken'/1(apply 'advanceNewline'/1(apply 'advance'/2(State, 1)))
    end
      <$-> when 'true' ->
        case apply 'peekAt'/2(State, 1) of
      <{'Just', $-}> when 'true' ->
        let <State_> = apply 'skipLineComment'/1(apply 'advance'/2(State, 2))
      in apply 'lexToken'/1(State_)
      <_W0> when 'true' ->
        apply 'lexOperator'/1(State)
    end
      <${> when 'true' ->
        case apply 'peekAt'/2(State, 1) of
      <{'Just', $-}> when 'true' ->
        let <State_> = apply 'skipBlockComment'/2(apply 'advance'/2(State, 2), 1)
      in apply 'lexToken'/1(State_)
      <_W0> when 'true' ->
        apply 'lexDelimiter'/1(State)
    end
      <$"> when 'true' ->
        case apply 'peekAt'/2(State, 1) of
      <{'Just', $"}> when 'true' ->
        case apply 'peekAt'/2(State, 2) of
      <{'Just', $"}> when 'true' ->
        apply 'lexRawString'/1(State)
      <_W0> when 'true' ->
        apply 'lexString'/1(State)
    end
      <_W0> when 'true' ->
        apply 'lexString'/1(State)
    end
      <$'> when 'true' ->
        apply 'lexChar'/1(State)
      <$(> when 'true' ->
        apply 'lexDelimiter'/1(State)
      <$)> when 'true' ->
        apply 'lexDelimiter'/1(State)
      <$[> when 'true' ->
        apply 'lexDelimiter'/1(State)
      <$]> when 'true' ->
        apply 'lexDelimiter'/1(State)
      <$}> when 'true' ->
        apply 'lexDelimiter'/1(State)
      <$,> when 'true' ->
        apply 'lexDelimiter'/1(State)
      <$`> when 'true' ->
        apply 'lexDelimiter'/1(State)
      <$;> when 'true' ->
        apply 'lexDelimiter'/1(State)
      <$_> when 'true' ->
        apply 'lexUnderscore'/1(State)
      <$@> when 'true' ->
        {'Just', call 'Data.Tuple':'Tuple'(apply 'makeToken'/2(call 'Nova.Compiler.Cst':'TokAt'(), State), apply 'advance'/2(State, 1))}
      <_W0> when 'true' ->
        case apply 'isDigit'/1(C) of
      <'true'> when 'true' -> apply 'lexNumber'/1(State)
      <'false'> when 'true' -> case apply 'isIdentStart'/1(C) of
      <'true'> when 'true' -> apply 'lexIdentOrKeyword'/1(State)
      <'false'> when 'true' -> case apply 'isUpper'/1(C) of
      <'true'> when 'true' -> apply 'lexUpperIdentifier'/1(State)
      <'false'> when 'true' -> case apply 'isOperatorChar'/1(C) of
      <'true'> when 'true' -> apply 'lexOperator'/1(State)
      <'false'> when 'true' -> apply 'lexToken'/1(apply 'advance'/2(State, 1))
    end
    end
    end
    end
    end
      <{'Right', C}> when 'true' ->
        case C of
      <$ > when 'true' ->
        apply 'lexToken'/1(apply 'advance'/2(State, 1))
      <$\t> when 'true' ->
        apply 'lexToken'/1(apply 'advanceTab'/1(State))
      <$\n> when 'true' ->
        apply 'lexToken'/1(apply 'advanceNewline'/1(apply 'advance'/2(State, 1)))
      <$\r> when 'true' ->
        case apply 'peekAt'/2(State, 1) of
      <{'Just', $\n}> when 'true' ->
        apply 'lexToken'/1(apply 'advanceNewline'/1(apply 'advance'/2(State, 2)))
      <_W0> when 'true' ->
        apply 'lexToken'/1(apply 'advanceNewline'/1(apply 'advance'/2(State, 1)))
    end
      <$-> when 'true' ->
        case apply 'peekAt'/2(State, 1) of
      <{'Just', $-}> when 'true' ->
        let <State_> = apply 'skipLineComment'/1(apply 'advance'/2(State, 2))
      in apply 'lexToken'/1(State_)
      <_W0> when 'true' ->
        apply 'lexOperator'/1(State)
    end
      <${> when 'true' ->
        case apply 'peekAt'/2(State, 1) of
      <{'Just', $-}> when 'true' ->
        let <State_> = apply 'skipBlockComment'/2(apply 'advance'/2(State, 2), 1)
      in apply 'lexToken'/1(State_)
      <_W0> when 'true' ->
        apply 'lexDelimiter'/1(State)
    end
      <$"> when 'true' ->
        case apply 'peekAt'/2(State, 1) of
      <{'Just', $"}> when 'true' ->
        case apply 'peekAt'/2(State, 2) of
      <{'Just', $"}> when 'true' ->
        apply 'lexRawString'/1(State)
      <_W0> when 'true' ->
        apply 'lexString'/1(State)
    end
      <_W0> when 'true' ->
        apply 'lexString'/1(State)
    end
      <$'> when 'true' ->
        apply 'lexChar'/1(State)
      <$(> when 'true' ->
        apply 'lexDelimiter'/1(State)
      <$)> when 'true' ->
        apply 'lexDelimiter'/1(State)
      <$[> when 'true' ->
        apply 'lexDelimiter'/1(State)
      <$]> when 'true' ->
        apply 'lexDelimiter'/1(State)
      <$}> when 'true' ->
        apply 'lexDelimiter'/1(State)
      <$,> when 'true' ->
        apply 'lexDelimiter'/1(State)
      <$`> when 'true' ->
        apply 'lexDelimiter'/1(State)
      <$;> when 'true' ->
        apply 'lexDelimiter'/1(State)
      <$_> when 'true' ->
        apply 'lexUnderscore'/1(State)
      <$@> when 'true' ->
        {'Just', call 'Data.Tuple':'Tuple'(apply 'makeToken'/2(call 'Nova.Compiler.Cst':'TokAt'(), State), apply 'advance'/2(State, 1))}
      <_W0> when 'true' ->
        case apply 'isDigit'/1(C) of
      <'true'> when 'true' -> apply 'lexNumber'/1(State)
      <'false'> when 'true' -> case apply 'isIdentStart'/1(C) of
      <'true'> when 'true' -> apply 'lexIdentOrKeyword'/1(State)
      <'false'> when 'true' -> case apply 'isUpper'/1(C) of
      <'true'> when 'true' -> apply 'lexUpperIdentifier'/1(State)
      <'false'> when 'true' -> case apply 'isOperatorChar'/1(C) of
      <'true'> when 'true' -> apply 'lexOperator'/1(State)
      <'false'> when 'true' -> apply 'lexToken'/1(apply 'advance'/2(State, 1))
    end
    end
    end
    end
    end
      end

'isDigit'/1 =
  fun (C) ->
    case call 'erlang':'>='(C, $0) of <'true'> when 'true' -> call 'erlang':'=<'(C, $9) <_> when 'true' -> 'false' end

'isUpper'/1 =
  fun (C) ->
    case call 'erlang':'>='(C, $A) of <'true'> when 'true' -> call 'erlang':'=<'(C, $Z) <_> when 'true' -> 'false' end

'isLower'/1 =
  fun (C) ->
    case call 'erlang':'>='(C, $a) of <'true'> when 'true' -> call 'erlang':'=<'(C, $z) <_> when 'true' -> 'false' end

'isAlpha'/1 =
  fun (C) ->
    case apply 'isUpper'/1(C) of <'true'> when 'true' -> 'true' <_> when 'true' -> apply 'isLower'/1(C) end

'isAlphaNum'/1 =
  fun (C) ->
    case apply 'isAlpha'/1(C) of <'true'> when 'true' -> 'true' <_> when 'true' -> apply 'isDigit'/1(C) end

'isIdentStart'/1 =
  fun (C) ->
    case apply 'isLower'/1(C) of <'true'> when 'true' -> 'true' <_> when 'true' -> call 'erlang':'=:='(C, $_) end

'isIdentChar'/1 =
  fun (C) ->
    case case apply 'isAlphaNum'/1(C) of <'true'> when 'true' -> 'true' <_> when 'true' -> call 'erlang':'=:='(C, $_) end of <'true'> when 'true' -> 'true' <_> when 'true' -> call 'erlang':'=:='(C, $') end

'isOperatorChar'/1 =
  fun (C) ->
    case case case case case case case case case case case case case case case case case case call 'erlang':'=:='(C, $:) of <'true'> when 'true' -> 'true' <_> when 'true' -> call 'erlang':'=:='(C, $!) end of <'true'> when 'true' -> 'true' <_> when 'true' -> call 'erlang':'=:='(C, $#) end of <'true'> when 'true' -> 'true' <_> when 'true' -> call 'erlang':'=:='(C, $$) end of <'true'> when 'true' -> 'true' <_> when 'true' -> call 'erlang':'=:='(C, $%) end of <'true'> when 'true' -> 'true' <_> when 'true' -> call 'erlang':'=:='(C, $&) end of <'true'> when 'true' -> 'true' <_> when 'true' -> call 'erlang':'=:='(C, $*) end of <'true'> when 'true' -> 'true' <_> when 'true' -> call 'erlang':'=:='(C, $+) end of <'true'> when 'true' -> 'true' <_> when 'true' -> call 'erlang':'=:='(C, $.) end of <'true'> when 'true' -> 'true' <_> when 'true' -> call 'erlang':'=:='(C, $/) end of <'true'> when 'true' -> 'true' <_> when 'true' -> call 'erlang':'=:='(C, $<) end of <'true'> when 'true' -> 'true' <_> when 'true' -> call 'erlang':'=:='(C, $=) end of <'true'> when 'true' -> 'true' <_> when 'true' -> call 'erlang':'=:='(C, $>) end of <'true'> when 'true' -> 'true' <_> when 'true' -> call 'erlang':'=:='(C, $?) end of <'true'> when 'true' -> 'true' <_> when 'true' -> call 'erlang':'=:='(C, $\\) end of <'true'> when 'true' -> 'true' <_> when 'true' -> call 'erlang':'=:='(C, $^) end of <'true'> when 'true' -> 'true' <_> when 'true' -> call 'erlang':'=:='(C, $|) end of <'true'> when 'true' -> 'true' <_> when 'true' -> call 'erlang':'=:='(C, $-) end of <'true'> when 'true' -> 'true' <_> when 'true' -> call 'erlang':'=:='(C, $~) end

'peek'/1 =
  fun (State) ->
    call 'Data.Array':'index'(call 'maps':'get'('chars', State), call 'maps':'get'('pos', State))

'peekAt'/2 =
  fun (State, Offset) ->
    call 'Data.Array':'index'(call 'maps':'get'('chars', State), call 'erlang':'+'(call 'maps':'get'('pos', State), Offset))

'advance'/2 =
  fun (State, N) ->
    call 'maps':'merge'(State, ~{'pos'=>call 'erlang':'+'(call 'maps':'get'('pos', State), N),'column'=>call 'erlang':'+'(call 'maps':'get'('column', State), N)}~)

'advanceNewline'/1 =
  fun (State) ->
    call 'maps':'merge'(State, ~{'line'=>call 'erlang':'+'(call 'maps':'get'('line', State), 1),'column'=>1}~)

'advanceTab'/1 =
  fun (State) ->
    let <Col> = call 'maps':'get'('column', State)
      in let <NextTab> = call 'erlang':'+'(call 'erlang':'*'(call 'erlang':'+'(call 'erlang':'div'(call 'erlang':'-'(Col, 1), 8), 1), 8), 1)
      in call 'maps':'merge'(State, ~{'pos'=>call 'erlang':'+'(call 'maps':'get'('pos', State), 1),'column'=>NextTab}~)

'makeToken'/2 =
  fun (Tok, State) ->
    ~{'range'=>~{'start'=>~{'line'=>call 'maps':'get'('line', State),'column'=>call 'maps':'get'('column', State)}~,'end'=>~{'line'=>call 'maps':'get'('line', State),'column'=>call 'maps':'get'('column', State)}~}~,'leadingComments'=>[],'trailingComments'=>[],'value'=>Tok}~

'makeTokenRange'/3 =
  fun (Tok, StartState, EndState) ->
    ~{'range'=>~{'start'=>~{'line'=>call 'maps':'get'('line', StartState),'column'=>call 'maps':'get'('column', StartState)}~,'end'=>~{'line'=>call 'maps':'get'('line', EndState),'column'=>call 'maps':'get'('column', EndState)}~}~,'leadingComments'=>[],'trailingComments'=>[],'value'=>Tok}~

'lexIdentOrKeyword'/1 =
  fun (State) ->
    let <StartState> = State
      in let <_Let0> = apply 'consumeIdent'/2(State, "")
      in case _Let0 of
        <{'Tuple', Name, State_}> when 'true' -> let <Tok> = case call 'Data.Array':'elem'(Name, apply 'keywords'/0()) of
      <'true'> when 'true' -> apply 'makeKeywordToken'/3(Name, StartState, State_)
      <'false'> when 'true' -> apply 'makeIdentToken'/3(Name, StartState, State_)
    end
      in {'Just', call 'Data.Tuple':'Tuple'(Tok, State_)}
      end

'makeKeywordToken'/3 =
  fun (Name, StartState, EndState) ->
    let <Token> = case Name of
      <"forall"> when 'true' ->
        call 'Nova.Compiler.Cst':'TokForall'()
      <_W0> when 'true' ->
        call 'Nova.Compiler.Cst':'TokLowerName'('Nothing', Name)
    end
      in apply 'makeTokenRange'/3(Token, StartState, EndState)

'makeIdentToken'/3 =
  fun (Name, StartState, EndState) ->
    apply 'makeTokenRange'/3(call 'Nova.Compiler.Cst':'TokLowerName'('Nothing', Name), StartState, EndState)

'lexUpperIdentifier'/1 =
  fun (State) ->
    let <StartState> = State
      in let <_Let0> = apply 'consumeUpperIdent'/2(State, "")
      in case _Let0 of
        <{'Tuple', Name, State_}> when 'true' -> let <Result> = case apply 'peek'/1(State_) of
      <{'Just', $.}> when 'true' ->
        let <State__> = apply 'advance'/2(State_, 1)
      in apply 'checkQualifiedChain'/2(Name, State__)
      <_W0> when 'true' ->
        call 'Data.Tuple':'Tuple'(call 'Nova.Compiler.Cst':'TokUpperName'('Nothing', Name), State_)
    end
      in let <_Let1> = Result
      in case _Let1 of
        <{'Tuple', Tok, FinalState}> when 'true' -> {'Just', call 'Data.Tuple':'Tuple'(apply 'makeTokenRange'/3(Tok, StartState, FinalState), FinalState)}
      end
      end

'checkQualifiedChain'/2 =
  fun (Prefix, State) ->
    case apply 'peek'/1(State) of
      <{'Just', C}> when 'true' ->
        case apply 'isUpper'/1(C) of
      <'true'> when 'true' -> let <_Let0> = apply 'consumeUpperIdent'/2(State, "")
      in case _Let0 of
        <{'Tuple', Name, State_}> when 'true' -> let <FullPrefix> = call 'erlang':'++'(call 'erlang':'++'(Prefix, "."), Name)
      in case apply 'peek'/1(State_) of
      <{'Just', $.}> when 'true' ->
        apply 'checkQualifiedChain'/2(FullPrefix, apply 'advance'/2(State_, 1))
      <_W0> when 'true' ->
        call 'Data.Tuple':'Tuple'(call 'Nova.Compiler.Cst':'TokUpperName'({'Just', Prefix}, Name), State_)
    end
      end
      <'false'> when 'true' -> case apply 'isLower'/1(C) of
      <'true'> when 'true' -> let <_Let0> = apply 'consumeIdent'/2(State, "")
      in case _Let0 of
        <{'Tuple', Name, State_}> when 'true' -> call 'Data.Tuple':'Tuple'(call 'Nova.Compiler.Cst':'TokLowerName'({'Just', Prefix}, Name), State_)
      end
      <'false'> when 'true' -> case apply 'isOperatorChar'/1(C) of
      <'true'> when 'true' -> let <_Let0> = apply 'consumeOperator'/2(State, "")
      in case _Let0 of
        <{'Tuple', Op, State_}> when 'true' -> call 'Data.Tuple':'Tuple'(call 'Nova.Compiler.Cst':'TokOperator'({'Just', Prefix}, Op), State_)
      end
      <'false'> when 'true' -> call 'Data.Tuple':'Tuple'(call 'Nova.Compiler.Cst':'TokUpperName'('Nothing', Prefix), State)
    end
    end
    end
      <_W0> when 'true' ->
        call 'Data.Tuple':'Tuple'(call 'Nova.Compiler.Cst':'TokUpperName'('Nothing', Prefix), State)
    end

'consumeIdent'/2 =
  fun (State, Acc) ->
    case apply 'peek'/1(State) of
      <{'Just', C}> when 'true' ->
        case apply 'isIdentChar'/1(C) of
      <'true'> when 'true' -> apply 'consumeIdent'/2(apply 'advance'/2(State, 1), call 'erlang':'++'(Acc, call 'Data.String.CodeUnits':'singleton'(C)))
      <'false'> when 'true' -> call 'Data.Tuple':'Tuple'(Acc, State)
    end
      <_W0> when 'true' ->
        call 'Data.Tuple':'Tuple'(Acc, State)
    end

'consumeUpperIdent'/2 =
  fun (State, Acc) ->
    case apply 'peek'/1(State) of
      <{'Just', C}> when 'true' ->
        case case apply 'isAlphaNum'/1(C) of <'true'> when 'true' -> 'true' <_> when 'true' -> call 'erlang':'=:='(C, $_) end of
      <'true'> when 'true' -> apply 'consumeUpperIdent'/2(apply 'advance'/2(State, 1), call 'erlang':'++'(Acc, call 'Data.String.CodeUnits':'singleton'(C)))
      <'false'> when 'true' -> call 'Data.Tuple':'Tuple'(Acc, State)
    end
      <_W0> when 'true' ->
        call 'Data.Tuple':'Tuple'(Acc, State)
    end

'lexOperator'/1 =
  fun (State) ->
    let <StartState> = State
      in let <_Let0> = apply 'consumeOperator'/2(State, "")
      in case _Let0 of
        <{'Tuple', Op, State_}> when 'true' -> let <Tok> = case Op of
      <"::"> when 'true' ->
        call 'Nova.Compiler.Cst':'TokDoubleColon'()
      <"="> when 'true' ->
        call 'Nova.Compiler.Cst':'TokEquals'()
      <"|"> when 'true' ->
        call 'Nova.Compiler.Cst':'TokPipe'()
      <"."> when 'true' ->
        call 'Nova.Compiler.Cst':'TokDot'()
      <"\\"> when 'true' ->
        call 'Nova.Compiler.Cst':'TokBackslash'()
      <"->"> when 'true' ->
        call 'Nova.Compiler.Cst':'TokRightArrow'()
      <"<-"> when 'true' ->
        call 'Nova.Compiler.Cst':'TokLeftArrow'()
      <"=>"> when 'true' ->
        call 'Nova.Compiler.Cst':'TokRightFatArrow'()
      <"@"> when 'true' ->
        call 'Nova.Compiler.Cst':'TokAt'()
      <_W0> when 'true' ->
        call 'Nova.Compiler.Cst':'TokOperator'('Nothing', Op)
    end
      in {'Just', call 'Data.Tuple':'Tuple'(apply 'makeTokenRange'/3(Tok, StartState, State_), State_)}
      end

'consumeOperator'/2 =
  fun (State, Acc) ->
    case apply 'peek'/1(State) of
      <{'Just', C}> when 'true' ->
        case apply 'isOperatorChar'/1(C) of
      <'true'> when 'true' -> apply 'consumeOperator'/2(apply 'advance'/2(State, 1), call 'erlang':'++'(Acc, call 'Data.String.CodeUnits':'singleton'(C)))
      <'false'> when 'true' -> call 'Data.Tuple':'Tuple'(Acc, State)
    end
      <_W0> when 'true' ->
        call 'Data.Tuple':'Tuple'(Acc, State)
    end

'lexDelimiter'/1 =
  fun (State) ->
    case apply 'peek'/1(State) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', C}> when 'true' ->
        let <Tok> = case C of
      <$(> when 'true' ->
        call 'Nova.Compiler.Cst':'TokLeftParen'()
      <$)> when 'true' ->
        call 'Nova.Compiler.Cst':'TokRightParen'()
      <$[> when 'true' ->
        call 'Nova.Compiler.Cst':'TokLeftSquare'()
      <$]> when 'true' ->
        call 'Nova.Compiler.Cst':'TokRightSquare'()
      <${> when 'true' ->
        call 'Nova.Compiler.Cst':'TokLeftBrace'()
      <$}> when 'true' ->
        call 'Nova.Compiler.Cst':'TokRightBrace'()
      <$,> when 'true' ->
        call 'Nova.Compiler.Cst':'TokComma'()
      <$`> when 'true' ->
        call 'Nova.Compiler.Cst':'TokTick'()
      <$;> when 'true' ->
        call 'Nova.Compiler.Cst':'TokComma'()
      <_W0> when 'true' ->
        call 'Nova.Compiler.Cst':'TokComma'()
    end
      in {'Just', call 'Data.Tuple':'Tuple'(apply 'makeToken'/2(Tok, State), apply 'advance'/2(State, 1))}
      <{'Right', C}> when 'true' ->
        let <Tok> = case C of
      <$(> when 'true' ->
        call 'Nova.Compiler.Cst':'TokLeftParen'()
      <$)> when 'true' ->
        call 'Nova.Compiler.Cst':'TokRightParen'()
      <$[> when 'true' ->
        call 'Nova.Compiler.Cst':'TokLeftSquare'()
      <$]> when 'true' ->
        call 'Nova.Compiler.Cst':'TokRightSquare'()
      <${> when 'true' ->
        call 'Nova.Compiler.Cst':'TokLeftBrace'()
      <$}> when 'true' ->
        call 'Nova.Compiler.Cst':'TokRightBrace'()
      <$,> when 'true' ->
        call 'Nova.Compiler.Cst':'TokComma'()
      <$`> when 'true' ->
        call 'Nova.Compiler.Cst':'TokTick'()
      <$;> when 'true' ->
        call 'Nova.Compiler.Cst':'TokComma'()
      <_W0> when 'true' ->
        call 'Nova.Compiler.Cst':'TokComma'()
    end
      in {'Just', call 'Data.Tuple':'Tuple'(apply 'makeToken'/2(Tok, State), apply 'advance'/2(State, 1))}
      end

'lexUnderscore'/1 =
  fun (State) ->
    let <StartState> = State
      in let <State_> = apply 'advance'/2(State, 1)
      in case apply 'peek'/1(State_) of
      <{'Just', C}> when 'true' ->
        case apply 'isIdentChar'/1(C) of
      <'true'> when 'true' -> let <_Let0> = apply 'consumeIdent'/2(State_, "")
      in case _Let0 of
        <{'Tuple', Name, State__}> when 'true' -> {'Just', call 'Data.Tuple':'Tuple'(apply 'makeTokenRange'/3(call 'Nova.Compiler.Cst':'TokHole'(Name), StartState, State__), State__)}
      end
      <'false'> when 'true' -> {'Just', call 'Data.Tuple':'Tuple'(apply 'makeToken'/2(call 'Nova.Compiler.Cst':'TokUnderscore'(), State), State_)}
    end
      <_W0> when 'true' ->
        {'Just', call 'Data.Tuple':'Tuple'(apply 'makeToken'/2(call 'Nova.Compiler.Cst':'TokUnderscore'(), State), State_)}
    end

'lexNumber'/1 =
  fun (State) ->
    letrec 'makeIntResult'/3 = fun (IntPart, StartState, EndState) ->
      let <IntVal> = call 'Nova.Compiler.Cst':'SmallInt'(call 'Data.Maybe':'fromMaybe'(0, call 'Data.Int':'fromString'(IntPart)))
      in {'Just', call 'Data.Tuple':'Tuple'(apply 'makeTokenRange'/3(call 'Nova.Compiler.Cst':'TokInt'(IntPart, IntVal), StartState, EndState), EndState)}
      in let <StartState> = State
      in case apply 'consumeNumber'/2(State, "") of
      <{'Tuple', IntPart, AfterInt}> when 'true' ->
        case apply 'peek'/1(AfterInt) of
      <{'Just', $.}> when 'true' ->
        case apply 'peekAt'/2(AfterInt, 1) of
      <{'Just', C}> when 'true' ->
        case apply 'isDigit'/1(C) of
      <'true'> when 'true' -> let <AfterDot> = apply 'advance'/2(AfterInt, 1)
      in case apply 'consumeNumber'/2(AfterDot, "") of
      <{'Tuple', FracPart, AfterFrac}> when 'true' ->
        let <NumStr> = call 'erlang':'++'(call 'erlang':'++'(IntPart, "."), FracPart)
      in case call 'Data.Number':'fromString'(NumStr) of
      <{'Just', N}> when 'true' ->
        {'Just', call 'Data.Tuple':'Tuple'(apply 'makeTokenRange'/3(call 'Nova.Compiler.Cst':'TokNumber'(NumStr, N), StartState, AfterFrac), AfterFrac)}
      <'Nothing'> when 'true' ->
        apply 'makeIntResult'/3(IntPart, StartState, AfterInt)
    end
    end
      <'false'> when 'true' -> apply 'makeIntResult'/3(IntPart, StartState, AfterInt)
    end
      <_W0> when 'true' ->
        apply 'makeIntResult'/3(IntPart, StartState, AfterInt)
    end
      <_W0> when 'true' ->
        apply 'makeIntResult'/3(IntPart, StartState, AfterInt)
    end
    end

'consumeNumber'/2 =
  fun (State, Acc) ->
    case apply 'peek'/1(State) of
      <{'Just', C}> when 'true' ->
        case apply 'isDigit'/1(C) of
      <'true'> when 'true' -> apply 'consumeNumber'/2(apply 'advance'/2(State, 1), call 'erlang':'++'(Acc, call 'Data.String.CodeUnits':'singleton'(C)))
      <'false'> when 'true' -> case call 'erlang':'=:='(C, $_) of
      <'true'> when 'true' -> apply 'consumeNumber'/2(apply 'advance'/2(State, 1), Acc)
      <'false'> when 'true' -> call 'Data.Tuple':'Tuple'(Acc, State)
    end
    end
      <_W0> when 'true' ->
        call 'Data.Tuple':'Tuple'(Acc, State)
    end

'lexString'/1 =
  fun (State) ->
    let <StartState> = State
      in let <AfterOpen> = apply 'advance'/2(State, 1)
      in case apply 'consumeString'/2(AfterOpen, "") of
      <{'Tuple', Content, AfterContent}> when 'true' ->
        let <AfterClose> = apply 'advance'/2(AfterContent, 1)
      in {'Just', call 'Data.Tuple':'Tuple'(apply 'makeTokenRange'/3(call 'Nova.Compiler.Cst':'TokString'(Content, Content), StartState, AfterClose), AfterClose)}
    end

'consumeString'/2 =
  fun (State, Acc) ->
    case apply 'peek'/1(State) of
      <'Nothing'> when 'true' ->
        call 'Data.Tuple':'Tuple'(Acc, State)
      <{'Just', $"}> when 'true' ->
        call 'Data.Tuple':'Tuple'(Acc, State)
      <{'Just', $\\}> when 'true' ->
        case apply 'peekAt'/2(State, 1) of
      <{'Just', $n}> when 'true' ->
        apply 'consumeString'/2(apply 'advance'/2(State, 2), call 'erlang':'++'(Acc, "\n"))
      <{'Just', $t}> when 'true' ->
        apply 'consumeString'/2(apply 'advance'/2(State, 2), call 'erlang':'++'(Acc, "\t"))
      <{'Just', $r}> when 'true' ->
        apply 'consumeString'/2(apply 'advance'/2(State, 2), call 'erlang':'++'(Acc, "\r"))
      <{'Just', $"}> when 'true' ->
        apply 'consumeString'/2(apply 'advance'/2(State, 2), call 'erlang':'++'(Acc, "\""))
      <{'Just', $\\}> when 'true' ->
        apply 'consumeString'/2(apply 'advance'/2(State, 2), call 'erlang':'++'(Acc, "\\"))
      <{'Just', C}> when 'true' ->
        apply 'consumeString'/2(apply 'advance'/2(State, 2), call 'erlang':'++'(Acc, call 'Data.String.CodeUnits':'singleton'(C)))
      <'Nothing'> when 'true' ->
        call 'Data.Tuple':'Tuple'(Acc, State)
    end
      <{'Just', $\n}> when 'true' ->
        call 'Data.Tuple':'Tuple'(Acc, State)
      <{'Just', C}> when 'true' ->
        apply 'consumeString'/2(apply 'advance'/2(State, 1), call 'erlang':'++'(Acc, call 'Data.String.CodeUnits':'singleton'(C)))
    end

'lexRawString'/1 =
  fun (State) ->
    let <StartState> = State
      in let <AfterOpen> = apply 'advance'/2(State, 3)
      in case apply 'consumeRawString'/2(AfterOpen, "") of
      <{'Tuple', Content, AfterContent}> when 'true' ->
        let <AfterClose> = apply 'advance'/2(AfterContent, 3)
      in {'Just', call 'Data.Tuple':'Tuple'(apply 'makeTokenRange'/3(call 'Nova.Compiler.Cst':'TokRawString'(Content), StartState, AfterClose), AfterClose)}
    end

'consumeRawString'/2 =
  fun (State, Acc) ->
    case apply 'peek'/1(State) of
      <'Nothing'> when 'true' ->
        call 'Data.Tuple':'Tuple'(Acc, State)
      <{'Just', $"}> when 'true' ->
        case apply 'peekAt'/2(State, 1) of
      <{'Just', $"}> when 'true' ->
        case apply 'peekAt'/2(State, 2) of
      <{'Just', $"}> when 'true' ->
        call 'Data.Tuple':'Tuple'(Acc, State)
      <_W0> when 'true' ->
        apply 'consumeRawString'/2(apply 'advance'/2(State, 1), call 'erlang':'++'(Acc, "\""))
    end
      <_W0> when 'true' ->
        apply 'consumeRawString'/2(apply 'advance'/2(State, 1), call 'erlang':'++'(Acc, "\""))
    end
      <{'Just', $\n}> when 'true' ->
        let <State_> = apply 'advanceNewline'/1(apply 'advance'/2(State, 1))
      in apply 'consumeRawString'/2(State_, call 'erlang':'++'(Acc, "\n"))
      <{'Just', C}> when 'true' ->
        apply 'consumeRawString'/2(apply 'advance'/2(State, 1), call 'erlang':'++'(Acc, call 'Data.String.CodeUnits':'singleton'(C)))
    end

'lexChar'/1 =
  fun (State) ->
    letrec 'parseCharContent'/1 = fun (S) ->
      case apply 'peek'/1(S) of
      <{'Just', $\\}> when 'true' ->
        case apply 'peekAt'/2(S, 1) of
      <{'Just', $n}> when 'true' ->
        call 'Data.Tuple':'Tuple'($\n, apply 'advance'/2(S, 2))
      <{'Just', $t}> when 'true' ->
        call 'Data.Tuple':'Tuple'($\t, apply 'advance'/2(S, 2))
      <{'Just', $r}> when 'true' ->
        call 'Data.Tuple':'Tuple'($\r, apply 'advance'/2(S, 2))
      <{'Just', $'}> when 'true' ->
        call 'Data.Tuple':'Tuple'($', apply 'advance'/2(S, 2))
      <{'Just', $\\}> when 'true' ->
        call 'Data.Tuple':'Tuple'($\\, apply 'advance'/2(S, 2))
      <{'Just', C}> when 'true' ->
        call 'Data.Tuple':'Tuple'(C, apply 'advance'/2(S, 2))
      <'Nothing'> when 'true' ->
        call 'Data.Tuple':'Tuple'($?, S)
    end
      <{'Just', C}> when 'true' ->
        call 'Data.Tuple':'Tuple'(C, apply 'advance'/2(S, 1))
      <'Nothing'> when 'true' ->
        call 'Data.Tuple':'Tuple'($?, S)
    end
      in let <StartState> = State
      in let <AfterOpen> = apply 'advance'/2(State, 1)
      in case apply 'parseCharContent'/1(AfterOpen) of
      <{'Tuple', Ch, AfterChar}> when 'true' ->
        let <AfterClose> = apply 'advance'/2(AfterChar, 1)
      in {'Just', call 'Data.Tuple':'Tuple'(apply 'makeTokenRange'/3(call 'Nova.Compiler.Cst':'TokChar'(call 'Data.String.CodeUnits':'singleton'(Ch), Ch), StartState, AfterClose), AfterClose)}
    end

'skipLineComment'/1 =
  fun (State) ->
    case apply 'peek'/1(State) of
      <'Nothing'> when 'true' ->
        State
      <{'Just', $\n}> when 'true' ->
        State
      <{'Just', $\r}> when 'true' ->
        State
      <{'Just', _W0}> when 'true' ->
        apply 'skipLineComment'/1(apply 'advance'/2(State, 1))
    end

'skipBlockComment'/2 =
  fun (_P0, _P1) ->
    case {_P0, _P1} of
      <{State, 0}> when 'true' ->
        State
      <{State, Depth}> when 'true' ->
        case apply 'peek'/1(State) of
      <'Nothing'> when 'true' ->
        State
      <{'Just', ${}> when 'true' ->
        case apply 'peekAt'/2(State, 1) of
      <{'Just', $-}> when 'true' ->
        apply 'skipBlockComment'/2(apply 'advance'/2(State, 2), call 'erlang':'+'(Depth, 1))
      <_W0> when 'true' ->
        apply 'skipBlockComment'/2(apply 'advance'/2(State, 1), Depth)
    end
      <{'Just', $-}> when 'true' ->
        case apply 'peekAt'/2(State, 1) of
      <{'Just', $}}> when 'true' ->
        apply 'skipBlockComment'/2(apply 'advance'/2(State, 2), call 'erlang':'-'(Depth, 1))
      <_W0> when 'true' ->
        apply 'skipBlockComment'/2(apply 'advance'/2(State, 1), Depth)
    end
      <{'Just', $\n}> when 'true' ->
        apply 'skipBlockComment'/2(apply 'advanceNewline'/1(apply 'advance'/2(State, 1)), Depth)
      <{'Just', _W0}> when 'true' ->
        apply 'skipBlockComment'/2(apply 'advance'/2(State, 1), Depth)
    end
    end

'initLexState'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'initLexState'/1(_A0)
      in _F0

'isIndented'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'isIndented'/1(_A0)
      in _F0

'lytToken'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'lytToken'/2(_A0, _A1)
      in _F1
      in _F0

'lytToken'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'lytToken'/2(_A0, _A1)
      in _F0

'closeLayouts'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'closeLayouts'/1(_A0)
      in _F0

'closeLayoutsGo'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'closeLayoutsGo'/2(_A0, _A1)
      in _F1
      in _F0

'closeLayoutsGo'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'closeLayoutsGo'/2(_A0, _A1)
      in _F0

'callInsertLayout'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'callInsertLayout'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'callInsertLayout'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'callInsertLayout'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'callInsertLayout'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'callInsertLayout'/3(_A0, _A1, _A2)
      in _F0

'insertLayoutGo'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'insertLayoutGo'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'insertLayoutGo'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'insertLayoutGo'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'insertLayoutGo'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'insertLayoutGo'/3(_A0, _A1, _A2)
      in _F0

'insertLayoutTokens'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'insertLayoutTokens'/1(_A0)
      in _F0

'lexModule'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'lexModule'/1(_A0)
      in _F0

'lexTokens'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'lexTokens'/1(_A0)
      in _F0

'lexTokensGo'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'lexTokensGo'/2(_A0, _A1)
      in _F1
      in _F0

'lexTokensGo'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'lexTokensGo'/2(_A0, _A1)
      in _F0

'lexToken'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'lexToken'/1(_A0)
      in _F0

'isDigit'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'isDigit'/1(_A0)
      in _F0

'isUpper'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'isUpper'/1(_A0)
      in _F0

'isLower'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'isLower'/1(_A0)
      in _F0

'isAlpha'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'isAlpha'/1(_A0)
      in _F0

'isAlphaNum'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'isAlphaNum'/1(_A0)
      in _F0

'isIdentStart'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'isIdentStart'/1(_A0)
      in _F0

'isIdentChar'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'isIdentChar'/1(_A0)
      in _F0

'isOperatorChar'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'isOperatorChar'/1(_A0)
      in _F0

'peek'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'peek'/1(_A0)
      in _F0

'peekAt'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'peekAt'/2(_A0, _A1)
      in _F1
      in _F0

'peekAt'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'peekAt'/2(_A0, _A1)
      in _F0

'advance'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'advance'/2(_A0, _A1)
      in _F1
      in _F0

'advance'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'advance'/2(_A0, _A1)
      in _F0

'advanceNewline'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'advanceNewline'/1(_A0)
      in _F0

'advanceTab'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'advanceTab'/1(_A0)
      in _F0

'makeToken'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'makeToken'/2(_A0, _A1)
      in _F1
      in _F0

'makeToken'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'makeToken'/2(_A0, _A1)
      in _F0

'makeTokenRange'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'makeTokenRange'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'makeTokenRange'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'makeTokenRange'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'makeTokenRange'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'makeTokenRange'/3(_A0, _A1, _A2)
      in _F0

'lexIdentOrKeyword'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'lexIdentOrKeyword'/1(_A0)
      in _F0

'makeKeywordToken'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'makeKeywordToken'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'makeKeywordToken'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'makeKeywordToken'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'makeKeywordToken'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'makeKeywordToken'/3(_A0, _A1, _A2)
      in _F0

'makeIdentToken'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'makeIdentToken'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'makeIdentToken'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'makeIdentToken'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'makeIdentToken'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'makeIdentToken'/3(_A0, _A1, _A2)
      in _F0

'lexUpperIdentifier'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'lexUpperIdentifier'/1(_A0)
      in _F0

'checkQualifiedChain'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'checkQualifiedChain'/2(_A0, _A1)
      in _F1
      in _F0

'checkQualifiedChain'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'checkQualifiedChain'/2(_A0, _A1)
      in _F0

'consumeIdent'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'consumeIdent'/2(_A0, _A1)
      in _F1
      in _F0

'consumeIdent'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'consumeIdent'/2(_A0, _A1)
      in _F0

'consumeUpperIdent'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'consumeUpperIdent'/2(_A0, _A1)
      in _F1
      in _F0

'consumeUpperIdent'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'consumeUpperIdent'/2(_A0, _A1)
      in _F0

'lexOperator'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'lexOperator'/1(_A0)
      in _F0

'consumeOperator'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'consumeOperator'/2(_A0, _A1)
      in _F1
      in _F0

'consumeOperator'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'consumeOperator'/2(_A0, _A1)
      in _F0

'lexDelimiter'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'lexDelimiter'/1(_A0)
      in _F0

'lexUnderscore'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'lexUnderscore'/1(_A0)
      in _F0

'lexNumber'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'lexNumber'/1(_A0)
      in _F0

'consumeNumber'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'consumeNumber'/2(_A0, _A1)
      in _F1
      in _F0

'consumeNumber'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'consumeNumber'/2(_A0, _A1)
      in _F0

'lexString'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'lexString'/1(_A0)
      in _F0

'consumeString'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'consumeString'/2(_A0, _A1)
      in _F1
      in _F0

'consumeString'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'consumeString'/2(_A0, _A1)
      in _F0

'lexRawString'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'lexRawString'/1(_A0)
      in _F0

'consumeRawString'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'consumeRawString'/2(_A0, _A1)
      in _F1
      in _F0

'consumeRawString'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'consumeRawString'/2(_A0, _A1)
      in _F0

'lexChar'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'lexChar'/1(_A0)
      in _F0

'skipLineComment'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'skipLineComment'/1(_A0)
      in _F0

'skipBlockComment'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'skipBlockComment'/2(_A0, _A1)
      in _F1
      in _F0

'skipBlockComment'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'skipBlockComment'/2(_A0, _A1)
      in _F0
end
