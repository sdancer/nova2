module 'Nova.Compiler.CstLexer' ['initLexState'/1, 'keywords'/0, 'isIndented'/1, 'lytToken'/2, 'closeLayouts'/1, 'closeLayoutsGo'/2, 'callInsertLayout'/3, 'insertLayoutGo'/3, 'insertLayoutTokens'/1, 'lexModule'/1, 'lexTokens'/1, 'lexTokensGo'/2, 'lexToken'/1, 'isDigit'/1, 'isUpper'/1, 'isLower'/1, 'isAlpha'/1, 'isAlphaNum'/1, 'isIdentStart'/1, 'isIdentChar'/1, 'isOperatorChar'/1, 'peek'/1, 'peekAt'/2, 'advance'/2, 'advanceNewline'/1, 'advanceTab'/1, 'makeToken'/2, 'makeTokenRange'/3, 'lexIdentOrKeyword'/1, 'makeKeywordToken'/3, 'makeIdentToken'/3, 'lexUpperIdentifier'/1, 'checkQualifiedChain'/2, 'consumeIdent'/2, 'consumeUpperIdent'/2, 'lexOperator'/1, 'consumeOperator'/2, 'lexDelimiter'/1, 'lexUnderscore'/1, 'lexNumber'/1, 'consumeNumber'/2, 'lexString'/1, 'consumeString'/2, 'lexRawString'/1, 'consumeRawString'/2, 'lexChar'/1, 'skipLineComment'/1, 'skipBlockComment'/2, 'initLexState'/0, 'isIndented'/0, 'lytToken'/0, 'lytToken'/1, 'closeLayouts'/0, 'closeLayoutsGo'/0, 'closeLayoutsGo'/1, 'callInsertLayout'/0, 'callInsertLayout'/1, 'callInsertLayout'/2, 'insertLayoutGo'/0, 'insertLayoutGo'/1, 'insertLayoutGo'/2, 'insertLayoutTokens'/0, 'lexModule'/0, 'lexTokens'/0, 'lexTokensGo'/0, 'lexTokensGo'/1, 'lexToken'/0, 'isDigit'/0, 'isUpper'/0, 'isLower'/0, 'isAlpha'/0, 'isAlphaNum'/0, 'isIdentStart'/0, 'isIdentChar'/0, 'isOperatorChar'/0, 'peek'/0, 'peekAt'/0, 'peekAt'/1, 'advance'/0, 'advance'/1, 'advanceNewline'/0, 'advanceTab'/0, 'makeToken'/0, 'makeToken'/1, 'makeTokenRange'/0, 'makeTokenRange'/1, 'makeTokenRange'/2, 'lexIdentOrKeyword'/0, 'makeKeywordToken'/0, 'makeKeywordToken'/1, 'makeKeywordToken'/2, 'makeIdentToken'/0, 'makeIdentToken'/1, 'makeIdentToken'/2, 'lexUpperIdentifier'/0, 'checkQualifiedChain'/0, 'checkQualifiedChain'/1, 'consumeIdent'/0, 'consumeIdent'/1, 'consumeUpperIdent'/0, 'consumeUpperIdent'/1, 'lexOperator'/0, 'consumeOperator'/0, 'consumeOperator'/1, 'lexDelimiter'/0, 'lexUnderscore'/0, 'lexNumber'/0, 'consumeNumber'/0, 'consumeNumber'/1, 'lexString'/0, 'consumeString'/0, 'consumeString'/1, 'lexRawString'/0, 'consumeRawString'/0, 'consumeRawString'/1, 'lexChar'/0, 'skipLineComment'/0, 'skipBlockComment'/0, 'skipBlockComment'/1, 'module_info'/0, 'module_info'/1]
  attributes []
'initLexState'/1 =
  fun (Input) ->
    ч铕豸Ы旧铕豸с栳蝮Ы俱犰尼翎郁蜷铉蔑溴疹轸螫骇麸描狎硫蜥Ж深瘐舂ю矬Ы景ъ轭濮骄爆с镬蹴瞌骄饼щ妁黠蜾螫骢ī郏＜卑簿ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北淳ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑稻ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑尘ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北熬ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺，｛＜卑咕ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑熬ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北肪ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑妇ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺，｛＜北咕ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑淳ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北淳ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺，｛＜卑稻ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑咕ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北簿ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北淳ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北毒ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺，｛＜卑熬ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜狗鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北毒ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜狗鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺，｛＜北毒ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜辈本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北簿ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺，｛＜构鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑妇ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜狗鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北稻ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北稻ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺，｛＜卑稻ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北熬ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北稻ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北毒ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜狗鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北熬ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜构鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺，｛＜卑妇ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北毒ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺，｛＜卑稻ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北熬ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺，｛＜卑稻ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑簿ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺，｛＜北毒ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑淳ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北熬ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺，｛＜卑本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑妇ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北稻ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺，｛＜构鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜狗鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北稻ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺，｛＜北本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑簿ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺，｛＜卑熬ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺，｛＜狗鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑熬ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺，｛＜卑熬ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北淳ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑稻ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北妇ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺，｛＜北熬ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北咕ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北毒ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜辈本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北簿ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺，｛＜卑稻ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北熬ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑簿ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑稻ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜辈熬ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑妇ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺，｛＜卑稻ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北熬ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑簿ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑稻ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜辈熬ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北淳ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺，｛＜卑稻ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北熬ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑簿ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑稻ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜辈熬ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺，｛＜卑簿ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北淳ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜狗鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑妇ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑妇ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺，｛＜狗鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北稻ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺，｛＜卑淳ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑稻ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑熬ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑稻ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北熬ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑尘ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺，｛＜北毒ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北淳ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北肪ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺，｛＜卑簿ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜狗鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑妇ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北稻ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺，｛＜北淳ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑妇ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺，｛＜北熬ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑咕ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑稻ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北熬ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜狗鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑妇ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺，｛＜北淳ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北簿ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北淳ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北稻ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北熬ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北毒ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜狗鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北毒ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑稻ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北熬ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜狗鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑妇ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺，｛＜北簿ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑淳ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜狗鲸脯爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北熬ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北毒ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜北本ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺┈＜卑咕ǜ爆ч铘彗弪К郄躅箝珙邃郄忾绉葺］ч笊钿孱翦洄骢ㄌ舂汜箦贴镦姬贴籼弭Ь麒孱趄蹂趄蹂姬贴籼弭郁眙Ь麒孱趄蹂趄蹂姬贴糇桢蝈Ь麒孱趄蹂趄蹂姬贴粝妲麒孱趄蹂趄蹂姬贴裟铵麒孱趄蹂趄蹂姬贴袅滹Ь麒孱趄蹂趄蹂歼装麒孱趄蹂ф犰箦孱ъ粼镫孱Н骢ㄐ矬轴祯濠蜥铉濮骄篝狎臾骄酗蟋у钿Ы拘矬ъ遽溟铉蔑眄孱趔Ы聚莠趄衢扉铉蔑眄孱趔Ы聚莠鲠祯濮骄轴祯妪с祜箦提秕趔Н骢ㄓ翎汶狃痨с祜箦提秕趔秋Н波圯郁徙氅с祜箦提秕趔秋Н骢ㄟ邪咝暴汜箦咝艾咝饼镦见零悻圯麒孱趄蹂零见零悻埯г躔戾К酗蟋贴酏义篝蔟麒孱趄蹂汜箦狃痨ч笊钿孱翦洄报贴舂镦姬趄蹂Ь麒孱趄蹂戾寂钿燥刖狃痨ъ粼镫孱Н波酗蟋汜祆物鲠蔑眇殪弪皿臾骇燥胩狴秕襞钿Ж汜祆ы狃螫骇珏臾ě泔祯眍К酗螬┅轭狃痨с祜箦提秕趔秋Н波汜祆物鲠序屐蹁濮骇箦黹珧秕鹆痧孱渖眇歆零悻叟钿燥圯荸义篝姬驷祗濮麒孱趄蹂狃痨с祜箦提秕趔秋Н波零悻义篝孱孱с犰焐铙弪籼狴秕臾骢ㄔ镫酗蟋郁氅汜祆物鲠蔑眇殪弪皿籼狴秕臾骇轭箦螋提秕臾ㄔ镫酗蟋郁氅ч铙弪籼狴秕羟铵骢ㄓ翎汶燥塍零悌汜箦燥塍镦价菥麒孱趄蹂汜祆物鲠序屐蹁濮骇箦黹珧秕鹆痧孱渖眇歆零悻狃痨с祜箦提秕趔Н报郁徙氅价燥义篝菥麒孱趄蹂戾嘉屮粜矬汜箦义篝镦价五咦拜麒孱趄蹂汜祆ы狃螫骇珏臾ě篝狎臾汜祆ы狃螫骇珏臾ě蜥铉濮五舂价菥麒孱趄蹂ъ轭濮骄汜祆у蜢犷绉骇Ж汜祆ы狃螫骇珏臾ě扉铄К汜祆ы狃螫骇珏臾ě孱洄汜祆ы狃螫骇珏臾ě蜥铉濮燥氅┅暴с镬蹴瞌骄饼孱轭汜箦狃痨с犰焐铙弪籼狴秕臾敞燥氍五粜矬郁徙氅镦见г躔戾К五饔翎汶硝麴豸燥脲铙麒孱趄蹂戾嘉鬻燥塍汜祆ъ轶趔Шы狃Ж汜祆尼翎怎痨濮骇骟臾ī硝麴豸燥脲铙轭狃痨ч铙弪籼狴秕羟铵敞五饔翎汶义篝汜祆物鲠序屐蹁濮骇箦黹珧秕鹆痧孱渖眇歆零悻五髟镫螬孱孱ч铙弪籼狴秕粼镫孱螫骢ㄔ镫孱螬戾趄邈х弭绎雉提秕臾骢ㄟ装汜祆物鲠蔑眇殪弪皿籼狴秕臾骇蝻雉提秕裟屐轫Ж轭戾忌铋粜矬ъ轭濮骄爆с镬蹴瞌骄饼轭戾忌铋粲翎汶坫犰尼翎怎痨濮骇怎痨濮ㄉ铋粜矬狃痨х弭绎雉提秕臾报┅圯轭狃痨ч铙弪籼狴秕羟铵敞深轸郁徙氍燥脲铙圯ъ屮惋漉戾Н骢ㄓ秕蜚濠戾家狩燥脲铙狃痨ъ屮燥脲铙Н报语躜沐轭狃痨ч铙弪籼狴秕粼镫孱螫报裔髟镫孱螬ъ屮燥脲铙Н骢ㄓ秕蜚濠狃痨ъ屮燥脲铙秋Н波狃痨ч铋籼屮郁狒濮报语躜沐┈圯ъ屮燥脲铙秋Н骢ㄓ翎翦零悌汜箦狃痨ъ屮燥脲瞌报郁狒濠镦姬物翳轭绉麒孱趄蹂零见术篝Кг躔戾К燥氍郁狒暹麒孱趄蹂狃痨ъ屮燥脲铙秋Н波郁狒暹汜祆物鲠序屐蹁濮骇箦黹珧秕鹆痧孱渖眇歆零悻墼镫圯荸孱ъ屮燥脲瞌骢ㄓ翎翦汜箦狃痨ю邋毵报郁狒濠镦姬物翳轭绉麒孱趄蹂物翳轭绉见体骠К吲蝌麒孱趄蹂体骠К吲蝌见术篝К谬麒孱趄蹂汜箦镦激麒孱趄蹂狃痨ъ屮燥脲瞌报狃痨п漩犷沐Н波郁狒瀣暴激荇麒孱趄蹂狃痨ъ屮燥脲瞌报狃痨п漩犷沐葬猝报郁狒濠激茴麒孱趄蹂狃痨ъ屮燥脲瞌报狃痨п漩犷沐五黛轭濮报狃痨п漩犷沐Н波郁狒瀣暴┅激茯麒孱趄蹂汜箦狃痨ю邋肓臾波郁狒瀣暴镦见术篝Кぼ铨麒孱趄蹂狃痨ъ屮燥脲瞌报狃痨п漩犷沐五黛轭濮报狃痨п漩犷沐Н波郁狒瀣博┅歼装麒孱趄蹂狃痨ъ屮燥脲瞌报狃痨п漩犷沐五黛轭濮报狃痨п漩犷沐Н波郁狒瀣暴┅孱激麒孱趄蹂汜箦狃痨ю邋肓臾波郁狒瀣暴镦见术篝Кき麒孱趄蹂戾加翎翦呔狃痨箅轲涕铄蔑眄孱臾报狃痨п漩犷沐Н波郁狒瀣博轭狃痨ъ屮燥脲瞌报郁狒暹歼装麒孱趄蹂狃痨ъ屮橡弪狒矧Н报郁狒濠孱激麒孱趄蹂汜箦狃痨ю邋肓臾波郁狒瀣暴镦见术篝Кき麒孱趄蹂戾加翎翦呔狃痨箅轲蚂镢朊镯礤铘Н波狃痨п漩犷沐Н波郁狒瀣博暴轭狃痨ъ屮燥脲瞌报郁狒暹歼装麒孱趄蹂狃痨ъ屮腻扉黹翦颛报郁狒濠孱激⒕麒孱趄蹂汜箦狃痨ю邋肓臾波郁狒瀣暴镦见术篝Кあ麒孱趄蹂汜箦狃痨ю邋肓臾波郁狒瀣博镦见术篝Кあ麒孱趄蹂狃痨ъ屮裔饔趄轭绉报郁狒濠歼装麒孱趄蹂狃痨ъ屮郁蜷铉Н报郁狒濠孱歼装麒孱趄蹂狃痨ъ屮郁蜷铉Н报郁狒濠孱激Ь麒孱趄蹂狃痨ъ屮描狎Н报郁狒濠激麒孱趄蹂狃痨ъ屮腻扉黹翦颛报郁狒濠激┚麒孱趄蹂狃痨ъ屮腻扉黹翦颛报郁狒濠激劬麒孱趄蹂狃痨ъ屮腻扉黹翦颛报郁狒濠激菥麒孱趄蹂狃痨ъ屮腻扉黹翦颛报郁狒濠激麒孱趄蹂狃痨ъ屮腻扉黹翦颛报郁狒濠激麒孱趄蹂狃痨ъ屮腻扉黹翦颛报郁狒濠激嗑麒孱趄蹂狃痨ъ屮腻扉黹翦颛报郁狒濠激痪麒孱趄蹂狃痨ъ屮腻扉黹翦颛报郁狒濠激呔麒孱趄蹂狃痨ъ屮疹溴蝮泔蝈Н报郁狒濠激谰麒孱趄蹂术篝К汜祆尼翎怎痨濮骇怎痨濮ㄡ痧禊ы犭逶镫孱Н波汜祆物鲠蔑眇殪弪皿臾骇燥肓臾ī郁狒濠狃痨п漩犷沐Н波郁狒瀣暴歼装麒孱趄蹂汜箦狃痨ч竽殓轸Н报茅镦姬趄蹂Ь麒孱趄蹂狃痨ъ屮熙礅弪Н报郁狒濠姬驷祗濮麒孱趄蹂汜箦狃痨ч笊溴铘郁狎臾报茅镦姬趄蹂Ь麒孱趄蹂狃痨ъ屮射孱粝蛩妁黠蜾Н报郁狒濠姬驷祗濮麒孱趄蹂汜箦狃痨ч笳痧弪Н报茅镦姬趄蹂Ь麒孱趄蹂狃痨ъ屮震疱蛏溴铘殒殄颛报郁狒濠姬驷祗濮麒孱趄蹂汜箦狃痨ч笙疱蜥麸蛎栳颛报茅镦姬趄蹂Ь麒孱趄蹂狃痨ъ屮橡弪狒矧Н报郁狒濠姬驷祗濮麒孱趄蹂狃痨ъ屮燥脲瞌报狃痨п漩犷沐Н波郁狒瀣暴孱孱孱孱孱见б殓梏К谬麒孱趄蹂汜箦镦激麒孱趄蹂狃痨ъ屮燥脲瞌报狃痨п漩犷沐Н波郁狒瀣暴激荇麒孱趄蹂狃痨ъ屮燥脲瞌报狃痨п漩犷沐葬猝报郁狒濠激茴麒孱趄蹂狃痨ъ屮燥脲瞌报狃痨п漩犷沐五黛轭濮报狃痨п漩犷沐Н波郁狒瀣暴┅激茯麒孱趄蹂汜箦狃痨ю邋肓臾波郁狒瀣暴镦见术篝Кぼ铨麒孱趄蹂狃痨ъ屮燥脲瞌报狃痨п漩犷沐五黛轭濮报狃痨п漩犷沐Н波郁狒瀣博┅歼装麒孱趄蹂狃痨ъ屮燥脲瞌报狃痨п漩犷沐五黛轭濮报狃痨п漩犷沐Н波郁狒瀣暴┅孱激麒孱趄蹂汜箦狃痨ю邋肓臾波郁狒瀣暴镦见术篝Кき麒孱趄蹂戾加翎翦呔狃痨箅轲涕铄蔑眄孱臾报狃痨п漩犷沐Н波郁狒瀣博轭狃痨ъ屮燥脲瞌报郁狒暹歼装麒孱趄蹂狃痨ъ屮橡弪狒矧Н报郁狒濠孱激麒孱趄蹂汜箦狃痨ю邋肓臾波郁狒瀣暴镦见术篝Кき麒孱趄蹂戾加翎翦呔狃痨箅轲蚂镢朊镯礤铘Н波狃痨п漩犷沐Н波郁狒瀣博暴轭狃痨ъ屮燥脲瞌报郁狒暹歼装麒孱趄蹂狃痨ъ屮腻扉黹翦颛报郁狒濠孱激⒕麒孱趄蹂汜箦狃痨ю邋肓臾波郁狒瀣暴镦见术篝Кあ麒孱趄蹂汜箦狃痨ю邋肓臾波郁狒瀣博镦见术篝Кあ麒孱趄蹂狃痨ъ屮裔饔趄轭绉报郁狒濠歼装麒孱趄蹂狃痨ъ屮郁蜷铉Н报郁狒濠孱歼装麒孱趄蹂狃痨ъ屮郁蜷铉Н报郁狒濠孱激Ь麒孱趄蹂狃痨ъ屮描狎Н报郁狒濠激麒孱趄蹂狃痨ъ屮腻扉黹翦颛报郁狒濠激┚麒孱趄蹂狃痨ъ屮腻扉黹翦颛报郁狒濠激劬麒孱趄蹂狃痨ъ屮腻扉黹翦颛报郁狒濠激菥麒孱趄蹂狃痨ъ屮腻扉黹翦颛报郁狒濠激麒孱趄蹂狃痨ъ屮腻扉黹翦颛报郁狒濠激麒孱趄蹂狃痨ъ屮腻扉黹翦颛报郁狒濠激嗑麒孱趄蹂狃痨ъ屮腻扉黹翦颛报郁狒濠激痪麒孱趄蹂狃痨ъ屮腻扉黹翦颛报郁狒濠激呔麒孱趄蹂狃痨ъ屮疹溴蝮泔蝈Н报郁狒濠激谰麒孱趄蹂术篝К汜祆尼翎怎痨濮骇怎痨濮ㄡ痧禊ы犭逶镫孱Н波汜祆物鲠蔑眇殪弪皿臾骇燥肓臾ī郁狒濠狃痨п漩犷沐Н波郁狒瀣暴歼装麒孱趄蹂汜箦狃痨ч竽殓轸Н报茅镦姬趄蹂Ь麒孱趄蹂狃痨ъ屮熙礅弪Н报郁狒濠姬驷祗濮麒孱趄蹂汜箦狃痨ч笊溴铘郁狎臾报茅镦姬趄蹂Ь麒孱趄蹂狃痨ъ屮射孱粝蛩妁黠蜾Н报郁狒濠姬驷祗濮麒孱趄蹂汜箦狃痨ч笳痧弪Н报茅镦姬趄蹂Ь麒孱趄蹂狃痨ъ屮震疱蛏溴铘殒殄颛报郁狒濠姬驷祗濮麒孱趄蹂汜箦狃痨ч笙疱蜥麸蛎栳颛报茅镦姬趄蹂Ь麒孱趄蹂狃痨ъ屮橡弪狒矧Н报郁狒濠姬驷祗濮麒孱趄蹂狃痨ъ屮燥脲瞌报狃痨п漩犷沐Н波郁狒瀣暴孱孱孱孱孱孱ч竽殓轸Н骢茅汜箦汜祆у蜢犷绉骇窘Ж矛ぐ镦姬趄蹂Ь麒孱趄蹂汜祆у蜢犷绉骇郊Ж矛す歼麒孱趄蹂ф犰箦孱ч笳痧弪Н骢茅汜箦汜祆у蜢犷绉骇窘Ж矛ち镦姬趄蹂Ь麒孱趄蹂汜祆у蜢犷绉骇郊Ж矛ぺ歼麒孱趄蹂ф犰箦孱ч筇秣弪Н骢茅汜箦汜祆у蜢犷绉骇窘Ж矛め镦姬趄蹂Ь麒孱趄蹂汜祆у蜢犷绉骇郊Ж矛歼麒孱趄蹂ф犰箦孱ч罅祓栳Н骢茅汜箦狃痨ч笳痧弪Н报茅镦姬趄蹂Ь麒孱趄蹂趄蹂歼麒孱趄蹂狃痨ч筇秣弪Н报茅孱ч罅祓栳熙恣骢茅汜箦狃痨ч罅祓栳Н报茅镦姬趄蹂Ь麒孱趄蹂趄蹂歼麒孱趄蹂狃痨ч竽殓轸Н报茅孱ч笊溴铘郁狎臾骢茅汜箦狃痨ч筇秣弪Н报茅镦姬趄蹂Ь麒孱趄蹂趄蹂歼麒孱趄蹂汜祆у蜢犷绉骇胶涧矛み孱ч笊溴铘描狎Н骢茅汜箦汜箦狃痨ч罅祓栳熙恣报茅镦姬趄蹂Ь麒孱趄蹂趄蹂歼麒孱趄蹂汜祆у蜢犷绉骇胶涧矛み孱镦姬趄蹂Ь麒孱趄蹂趄蹂歼麒孱趄蹂汜祆у蜢犷绉骇胶涧矛ぇ孱ч笙疱蜥麸蛎栳颛骢茅汜箦汜箦汜箦汜箦汜箦汜箦汜箦汜箦汜箦汜箦汜箦汜箦汜箦汜箦汜箦汜箦汜箦汜箦汜祆у蜢犷绉骇胶涧矛ず镦姬趄蹂Ь麒孱趄蹂趄蹂歼麒孱趄蹂汜祆у蜢犷绉骇胶涧矛ぁ孱镦姬趄蹂Ь麒孱趄蹂趄蹂歼麒孱趄蹂汜祆у蜢犷绉骇胶涧矛ぃ孱镦姬趄蹂Ь麒孱趄蹂趄蹂歼麒孱趄蹂汜祆у蜢犷绉骇胶涧矛い孱镦姬趄蹂Ь麒孱趄蹂趄蹂歼麒孱趄蹂汜祆у蜢犷绉骇胶涧矛ぅ孱镦姬趄蹂Ь麒孱趄蹂趄蹂歼麒孱趄蹂汜祆у蜢犷绉骇胶涧矛う孱镦姬趄蹂Ь麒孱趄蹂趄蹂歼麒孱趄蹂汜祆у蜢犷绉骇胶涧矛お孱镦姬趄蹂Ь麒孱趄蹂趄蹂歼麒孱趄蹂汜祆у蜢犷绉骇胶涧矛か孱镦姬趄蹂Ь麒孱趄蹂趄蹂歼麒孱趄蹂汜祆у蜢犷绉骇胶涧矛ぎ孱镦姬趄蹂Ь麒孱趄蹂趄蹂歼麒孱趄蹂汜祆у蜢犷绉骇胶涧矛く孱镦姬趄蹂Ь麒孱趄蹂趄蹂歼麒孱趄蹂汜祆у蜢犷绉骇胶涧矛ぜ孱镦姬趄蹂Ь麒孱趄蹂趄蹂歼麒孱趄蹂汜祆у蜢犷绉骇胶涧矛そ孱镦姬趄蹂Ь麒孱趄蹂趄蹂歼麒孱趄蹂汜祆у蜢犷绉骇胶涧矛ぞ孱镦姬趄蹂Ь麒孱趄蹂趄蹂歼麒孱趄蹂汜祆у蜢犷绉骇胶涧矛た孱镦姬趄蹂Ь麒孱趄蹂趄蹂歼麒孱趄蹂汜祆у蜢犷绉骇胶涧矛ぼ堠孱镦姬趄蹂Ь麒孱趄蹂趄蹂歼麒孱趄蹂汜祆у蜢犷绉骇胶涧矛ま孱镦姬趄蹂Ь麒孱趄蹂趄蹂歼麒孱趄蹂汜祆у蜢犷绉骇胶涧矛孱镦姬趄蹂Ь麒孱趄蹂趄蹂歼麒孱趄蹂汜祆у蜢犷绉骇胶涧矛き孱镦姬趄蹂Ь麒孱趄蹂趄蹂歼麒孱趄蹂汜祆у蜢犷绉骇胶涧矛孱ю邋毵骢ㄓ翎翦汜祆尼翎硫蜥Шч钿屮Ж汜祆ы狃螫骇珏臾ě汨狎螫郁狒濠汜祆ы狃螫骇珏臾ě痫螫郁狒濠ю邋肓臾骢ㄓ翎翦湘骟弭汜祆尼翎硫蜥Шч钿屮Ж汜祆ы狃螫骇珏臾ě汨狎螫郁狒濠汜祆у蜢犷绉骇Ж汜祆ы狃螫骇珏臾ě痫螫郁狒濠湘骟弭┅п漩犷沐Н骢ㄓ翎翦惟汜祆ы狃螫骇礤蜱濮ㄓ翎翦ю矬Ы俱犰у蜢犷绉骇Ж汜祆ы狃螫骇珏臾ě痫螫郁狒濠惟с镬蹴瞌骄汜祆у蜢犷绉骇Ж汜祆ы狃螫骇珏臾ě泔祯眍К郁狒濠惟п漩犷沐五黛轭濮骢ㄓ翎翦汜祆ы狃螫骇礤蜱濮ㄓ翎翦ъ轭濮骄汜祆у蜢犷绉骇Ж汜祆ы狃螫骇珏臾ě扉铄К郁狒濠暴с镬蹴瞌骄饼п漩犷沐葬猝骢ㄓ翎翦戾济镬汜祆ы狃螫骇珏臾ě泔祯眍К郁狒濠轭戾嘉屮粼徕汜祆у蜢犷绉骇Ж汜祆у蜢犷绉骇Ж汜祆у蜢犷绉骇Ж汜祆у蜢犷绉骇溟雩ㄣ犰у蜢犷绉骇Ж蔑飕暴俯暴俯暴轭汜祆ы狃螫骇礤蜱濮ㄓ翎翦ю矬Ы俱犰у蜢犷绉骇Ж汜祆ы狃螫骇珏臾ě痫螫郁狒濠暴с镬蹴瞌骄五粼徕ы犭逶镫孱Н骢ㄔ镫郁狒濠蜥铉濮骄篝狎臾骄ъ轭濮骄汜祆ы狃螫骇珏臾ě扉铄К郁狒濠с镬蹴瞌骄汜祆ы狃螫骇珏臾ě泔祯眍К郁狒濠у钿Ы峻ъ轭濮骄汜祆ы狃螫骇珏臾ě扉铄К郁狒濠с镬蹴瞌骄汜祆ы狃螫骇珏臾ě泔祯眍К郁狒濠,'leadingComments'=>[],'trailingComments'=>[],'value'=>Tok}
'makeTokenRange'/3 =
  fun (Tok, StartState, EndState) ->
    蜥铉濮骄篝狎臾骄ъ轭濮骄汜祆ы狃螫骇珏臾ě扉铄К郁狎粲翎翦┈с镬蹴瞌骄汜祆ы狃螫骇珏臾ě泔祯眍К郁狎粲翎翦у钿Ы峻ъ轭濮骄汜祆ы狃螫骇珏臾ě扉铄К蓬溆翎翦┈с镬蹴瞌骄汜祆ы狃螫骇珏臾ě泔祯眍К蓬溆翎翦,'leadingComments'=>[],'trailingComments'=>[],'value'=>Tok}
'lexIdentOrKeyword'/1 =
  fun (State) ->
    let <StartState> = State
      in let <_Let0> = apply 'consumeIdent'/2(State, #{}#)
      in case _Let0 of
        <{'Tuple', Name, State_}> when 'true' -> let <Tok> = case call 'Data.Array':'elem'(Name, apply 'keywords'/0()) of
      <'true'> when 'true' -> apply 'makeKeywordToken'/3(Name, StartState, State_)
      <'false'> when 'true' -> apply 'makeIdentToken'/3(Name, StartState, State_)
    end
      in {'Just', call 'Data.Tuple':'Tuple'(Tok, State_)}
      end

'makeKeywordToken'/3 =
  fun (Name, StartState, EndState) ->
    let <Token> = case Name of
      <#{#<102>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<108>(8,1,'integer',['unsigned'|['big']]),#<108>(8,1,'integer',['unsigned'|['big']])}#> when 'true' ->
        call 'Nova.Compiler.Cst':'TokForall'()
      <_W0> when 'true' ->
        call 'Nova.Compiler.Cst':'TokLowerName'('Nothing', Name)
    end
      in apply 'makeTokenRange'/3(Token, StartState, EndState)

'makeIdentToken'/3 =
  fun (Name, StartState, EndState) ->
    apply 'makeTokenRange'/3(call 'Nova.Compiler.Cst':'TokLowerName'('Nothing', Name), StartState, EndState)

'lexUpperIdentifier'/1 =
  fun (State) ->
    let <StartState> = State
      in let <_Let0> = apply 'consumeUpperIdent'/2(State, #{}#)
      in case _Let0 of
        <{'Tuple', Name, State_}> when 'true' -> let <Result> = case apply 'peek'/1(State_) of
      <{'Just', $.}> when 'true' ->
        let <State__> = apply 'advance'/2(State_, 1)
      in apply 'checkQualifiedChain'/2(Name, State__)
      <_W0> when 'true' ->
        call 'Data.Tuple':'Tuple'(call 'Nova.Compiler.Cst':'TokUpperName'('Nothing', Name), State_)
    end
      in let <_Let1> = Result
      in case _Let1 of
        <{'Tuple', Tok, FinalState}> when 'true' -> {'Just', call 'Data.Tuple':'Tuple'(apply 'makeTokenRange'/3(Tok, StartState, FinalState), FinalState)}
      end
      end

'checkQualifiedChain'/2 =
  fun (Prefix, State) ->
    case apply 'peek'/1(State) of
      <{'Just', C}> when 'true' ->
        case apply 'isUpper'/1(C) of
      <'true'> when 'true' -> let <_Let0> = apply 'consumeUpperIdent'/2(State, #{}#)
      in case _Let0 of
        <{'Tuple', Name, State_}> when 'true' -> let <FullPrefix> = call 'Nova.Prelude':'semigroupAppendImpl'(call 'Nova.Prelude':'semigroupAppendImpl'(Prefix, #{#<46>(8,1,'integer',['unsigned'|['big']])}#), Name)
      in case apply 'peek'/1(State_) of
      <{'Just', $.}> when 'true' ->
        apply 'checkQualifiedChain'/2(FullPrefix, apply 'advance'/2(State_, 1))
      <_W0> when 'true' ->
        call 'Data.Tuple':'Tuple'(call 'Nova.Compiler.Cst':'TokUpperName'({'Just', Prefix}, Name), State_)
    end
      end
      <'false'> when 'true' -> case apply 'isLower'/1(C) of
      <'true'> when 'true' -> let <_Let0> = apply 'consumeIdent'/2(State, #{}#)
      in case _Let0 of
        <{'Tuple', Name, State_}> when 'true' -> call 'Data.Tuple':'Tuple'(call 'Nova.Compiler.Cst':'TokLowerName'({'Just', Prefix}, Name), State_)
      end
      <'false'> when 'true' -> case apply 'isOperatorChar'/1(C) of
      <'true'> when 'true' -> let <_Let0> = apply 'consumeOperator'/2(State, #{}#)
      in case _Let0 of
        <{'Tuple', Op, State_}> when 'true' -> call 'Data.Tuple':'Tuple'(call 'Nova.Compiler.Cst':'TokOperator'({'Just', Prefix}, Op), State_)
      end
      <'false'> when 'true' -> call 'Data.Tuple':'Tuple'(call 'Nova.Compiler.Cst':'TokUpperName'('Nothing', Prefix), State)
    end
    end
    end
      <_W0> when 'true' ->
        call 'Data.Tuple':'Tuple'(call 'Nova.Compiler.Cst':'TokUpperName'('Nothing', Prefix), State)
    end

'consumeIdent'/2 =
  fun (State, Acc) ->
    case apply 'peek'/1(State) of
      <{'Just', C}> when 'true' ->
        case apply 'isIdentChar'/1(C) of
      <'true'> when 'true' -> apply 'consumeIdent'/2(apply 'advance'/2(State, 1), call 'Nova.Prelude':'semigroupAppendImpl'(Acc, call 'Data.String.CodeUnits':'singleton'(C)))
      <'false'> when 'true' -> call 'Data.Tuple':'Tuple'(Acc, State)
    end
      <_W0> when 'true' ->
        call 'Data.Tuple':'Tuple'(Acc, State)
    end

'consumeUpperIdent'/2 =
  fun (State, Acc) ->
    case apply 'peek'/1(State) of
      <{'Just', C}> when 'true' ->
        case case apply 'isAlphaNum'/1(C) of <'true'> when 'true' -> 'true' <_> when 'true' -> call 'erlang':'=:='(C, $_) end of
      <'true'> when 'true' -> apply 'consumeUpperIdent'/2(apply 'advance'/2(State, 1), call 'Nova.Prelude':'semigroupAppendImpl'(Acc, call 'Data.String.CodeUnits':'singleton'(C)))
      <'false'> when 'true' -> call 'Data.Tuple':'Tuple'(Acc, State)
    end
      <_W0> when 'true' ->
        call 'Data.Tuple':'Tuple'(Acc, State)
    end

'lexOperator'/1 =
  fun (State) ->
    let <StartState> = State
      in let <_Let0> = apply 'consumeOperator'/2(State, #{}#)
      in case _Let0 of
        <{'Tuple', Op, State_}> when 'true' -> let <Tok> = case Op of
      <#{#<58>(8,1,'integer',['unsigned'|['big']]),#<58>(8,1,'integer',['unsigned'|['big']])}#> when 'true' ->
        call 'Nova.Compiler.Cst':'TokDoubleColon'()
      <#{#<61>(8,1,'integer',['unsigned'|['big']])}#> when 'true' ->
        call 'Nova.Compiler.Cst':'TokEquals'()
      <#{#<124>(8,1,'integer',['unsigned'|['big']])}#> when 'true' ->
        call 'Nova.Compiler.Cst':'TokPipe'()
      <#{#<46>(8,1,'integer',['unsigned'|['big']])}#> when 'true' ->
        call 'Nova.Compiler.Cst':'TokDot'()
      <#{#<92>(8,1,'integer',['unsigned'|['big']])}#> when 'true' ->
        call 'Nova.Compiler.Cst':'TokBackslash'()
      <#{#<45>(8,1,'integer',['unsigned'|['big']]),#<62>(8,1,'integer',['unsigned'|['big']])}#> when 'true' ->
        call 'Nova.Compiler.Cst':'TokRightArrow'()
      <#{#<60>(8,1,'integer',['unsigned'|['big']]),#<45>(8,1,'integer',['unsigned'|['big']])}#> when 'true' ->
        call 'Nova.Compiler.Cst':'TokLeftArrow'()
      <#{#<61>(8,1,'integer',['unsigned'|['big']]),#<62>(8,1,'integer',['unsigned'|['big']])}#> when 'true' ->
        call 'Nova.Compiler.Cst':'TokRightFatArrow'()
      <#{#<64>(8,1,'integer',['unsigned'|['big']])}#> when 'true' ->
        call 'Nova.Compiler.Cst':'TokAt'()
      <_W0> when 'true' ->
        call 'Nova.Compiler.Cst':'TokOperator'('Nothing', Op)
    end
      in {'Just', call 'Data.Tuple':'Tuple'(apply 'makeTokenRange'/3(Tok, StartState, State_), State_)}
      end

'consumeOperator'/2 =
  fun (State, Acc) ->
    case apply 'peek'/1(State) of
      <{'Just', C}> when 'true' ->
        case apply 'isOperatorChar'/1(C) of
      <'true'> when 'true' -> apply 'consumeOperator'/2(apply 'advance'/2(State, 1), call 'Nova.Prelude':'semigroupAppendImpl'(Acc, call 'Data.String.CodeUnits':'singleton'(C)))
      <'false'> when 'true' -> call 'Data.Tuple':'Tuple'(Acc, State)
    end
      <_W0> when 'true' ->
        call 'Data.Tuple':'Tuple'(Acc, State)
    end

'lexDelimiter'/1 =
  fun (State) ->
    case apply 'peek'/1(State) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Left', _Err}> when 'true' ->
        {'Left', _Err}
      <{'Just', C}> when 'true' ->
        let <Tok> = case C of
      <$(> when 'true' ->
        call 'Nova.Compiler.Cst':'TokLeftParen'()
      <$)> when 'true' ->
        call 'Nova.Compiler.Cst':'TokRightParen'()
      <$[> when 'true' ->
        call 'Nova.Compiler.Cst':'TokLeftSquare'()
      <$]> when 'true' ->
        call 'Nova.Compiler.Cst':'TokRightSquare'()
      <${> when 'true' ->
        call 'Nova.Compiler.Cst':'TokLeftBrace'()
      <$}> when 'true' ->
        call 'Nova.Compiler.Cst':'TokRightBrace'()
      <$,> when 'true' ->
        call 'Nova.Compiler.Cst':'TokComma'()
      <$`> when 'true' ->
        call 'Nova.Compiler.Cst':'TokTick'()
      <$;> when 'true' ->
        call 'Nova.Compiler.Cst':'TokComma'()
      <_W0> when 'true' ->
        call 'Nova.Compiler.Cst':'TokComma'()
    end
      in {'Just', call 'Data.Tuple':'Tuple'(apply 'makeToken'/2(Tok, State), apply 'advance'/2(State, 1))}
      <{'Right', C}> when 'true' ->
        let <Tok> = case C of
      <$(> when 'true' ->
        call 'Nova.Compiler.Cst':'TokLeftParen'()
      <$)> when 'true' ->
        call 'Nova.Compiler.Cst':'TokRightParen'()
      <$[> when 'true' ->
        call 'Nova.Compiler.Cst':'TokLeftSquare'()
      <$]> when 'true' ->
        call 'Nova.Compiler.Cst':'TokRightSquare'()
      <${> when 'true' ->
        call 'Nova.Compiler.Cst':'TokLeftBrace'()
      <$}> when 'true' ->
        call 'Nova.Compiler.Cst':'TokRightBrace'()
      <$,> when 'true' ->
        call 'Nova.Compiler.Cst':'TokComma'()
      <$`> when 'true' ->
        call 'Nova.Compiler.Cst':'TokTick'()
      <$;> when 'true' ->
        call 'Nova.Compiler.Cst':'TokComma'()
      <_W0> when 'true' ->
        call 'Nova.Compiler.Cst':'TokComma'()
    end
      in {'Just', call 'Data.Tuple':'Tuple'(apply 'makeToken'/2(Tok, State), apply 'advance'/2(State, 1))}
      end

'lexUnderscore'/1 =
  fun (State) ->
    let <StartState> = State
      in let <State_> = apply 'advance'/2(State, 1)
      in case apply 'peek'/1(State_) of
      <{'Just', C}> when 'true' ->
        case apply 'isIdentChar'/1(C) of
      <'true'> when 'true' -> let <_Let0> = apply 'consumeIdent'/2(State_, #{}#)
      in case _Let0 of
        <{'Tuple', Name, State__}> when 'true' -> {'Just', call 'Data.Tuple':'Tuple'(apply 'makeTokenRange'/3(call 'Nova.Compiler.Cst':'TokHole'(Name), StartState, State__), State__)}
      end
      <'false'> when 'true' -> {'Just', call 'Data.Tuple':'Tuple'(apply 'makeToken'/2(call 'Nova.Compiler.Cst':'TokUnderscore'(), State), State_)}
    end
      <_W0> when 'true' ->
        {'Just', call 'Data.Tuple':'Tuple'(apply 'makeToken'/2(call 'Nova.Compiler.Cst':'TokUnderscore'(), State), State_)}
    end

'lexNumber'/1 =
  fun (State) ->
    letrec 'makeIntResult'/3 = fun (IntPart, StartState, EndState) ->
      let <IntVal> = call 'Nova.Compiler.Cst':'SmallInt'(call 'Data.Maybe':'fromMaybe'(0, call 'Data.Int':'fromString'(IntPart)))
      in {'Just', call 'Data.Tuple':'Tuple'(apply 'makeTokenRange'/3(call 'Nova.Compiler.Cst':'TokInt'(IntPart, IntVal), StartState, EndState), EndState)}
      in let <StartState> = State
      in case apply 'consumeNumber'/2(State, #{}#) of
      <{'Tuple', IntPart, AfterInt}> when 'true' ->
        case apply 'peek'/1(AfterInt) of
      <{'Just', $.}> when 'true' ->
        case apply 'peekAt'/2(AfterInt, 1) of
      <{'Just', C}> when 'true' ->
        case apply 'isDigit'/1(C) of
      <'true'> when 'true' -> let <AfterDot> = apply 'advance'/2(AfterInt, 1)
      in case apply 'consumeNumber'/2(AfterDot, #{}#) of
      <{'Tuple', FracPart, AfterFrac}> when 'true' ->
        let <NumStr> = call 'Nova.Prelude':'semigroupAppendImpl'(call 'Nova.Prelude':'semigroupAppendImpl'(IntPart, #{#<46>(8,1,'integer',['unsigned'|['big']])}#), FracPart)
      in case call 'Data.Number':'fromString'(NumStr) of
      <{'Just', N}> when 'true' ->
        {'Just', call 'Data.Tuple':'Tuple'(apply 'makeTokenRange'/3(call 'Nova.Compiler.Cst':'TokNumber'(NumStr, N), StartState, AfterFrac), AfterFrac)}
      <'Nothing'> when 'true' ->
        apply 'makeIntResult'/3(IntPart, StartState, AfterInt)
    end
    end
      <'false'> when 'true' -> apply 'makeIntResult'/3(IntPart, StartState, AfterInt)
    end
      <_W0> when 'true' ->
        apply 'makeIntResult'/3(IntPart, StartState, AfterInt)
    end
      <_W0> when 'true' ->
        apply 'makeIntResult'/3(IntPart, StartState, AfterInt)
    end
    end

'consumeNumber'/2 =
  fun (State, Acc) ->
    case apply 'peek'/1(State) of
      <{'Just', C}> when 'true' ->
        case apply 'isDigit'/1(C) of
      <'true'> when 'true' -> apply 'consumeNumber'/2(apply 'advance'/2(State, 1), call 'Nova.Prelude':'semigroupAppendImpl'(Acc, call 'Data.String.CodeUnits':'singleton'(C)))
      <'false'> when 'true' -> case call 'erlang':'=:='(C, $_) of
      <'true'> when 'true' -> apply 'consumeNumber'/2(apply 'advance'/2(State, 1), Acc)
      <'false'> when 'true' -> call 'Data.Tuple':'Tuple'(Acc, State)
    end
    end
      <_W0> when 'true' ->
        call 'Data.Tuple':'Tuple'(Acc, State)
    end

'lexString'/1 =
  fun (State) ->
    let <StartState> = State
      in let <AfterOpen> = apply 'advance'/2(State, 1)
      in case apply 'consumeString'/2(AfterOpen, #{}#) of
      <{'Tuple', Content, AfterContent}> when 'true' ->
        let <AfterClose> = apply 'advance'/2(AfterContent, 1)
      in {'Just', call 'Data.Tuple':'Tuple'(apply 'makeTokenRange'/3(call 'Nova.Compiler.Cst':'TokString'(Content, Content), StartState, AfterClose), AfterClose)}
    end

'consumeString'/2 =
  fun (State, Acc) ->
    case apply 'peek'/1(State) of
      <'Nothing'> when 'true' ->
        call 'Data.Tuple':'Tuple'(Acc, State)
      <{'Just', $"}> when 'true' ->
        call 'Data.Tuple':'Tuple'(Acc, State)
      <{'Just', $\\}> when 'true' ->
        case apply 'peekAt'/2(State, 1) of
      <{'Just', $n}> when 'true' ->
        apply 'consumeString'/2(apply 'advance'/2(State, 2), call 'Nova.Prelude':'semigroupAppendImpl'(Acc, #{#<10>(8,1,'integer',['unsigned'|['big']])}#))
      <{'Just', $t}> when 'true' ->
        apply 'consumeString'/2(apply 'advance'/2(State, 2), call 'Nova.Prelude':'semigroupAppendImpl'(Acc, #{#<9>(8,1,'integer',['unsigned'|['big']])}#))
      <{'Just', $r}> when 'true' ->
        apply 'consumeString'/2(apply 'advance'/2(State, 2), call 'Nova.Prelude':'semigroupAppendImpl'(Acc, #{#<13>(8,1,'integer',['unsigned'|['big']])}#))
      <{'Just', $"}> when 'true' ->
        apply 'consumeString'/2(apply 'advance'/2(State, 2), call 'Nova.Prelude':'semigroupAppendImpl'(Acc, #{#<34>(8,1,'integer',['unsigned'|['big']])}#))
      <{'Just', $\\}> when 'true' ->
        apply 'consumeString'/2(apply 'advance'/2(State, 2), call 'Nova.Prelude':'semigroupAppendImpl'(Acc, #{#<92>(8,1,'integer',['unsigned'|['big']])}#))
      <{'Just', C}> when 'true' ->
        apply 'consumeString'/2(apply 'advance'/2(State, 2), call 'Nova.Prelude':'semigroupAppendImpl'(Acc, call 'Data.String.CodeUnits':'singleton'(C)))
      <'Nothing'> when 'true' ->
        call 'Data.Tuple':'Tuple'(Acc, State)
    end
      <{'Just', $\n}> when 'true' ->
        call 'Data.Tuple':'Tuple'(Acc, State)
      <{'Just', C}> when 'true' ->
        apply 'consumeString'/2(apply 'advance'/2(State, 1), call 'Nova.Prelude':'semigroupAppendImpl'(Acc, call 'Data.String.CodeUnits':'singleton'(C)))
    end

'lexRawString'/1 =
  fun (State) ->
    let <StartState> = State
      in let <AfterOpen> = apply 'advance'/2(State, 3)
      in case apply 'consumeRawString'/2(AfterOpen, #{}#) of
      <{'Tuple', Content, AfterContent}> when 'true' ->
        let <AfterClose> = apply 'advance'/2(AfterContent, 3)
      in {'Just', call 'Data.Tuple':'Tuple'(apply 'makeTokenRange'/3(call 'Nova.Compiler.Cst':'TokRawString'(Content), StartState, AfterClose), AfterClose)}
    end

'consumeRawString'/2 =
  fun (State, Acc) ->
    case apply 'peek'/1(State) of
      <'Nothing'> when 'true' ->
        call 'Data.Tuple':'Tuple'(Acc, State)
      <{'Just', $"}> when 'true' ->
        case apply 'peekAt'/2(State, 1) of
      <{'Just', $"}> when 'true' ->
        case apply 'peekAt'/2(State, 2) of
      <{'Just', $"}> when 'true' ->
        call 'Data.Tuple':'Tuple'(Acc, State)
      <_W0> when 'true' ->
        apply 'consumeRawString'/2(apply 'advance'/2(State, 1), call 'Nova.Prelude':'semigroupAppendImpl'(Acc, #{#<34>(8,1,'integer',['unsigned'|['big']])}#))
    end
      <_W0> when 'true' ->
        apply 'consumeRawString'/2(apply 'advance'/2(State, 1), call 'Nova.Prelude':'semigroupAppendImpl'(Acc, #{#<34>(8,1,'integer',['unsigned'|['big']])}#))
    end
      <{'Just', $\n}> when 'true' ->
        let <State_> = apply 'advanceNewline'/1(apply 'advance'/2(State, 1))
      in apply 'consumeRawString'/2(State_, call 'Nova.Prelude':'semigroupAppendImpl'(Acc, #{#<10>(8,1,'integer',['unsigned'|['big']])}#))
      <{'Just', C}> when 'true' ->
        apply 'consumeRawString'/2(apply 'advance'/2(State, 1), call 'Nova.Prelude':'semigroupAppendImpl'(Acc, call 'Data.String.CodeUnits':'singleton'(C)))
    end

'lexChar'/1 =
  fun (State) ->
    letrec 'parseCharContent'/1 = fun (S) ->
      case apply 'peek'/1(S) of
      <{'Just', $\\}> when 'true' ->
        case apply 'peekAt'/2(S, 1) of
      <{'Just', $n}> when 'true' ->
        call 'Data.Tuple':'Tuple'($\n, apply 'advance'/2(S, 2))
      <{'Just', $t}> when 'true' ->
        call 'Data.Tuple':'Tuple'($\t, apply 'advance'/2(S, 2))
      <{'Just', $r}> when 'true' ->
        call 'Data.Tuple':'Tuple'($\r, apply 'advance'/2(S, 2))
      <{'Just', $'}> when 'true' ->
        call 'Data.Tuple':'Tuple'($', apply 'advance'/2(S, 2))
      <{'Just', $\\}> when 'true' ->
        call 'Data.Tuple':'Tuple'($\\, apply 'advance'/2(S, 2))
      <{'Just', C}> when 'true' ->
        call 'Data.Tuple':'Tuple'(C, apply 'advance'/2(S, 2))
      <'Nothing'> when 'true' ->
        call 'Data.Tuple':'Tuple'($?, S)
    end
      <{'Just', C}> when 'true' ->
        call 'Data.Tuple':'Tuple'(C, apply 'advance'/2(S, 1))
      <'Nothing'> when 'true' ->
        call 'Data.Tuple':'Tuple'($?, S)
    end
      in let <StartState> = State
      in let <AfterOpen> = apply 'advance'/2(State, 1)
      in case apply 'parseCharContent'/1(AfterOpen) of
      <{'Tuple', Ch, AfterChar}> when 'true' ->
        let <AfterClose> = apply 'advance'/2(AfterChar, 1)
      in {'Just', call 'Data.Tuple':'Tuple'(apply 'makeTokenRange'/3(call 'Nova.Compiler.Cst':'TokChar'(call 'Data.String.CodeUnits':'singleton'(Ch), Ch), StartState, AfterClose), AfterClose)}
    end

'skipLineComment'/1 =
  fun (State) ->
    case apply 'peek'/1(State) of
      <'Nothing'> when 'true' ->
        State
      <{'Just', $\n}> when 'true' ->
        State
      <{'Just', $\r}> when 'true' ->
        State
      <{'Just', _W0}> when 'true' ->
        apply 'skipLineComment'/1(apply 'advance'/2(State, 1))
    end

'skipBlockComment'/2 =
  fun (_P0, _P1) ->
    case {_P0, _P1} of
      <{State, 0}> when 'true' ->
        State
      <{State, Depth}> when 'true' ->
        case apply 'peek'/1(State) of
      <'Nothing'> when 'true' ->
        State
      <{'Just', ${}> when 'true' ->
        case apply 'peekAt'/2(State, 1) of
      <{'Just', $-}> when 'true' ->
        apply 'skipBlockComment'/2(apply 'advance'/2(State, 2), call 'erlang':'+'(Depth, 1))
      <_W0> when 'true' ->
        apply 'skipBlockComment'/2(apply 'advance'/2(State, 1), Depth)
    end
      <{'Just', $-}> when 'true' ->
        case apply 'peekAt'/2(State, 1) of
      <{'Just', $}}> when 'true' ->
        apply 'skipBlockComment'/2(apply 'advance'/2(State, 2), call 'erlang':'-'(Depth, 1))
      <_W0> when 'true' ->
        apply 'skipBlockComment'/2(apply 'advance'/2(State, 1), Depth)
    end
      <{'Just', $\n}> when 'true' ->
        apply 'skipBlockComment'/2(apply 'advanceNewline'/1(apply 'advance'/2(State, 1)), Depth)
      <{'Just', _W0}> when 'true' ->
        apply 'skipBlockComment'/2(apply 'advance'/2(State, 1), Depth)
    end
    end

'initLexState'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'initLexState'/1(_A0)
      in _F0

'isIndented'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'isIndented'/1(_A0)
      in _F0

'lytToken'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'lytToken'/2(_A0, _A1)
      in _F1
      in _F0

'lytToken'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'lytToken'/2(_A0, _A1)
      in _F0

'closeLayouts'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'closeLayouts'/1(_A0)
      in _F0

'closeLayoutsGo'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'closeLayoutsGo'/2(_A0, _A1)
      in _F1
      in _F0

'closeLayoutsGo'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'closeLayoutsGo'/2(_A0, _A1)
      in _F0

'callInsertLayout'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'callInsertLayout'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'callInsertLayout'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'callInsertLayout'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'callInsertLayout'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'callInsertLayout'/3(_A0, _A1, _A2)
      in _F0

'insertLayoutGo'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'insertLayoutGo'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'insertLayoutGo'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'insertLayoutGo'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'insertLayoutGo'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'insertLayoutGo'/3(_A0, _A1, _A2)
      in _F0

'insertLayoutTokens'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'insertLayoutTokens'/1(_A0)
      in _F0

'lexModule'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'lexModule'/1(_A0)
      in _F0

'lexTokens'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'lexTokens'/1(_A0)
      in _F0

'lexTokensGo'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'lexTokensGo'/2(_A0, _A1)
      in _F1
      in _F0

'lexTokensGo'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'lexTokensGo'/2(_A0, _A1)
      in _F0

'lexToken'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'lexToken'/1(_A0)
      in _F0

'isDigit'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'isDigit'/1(_A0)
      in _F0

'isUpper'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'isUpper'/1(_A0)
      in _F0

'isLower'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'isLower'/1(_A0)
      in _F0

'isAlpha'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'isAlpha'/1(_A0)
      in _F0

'isAlphaNum'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'isAlphaNum'/1(_A0)
      in _F0

'isIdentStart'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'isIdentStart'/1(_A0)
      in _F0

'isIdentChar'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'isIdentChar'/1(_A0)
      in _F0

'isOperatorChar'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'isOperatorChar'/1(_A0)
      in _F0

'peek'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'peek'/1(_A0)
      in _F0

'peekAt'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'peekAt'/2(_A0, _A1)
      in _F1
      in _F0

'peekAt'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'peekAt'/2(_A0, _A1)
      in _F0

'advance'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'advance'/2(_A0, _A1)
      in _F1
      in _F0

'advance'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'advance'/2(_A0, _A1)
      in _F0

'advanceNewline'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'advanceNewline'/1(_A0)
      in _F0

'advanceTab'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'advanceTab'/1(_A0)
      in _F0

'makeToken'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'makeToken'/2(_A0, _A1)
      in _F1
      in _F0

'makeToken'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'makeToken'/2(_A0, _A1)
      in _F0

'makeTokenRange'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'makeTokenRange'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'makeTokenRange'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'makeTokenRange'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'makeTokenRange'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'makeTokenRange'/3(_A0, _A1, _A2)
      in _F0

'lexIdentOrKeyword'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'lexIdentOrKeyword'/1(_A0)
      in _F0

'makeKeywordToken'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'makeKeywordToken'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'makeKeywordToken'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'makeKeywordToken'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'makeKeywordToken'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'makeKeywordToken'/3(_A0, _A1, _A2)
      in _F0

'makeIdentToken'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'makeIdentToken'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'makeIdentToken'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'makeIdentToken'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'makeIdentToken'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'makeIdentToken'/3(_A0, _A1, _A2)
      in _F0

'lexUpperIdentifier'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'lexUpperIdentifier'/1(_A0)
      in _F0

'checkQualifiedChain'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'checkQualifiedChain'/2(_A0, _A1)
      in _F1
      in _F0

'checkQualifiedChain'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'checkQualifiedChain'/2(_A0, _A1)
      in _F0

'consumeIdent'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'consumeIdent'/2(_A0, _A1)
      in _F1
      in _F0

'consumeIdent'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'consumeIdent'/2(_A0, _A1)
      in _F0

'consumeUpperIdent'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'consumeUpperIdent'/2(_A0, _A1)
      in _F1
      in _F0

'consumeUpperIdent'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'consumeUpperIdent'/2(_A0, _A1)
      in _F0

'lexOperator'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'lexOperator'/1(_A0)
      in _F0

'consumeOperator'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'consumeOperator'/2(_A0, _A1)
      in _F1
      in _F0

'consumeOperator'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'consumeOperator'/2(_A0, _A1)
      in _F0

'lexDelimiter'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'lexDelimiter'/1(_A0)
      in _F0

'lexUnderscore'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'lexUnderscore'/1(_A0)
      in _F0

'lexNumber'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'lexNumber'/1(_A0)
      in _F0

'consumeNumber'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'consumeNumber'/2(_A0, _A1)
      in _F1
      in _F0

'consumeNumber'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'consumeNumber'/2(_A0, _A1)
      in _F0

'lexString'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'lexString'/1(_A0)
      in _F0

'consumeString'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'consumeString'/2(_A0, _A1)
      in _F1
      in _F0

'consumeString'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'consumeString'/2(_A0, _A1)
      in _F0

'lexRawString'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'lexRawString'/1(_A0)
      in _F0

'consumeRawString'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'consumeRawString'/2(_A0, _A1)
      in _F1
      in _F0

'consumeRawString'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'consumeRawString'/2(_A0, _A1)
      in _F0

'lexChar'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'lexChar'/1(_A0)
      in _F0

'skipLineComment'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'skipLineComment'/1(_A0)
      in _F0

'skipBlockComment'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'skipBlockComment'/2(_A0, _A1)
      in _F1
      in _F0

'skipBlockComment'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'skipBlockComment'/2(_A0, _A1)
      in _F0

'module_info'/0 = fun () -> call 'erlang':'get_module_info'('Nova.Compiler.CstLexer')

'module_info'/1 = fun (_0) -> call 'erlang':'get_module_info'('Nova.Compiler.CstLexer', _0)
end
