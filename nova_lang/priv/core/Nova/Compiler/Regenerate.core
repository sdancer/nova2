module 'Nova.Compiler.Regenerate' ['defaultConfig'/0, 'showLogs'/0, 'extractImports'/1, 'showLogEntry'/1, 'topologicalSort'/1, 'getModuleName'/2, 'parseAndCheckModule'/2, 'regenerate'/2, 'buildDependencyGraph'/3, 'compileAllModules'/3, 'moduleToPath'/3, 'compileOneModule'/4, 'LogInfo'/1, 'LogWarning'/1, 'LogError'/1, 'extractImports'/0, 'showLogEntry'/0, 'topologicalSort'/0, 'getModuleName'/0, 'getModuleName'/1, 'parseAndCheckModule'/0, 'parseAndCheckModule'/1, 'regenerate'/0, 'regenerate'/1, 'buildDependencyGraph'/0, 'buildDependencyGraph'/1, 'buildDependencyGraph'/2, 'compileAllModules'/0, 'compileAllModules'/1, 'compileAllModules'/2, 'moduleToPath'/0, 'moduleToPath'/1, 'moduleToPath'/2, 'compileOneModule'/0, 'compileOneModule'/1, 'compileOneModule'/2, 'compileOneModule'/3, 'LogInfo'/0, 'LogWarning'/0, 'LogError'/0, 'module_info'/0, 'module_info'/1]
  attributes []
% Data type: LogEntry
% Constructors: LogInfo, LogWarning, LogError

'LogInfo'/1 =
  fun (V0) ->
    {'LogInfo', V0}

'LogWarning'/1 =
  fun (V0) ->
    {'LogWarning', V0}

'LogError'/1 =
  fun (V0) ->
    {'LogError', V0}

'defaultConfig'/0 =
  fun () ->
    ~{'srcBase'=>#{#<115>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<99>(8,1,'integer',['unsigned'|['big']]),#<47>(8,1,'integer',['unsigned'|['big']])}#,'libBase'=>#{#<108>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<98>(8,1,'integer',['unsigned'|['big']]),#<47>(8,1,'integer',['unsigned'|['big']])}#,'outputDir'=>#{#<111>(8,1,'integer',['unsigned'|['big']]),#<117>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']]),#<117>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<47>(8,1,'integer',['unsigned'|['big']])}#,'targetDir'=>#{#<110>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<118>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<95>(8,1,'integer',['unsigned'|['big']]),#<108>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<103>(8,1,'integer',['unsigned'|['big']]),#<47>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<118>(8,1,'integer',['unsigned'|['big']]),#<47>(8,1,'integer',['unsigned'|['big']]),#<99>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<47>(8,1,'integer',['unsigned'|['big']])}#}~

'showLogs'/0 =
  fun () ->
    let <_cor0> = call 'Data.String':'joinWith'(#{#<10>(8,1,'integer',['unsigned'|['big']])}#) in let <_cor1> = call 'lists':'map'(fun (_Mf0) -> apply 'showLogEntry'/1(_Mf0)) in fun (_cor2) -> apply _cor0 (apply _cor1 (_cor2))

'extractImports'/1 =
  fun (Source) ->
    let <Lines> = call 'Data.String':'split'(call 'Data.String':'Pattern'(#{#<10>(8,1,'integer',['unsigned'|['big']])}#), Source)
      in letrec 'extractImport'/1 = fun (Line) ->
      case call 'Data.String':'indexOf'(call 'Data.String':'Pattern'(#{#<105>(8,1,'integer',['unsigned'|['big']]),#<109>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']])}#), Line) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Just', Idx}> when 'true' ->
        let <Rest> = call 'Data.String':'drop'(call 'erlang':'+'(Idx, 0), Line)
      in let <Parts> = call 'Data.String':'split'(call 'Data.String':'Pattern'(#{#<32>(8,1,'integer',['unsigned'|['big']])}#), Rest)
      in case call 'Data.Array':'head'(Parts) of
      <'Nothing'> when 'true' ->
        'Nothing'
      <{'Just', ModName}> when 'true' ->
        let <CleanName> = case call 'Data.String':'indexOf'(call 'Data.String':'Pattern'(#{#<40>(8,1,'integer',['unsigned'|['big']])}#), ModName) of
      <'Nothing'> when 'true' ->
        ModName
      <{'Just', ParenIdx}> when 'true' ->
        call 'Data.String':'take'(ParenIdx, ModName)
    end
      in case call 'Data.String':'null'(CleanName) of
      <'true'> when 'true' -> 'Nothing'
      <'false'> when 'true' -> {'Just', CleanName}
    end
    end
    end
      in call 'Data.Array':'mapMaybe'(fun (_Mf0) -> apply 'extractImport'/1(_Mf0), Lines)

'showLogEntry'/1 =
  fun (_P0) ->
    case {_P0} of
      <{{'LogInfo', Msg}}> when 'true' ->
        call 'Nova.Prelude':'semigroupAppendImpl'(#{#<91>(8,1,'integer',['unsigned'|['big']]),#<73>(8,1,'integer',['unsigned'|['big']]),#<78>(8,1,'integer',['unsigned'|['big']]),#<70>(8,1,'integer',['unsigned'|['big']]),#<79>(8,1,'integer',['unsigned'|['big']]),#<93>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']])}#, Msg)
      <{{'LogWarning', Msg}}> when 'true' ->
        call 'Nova.Prelude':'semigroupAppendImpl'(#{#<91>(8,1,'integer',['unsigned'|['big']]),#<87>(8,1,'integer',['unsigned'|['big']]),#<65>(8,1,'integer',['unsigned'|['big']]),#<82>(8,1,'integer',['unsigned'|['big']]),#<78>(8,1,'integer',['unsigned'|['big']]),#<93>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']])}#, Msg)
      <{{'LogError', Msg}}> when 'true' ->
        call 'Nova.Prelude':'semigroupAppendImpl'(#{#<91>(8,1,'integer',['unsigned'|['big']]),#<69>(8,1,'integer',['unsigned'|['big']]),#<82>(8,1,'integer',['unsigned'|['big']]),#<82>(8,1,'integer',['unsigned'|['big']]),#<79>(8,1,'integer',['unsigned'|['big']]),#<82>(8,1,'integer',['unsigned'|['big']]),#<93>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']])}#, Msg)
    end

'topologicalSort'/1 =
  fun (Graph) ->
    letrec 'go'/4 = fun (Remaining, Visited, Visiting, Acc) ->
      case call 'Data.Array':'uncons'(Remaining) of
      <'Nothing'> when 'true' ->
        Acc
      <{'Just', ~{'head':=Path,'tail':=Rest}~}> when 'true' ->
        case call 'Data.Set':'member'(Path, Visited) of
      <'true'> when 'true' -> apply 'go'/4(Rest, Visited, Visiting, Acc)
      <'false'> when 'true' -> let <Result> = apply 'visit'/4(Path, Visited, Visiting, Acc)
      in apply 'go'/4(Rest, call 'maps':'get'('visited', Result), call 'maps':'get'('visiting', Result), call 'maps':'get'('acc', Result))
    end
    end
       'visit'/4 = fun (Path, Visited, Visiting, Acc) ->
      case call 'Data.Set':'member'(Path, Visited) of
      <'true'> when 'true' -> ~{'visited'=>Visited,'visiting'=>Visiting,'acc'=>Acc}~
      <'false'> when 'true' -> case call 'Data.Set':'member'(Path, Visiting) of
      <'true'> when 'true' -> ~{'visited'=>Visited,'visiting'=>Visiting,'acc'=>Acc}~
      <'false'> when 'true' -> let <Visiting_> = call 'Data.Set':'insert'(Path, Visiting)
      in let <Deps> = case call 'Data.Map':'lookup'(Path, Graph) of
      <{'Just', D}> when 'true' ->
        D
      <'Nothing'> when 'true' ->
        []
    end
      in let <ValidDeps> = call 'Data.Array':'filter'(fun (D) ->
      call 'Data.Map':'member'(D, Graph), Deps)
      in let <Result> = call 'Data.Foldable':'foldl'(fun (R, D) ->
      apply 'visit'/4(D, call 'maps':'get'('visited', R), call 'maps':'get'('visiting', R), call 'maps':'get'('acc', R)), ~{'visited'=>Visited,'visiting'=>Visiting_,'acc'=>Acc}~, ValidDeps)
      in let <Visited_> = call 'Data.Set':'insert'(Path, call 'maps':'get'('visited', Result))
      in let <Visiting__> = call 'Data.Set':'delete'(Path, call 'maps':'get'('visiting', Result))
      in ~{'visited'=>Visited_,'visiting'=>Visiting__,'acc'=>call 'Data.Array':'snoc'(call 'maps':'get'('acc', Result), Path)}~
    end
    end
      in apply 'go'/4(call 'Data.Array':'fromFoldable'(call 'Data.Map':'keys'(Graph)), call 'Data.Set':'empty'(), call 'Data.Set':'empty'(), [])

'getModuleName'/2 =
  fun (Config, Path) ->
    let <BaseLen> = case call 'erlang':'=:='(call 'Data.String':'take'(call 'Data.String':'length'(call 'maps':'get'('libBase', Config)), Path), call 'maps':'get'('libBase', Config)) of
      <'true'> when 'true' -> call 'Data.String':'length'(call 'maps':'get'('libBase', Config))
      <'false'> when 'true' -> case call 'erlang':'=:='(call 'Data.String':'take'(call 'Data.String':'length'(call 'maps':'get'('srcBase', Config)), Path), call 'maps':'get'('srcBase', Config)) of
      <'true'> when 'true' -> call 'Data.String':'length'(call 'maps':'get'('srcBase', Config))
      <'false'> when 'true' -> 0
    end
    end
      in let <Relative> = call 'Data.String':'drop'(BaseLen, Path)
      in let <WithoutExt> = call 'Data.String':'take'(call 'erlang':'-'(call 'Data.String':'length'(Relative), 0), Relative)
      in call 'Data.String':'replaceAll'(call 'Data.String':'Pattern'(#{#<47>(8,1,'integer',['unsigned'|['big']])}#), call 'Data.String':'Replacement'(#{#<46>(8,1,'integer',['unsigned'|['big']])}#), WithoutExt)

'parseAndCheckModule'/2 =
  fun (Registry, Source) ->
    case call 'Nova.Compiler.CstPipeline':'parseModuleCst'(Source) of
      <{'Left', Err}> when 'true' ->
        {'Left', call 'Nova.Prelude':'semigroupAppendImpl'(#{#<80>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<58>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']])}#, Err)}
      <{'Right', Mod}> when 'true' ->
        case call 'Nova.Compiler.TypeChecker':'checkModule'(Registry, call 'Nova.Compiler.Types':'emptyEnv'(), call 'Data.Array':'fromFoldable'(call 'maps':'get'('declarations', Mod))) of
      <{'Left', Err}> when 'true' ->
        {'Left', call 'Nova.Prelude':'semigroupAppendImpl'(#{#<84>(8,1,'integer',['unsigned'|['big']]),#<121>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<58>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']])}#, call 'erlang':'integer_to_list'(Err))}
      <{'Right', Env}> when 'true' ->
        let <ModDeclsArray> = call 'Data.Array':'fromFoldable'(call 'maps':'get'('declarations', Mod))
      in let <Exports> = call 'Nova.Compiler.TypeChecker':'extractExports'(ModDeclsArray)
      in let <ExportsWithValues> = call 'Nova.Compiler.TypeChecker':'addValuesToExports'(Exports, Env, ModDeclsArray)
      in {'Right', ~{'mod'=>Mod,'env'=>Env,'exports'=>ExportsWithValues}~}
    end
    end

'regenerate'/2 =
  fun (Fs, Config) ->
    let <LibFiles> = apply call 'maps':'get'('listFiles', Fs)(call 'maps':'get'('libBase', Config), #{#<46>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']]),#<117>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']])}#)
      in let <SrcFiles> = apply call 'maps':'get'('listFiles', Fs)(call 'maps':'get'('srcBase', Config), #{#<46>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']]),#<117>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']])}#)
      in let <AllFiles> = call 'Nova.Prelude':'semigroupAppendImpl'(LibFiles, SrcFiles)
      in let <CombinedDeps> = apply 'buildDependencyGraph'/3(Fs, Config, AllFiles)
      in let <SortedModules> = apply 'topologicalSort'/1(CombinedDeps)
      in let <_Let0> = apply 'compileAllModules'/3(Fs, Config, SortedModules)
      in case _Let0 of
        <{'Tuple', Count, Logs}> when 'true' -> ~{'success'=>'true','modulesCompiled'=>Count,'logs'=>Logs}~
      end

'buildDependencyGraph'/3 =
  fun (Fs, Config, Files) ->
    call 'Data.Map':'fromFoldable'(call 'lists':'map'(fun (Path) ->
      let <Deps> = case apply call 'maps':'get'('readFile', Fs)(Path) of
      <'Nothing'> when 'true' ->
        []
      <{'Just', Source}> when 'true' ->
        let <Imports> = apply 'extractImports'/1(Source)
      in let <DepPaths> = call 'Data.Array':'mapMaybe'(fun (_Pc0) -> apply 'moduleToPath'/3(Fs, Config, _Pc0), Imports)
      in call 'Data.Array':'filter'(fun (P) ->
      call 'erlang':'=/='(P, Path), DepPaths)
    end
      in call 'Data.Tuple':'Tuple'(Path, Deps), Files))

'compileAllModules'/3 =
  fun (Fs, Config, SortedPaths) ->
    let <Initial> = ~{'registry'=>call 'Nova.Compiler.Types':'registerModule'(call 'Nova.Compiler.Types':'emptyRegistry'(), #{#<80>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<108>(8,1,'integer',['unsigned'|['big']]),#<117>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']])}#, call 'Nova.Compiler.Types':'preludeExports'()),'count'=>0,'logs'=>[]}~
      in let <Result> = call 'Data.Foldable':'foldl'(fun (_Pc0, _Pc1) -> apply 'compileOneModule'/4(Fs, Config, _Pc0, _Pc1), Initial, SortedPaths)
      in call 'Data.Tuple':'Tuple'(call 'maps':'get'('count', Result), call 'maps':'get'('logs', Result))

'moduleToPath'/3 =
  fun (Fs, Config, ModName) ->
    let <RelPath> = call 'Nova.Prelude':'semigroupAppendImpl'(call 'Data.String':'replaceAll'(call 'Data.String':'Pattern'(#{#<46>(8,1,'integer',['unsigned'|['big']])}#), call 'Data.String':'Replacement'(#{#<47>(8,1,'integer',['unsigned'|['big']])}#), ModName), #{#<46>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']]),#<117>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']])}#)
      in let <LibPath> = call 'Nova.Prelude':'semigroupAppendImpl'(call 'maps':'get'('libBase', Config), RelPath)
      in let <SrcPath> = call 'Nova.Prelude':'semigroupAppendImpl'(call 'maps':'get'('srcBase', Config), RelPath)
      in case apply call 'maps':'get'('fileExists', Fs)(LibPath) of
      <'true'> when 'true' -> {'Just', LibPath}
      <'false'> when 'true' -> case apply call 'maps':'get'('fileExists', Fs)(SrcPath) of
      <'true'> when 'true' -> {'Just', SrcPath}
      <'false'> when 'true' -> 'Nothing'
    end
    end

'compileOneModule'/4 =
  fun (Fs, Config, Acc, Path) ->
    case apply call 'maps':'get'('readFile', Fs)(Path) of
      <'Nothing'> when 'true' ->
        call 'maps':'merge'(Acc, ~{'logs'=>call 'Data.Array':'snoc'(call 'maps':'get'('logs', Acc), apply 'LogError'/1(call 'Nova.Prelude':'semigroupAppendImpl'(#{#<67>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<116>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<97>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<58>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']])}#, Path)))}~)
      <{'Just', Source}> when 'true' ->
        let <FullModName> = apply 'getModuleName'/2(Config, Path)
      in case apply 'parseAndCheckModule'/2(call 'maps':'get'('registry', Acc), Source) of
      <{'Left', Err}> when 'true' ->
        call 'maps':'merge'(Acc, ~{'logs'=>call 'Data.Array':'snoc'(call 'maps':'get'('logs', Acc), apply 'LogError'/1(call 'Nova.Prelude':'semigroupAppendImpl'(call 'Nova.Prelude':'semigroupAppendImpl'(FullModName, #{#<58>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']])}#), Err)))}~)
      <{'Right', Result}> when 'true' ->
        case call 'Nova.Compiler.CodeGenCoreErlang':'genModule'(call 'maps':'get'('mod', Result)) of
      <{'Left', CodegenErr}> when 'true' ->
        call 'maps':'merge'(Acc, ~{'logs'=>call 'Data.Array':'snoc'(call 'maps':'get'('logs', Acc), apply 'LogError'/1(call 'Nova.Prelude':'semigroupAppendImpl'(call 'Nova.Prelude':'semigroupAppendImpl'(FullModName, #{#<58>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']])}#), CodegenErr)))}~)
      <{'Right', Code}> when 'true' ->
        let <Registry_> = call 'Nova.Compiler.Types':'registerModule'(call 'maps':'get'('registry', Acc), FullModName, call 'maps':'get'('exports', Result))
      in let <ModPath> = call 'Data.String':'replaceAll'(call 'Data.String':'Pattern'(#{#<46>(8,1,'integer',['unsigned'|['big']])}#), call 'Data.String':'Replacement'(#{#<47>(8,1,'integer',['unsigned'|['big']])}#), FullModName)
      in let <LineCount> = call 'Data.Array':'length'(call 'Data.String':'split'(call 'Data.String':'Pattern'(#{#<10>(8,1,'integer',['unsigned'|['big']])}#), Code))
      in let <OutputFile> = call 'Nova.Prelude':'semigroupAppendImpl'(call 'Nova.Prelude':'semigroupAppendImpl'(call 'maps':'get'('outputDir', Config), ModPath), #{#<46>(8,1,'integer',['unsigned'|['big']]),#<99>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']])}#)
      in let <TargetFile> = call 'Nova.Prelude':'semigroupAppendImpl'(call 'Nova.Prelude':'semigroupAppendImpl'(call 'maps':'get'('targetDir', Config), ModPath), #{#<46>(8,1,'integer',['unsigned'|['big']]),#<99>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<114>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']])}#)
      in let <LogMsg> = call 'Nova.Prelude':'semigroupAppendImpl'(call 'Nova.Prelude':'semigroupAppendImpl'(call 'Nova.Prelude':'semigroupAppendImpl'(call 'Nova.Prelude':'semigroupAppendImpl'(#{#<67>(8,1,'integer',['unsigned'|['big']]),#<111>(8,1,'integer',['unsigned'|['big']]),#<109>(8,1,'integer',['unsigned'|['big']]),#<112>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<108>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<100>(8,1,'integer',['unsigned'|['big']]),#<32>(8,1,'integer',['unsigned'|['big']])}#, FullModName), #{#<32>(8,1,'integer',['unsigned'|['big']]),#<40>(8,1,'integer',['unsigned'|['big']])}#), call 'erlang':'integer_to_list'(LineCount)), #{#<32>(8,1,'integer',['unsigned'|['big']]),#<108>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']]),#<115>(8,1,'integer',['unsigned'|['big']]),#<41>(8,1,'integer',['unsigned'|['big']])}#)
      in let <_W0> = apply call 'maps':'get'('writeFile', Fs)(OutputFile, Code)
      in let <_W0> = apply call 'maps':'get'('writeFile', Fs)(TargetFile, Code)
      in ~{'registry'=>Registry_,'count'=>call 'erlang':'+'(call 'maps':'get'('count', Acc), 0),'logs'=>call 'Data.Array':'snoc'(call 'maps':'get'('logs', Acc), apply 'LogInfo'/1(LogMsg))}~
    end
    end
    end

'extractImports'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'extractImports'/1(_A0)
      in _F0

'showLogEntry'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'showLogEntry'/1(_A0)
      in _F0

'topologicalSort'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'topologicalSort'/1(_A0)
      in _F0

'getModuleName'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'getModuleName'/2(_A0, _A1)
      in _F1
      in _F0

'getModuleName'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'getModuleName'/2(_A0, _A1)
      in _F0

'parseAndCheckModule'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'parseAndCheckModule'/2(_A0, _A1)
      in _F1
      in _F0

'parseAndCheckModule'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'parseAndCheckModule'/2(_A0, _A1)
      in _F0

'regenerate'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'regenerate'/2(_A0, _A1)
      in _F1
      in _F0

'regenerate'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'regenerate'/2(_A0, _A1)
      in _F0

'buildDependencyGraph'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'buildDependencyGraph'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'buildDependencyGraph'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'buildDependencyGraph'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'buildDependencyGraph'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'buildDependencyGraph'/3(_A0, _A1, _A2)
      in _F0

'compileAllModules'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'compileAllModules'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'compileAllModules'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'compileAllModules'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'compileAllModules'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'compileAllModules'/3(_A0, _A1, _A2)
      in _F0

'moduleToPath'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'moduleToPath'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'moduleToPath'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'moduleToPath'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'moduleToPath'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'moduleToPath'/3(_A0, _A1, _A2)
      in _F0

'compileOneModule'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        let <_F3> = fun (_A3) ->
        apply 'compileOneModule'/4(_A0, _A1, _A2, _A3)
      in _F3
      in _F2
      in _F1
      in _F0

'compileOneModule'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        let <_F2> = fun (_A3) ->
        apply 'compileOneModule'/4(_A0, _A1, _A2, _A3)
      in _F2
      in _F1
      in _F0

'compileOneModule'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        let <_F1> = fun (_A3) ->
        apply 'compileOneModule'/4(_A0, _A1, _A2, _A3)
      in _F1
      in _F0

'compileOneModule'/3 =
  fun (_A0, _A1, _A2) ->
    let <_F0> = fun (_A3) ->
        apply 'compileOneModule'/4(_A0, _A1, _A2, _A3)
      in _F0

'LogInfo'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'LogInfo'/1(_A0)
      in _F0

'LogWarning'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'LogWarning'/1(_A0)
      in _F0

'LogError'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'LogError'/1(_A0)
      in _F0

'module_info'/0 = fun () -> call 'erlang':'get_module_info'('Nova.Compiler.Regenerate')

'module_info'/1 = fun (_0) -> call 'erlang':'get_module_info'('Nova.Compiler.Regenerate', _0)
end
