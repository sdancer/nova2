module 'Data.List' ['fromFoldable'/1, 'toUnfoldable'/1, 'null'/1, 'uncons'/1, 'head'/1, 'tail'/1, 'reverse'/1, 'length'/1, 'cons'/2, 'singleton'/1, 'append'/2, 'map'/2, 'filter'/2, 'foldr'/3, 'foldl'/3, 'take'/2, 'drop'/2, 'any'/2, 'mapMaybe'/2, 'takeWhile'/2, 'dropWhile'/2, 'range'/2, 'elem'/2, 'fromFoldableImpl'/1, 'toUnfoldableImpl'/1, 'nullImpl'/1, 'unconsImpl'/1, 'headImpl'/1, 'tailImpl'/1, 'reverseImpl'/1, 'lengthImpl'/1, 'consImpl'/2, 'singletonImpl'/1, 'appendImpl'/2, 'mapImpl'/2, 'filterImpl'/2, 'foldrImpl'/3, 'takeImpl'/2, 'dropImpl'/2, 'anyImpl'/2, 'mapMaybeImpl'/2, 'takeWhileImpl'/2, 'dropWhileImpl'/2, 'rangeImpl'/2, 'elemImpl'/2, 'fromFoldable'/0, 'toUnfoldable'/0, 'null'/0, 'uncons'/0, 'head'/0, 'tail'/0, 'reverse'/0, 'length'/0, 'cons'/0, 'cons'/1, 'singleton'/0, 'append'/0, 'append'/1, 'map'/0, 'map'/1, 'filter'/0, 'filter'/1, 'foldr'/0, 'foldr'/1, 'foldr'/2, 'foldl'/0, 'foldl'/1, 'foldl'/2, 'take'/0, 'take'/1, 'drop'/0, 'drop'/1, 'any'/0, 'any'/1, 'mapMaybe'/0, 'mapMaybe'/1, 'takeWhile'/0, 'takeWhile'/1, 'dropWhile'/0, 'dropWhile'/1, 'range'/0, 'range'/1, 'elem'/0, 'elem'/1, 'fromFoldableImpl'/0, 'toUnfoldableImpl'/0, 'nullImpl'/0, 'unconsImpl'/0, 'headImpl'/0, 'tailImpl'/0, 'reverseImpl'/0, 'lengthImpl'/0, 'consImpl'/0, 'consImpl'/1, 'singletonImpl'/0, 'appendImpl'/0, 'appendImpl'/1, 'mapImpl'/0, 'mapImpl'/1, 'filterImpl'/0, 'filterImpl'/1, 'foldrImpl'/0, 'foldrImpl'/1, 'foldrImpl'/2, 'takeImpl'/0, 'takeImpl'/1, 'dropImpl'/0, 'dropImpl'/1, 'anyImpl'/0, 'anyImpl'/1, 'mapMaybeImpl'/0, 'mapMaybeImpl'/1, 'takeWhileImpl'/0, 'takeWhileImpl'/1, 'dropWhileImpl'/0, 'dropWhileImpl'/1, 'rangeImpl'/0, 'rangeImpl'/1, 'elemImpl'/0, 'elemImpl'/1]
  attributes []
'fromFoldable'/1 =
  fun (Xs) ->
    apply 'fromFoldableImpl'/1(Xs)

'toUnfoldable'/1 =
  fun (Xs) ->
    apply 'toUnfoldableImpl'/1(Xs)

'null'/1 =
  fun (Xs) ->
    apply 'nullImpl'/1(Xs)

'uncons'/1 =
  fun (Xs) ->
    apply 'unconsImpl'/1(Xs)

'head'/1 =
  fun (Xs) ->
    apply 'headImpl'/1(Xs)

'tail'/1 =
  fun (Xs) ->
    apply 'tailImpl'/1(Xs)

'reverse'/1 =
  fun (Xs) ->
    apply 'reverseImpl'/1(Xs)

'length'/1 =
  fun (Xs) ->
    apply 'lengthImpl'/1(Xs)

'cons'/2 =
  fun (X, Xs) ->
    apply 'consImpl'/2(X, Xs)

'singleton'/1 =
  fun (X) ->
    apply 'singletonImpl'/1(X)

'append'/2 =
  fun (Xs, Ys) ->
    apply 'appendImpl'/2(Xs, Ys)

'map'/2 =
  fun (F, Xs) ->
    apply 'mapImpl'/2(F, Xs)

'filter'/2 =
  fun (F, Xs) ->
    apply 'filterImpl'/2(F, Xs)

'foldr'/3 =
  fun (F, Acc, Xs) ->
    apply 'foldrImpl'/3(F, Acc, Xs)

'foldl'/3 =
  fun (F, Acc, Xs) ->
    case Xs of
      <[]> when 'true' ->
        Acc
      <[X|Rest]> when 'true' ->
        let <Applied> = apply F(Acc)
      in apply 'foldl'/3(F, apply Applied(X), Rest)
    end

'take'/2 =
  fun (N, Xs) ->
    apply 'takeImpl'/2(N, Xs)

'drop'/2 =
  fun (N, Xs) ->
    apply 'dropImpl'/2(N, Xs)

'any'/2 =
  fun (F, Xs) ->
    apply 'anyImpl'/2(F, Xs)

'mapMaybe'/2 =
  fun (F, Xs) ->
    apply 'mapMaybeImpl'/2(F, Xs)

'takeWhile'/2 =
  fun (F, Xs) ->
    apply 'takeWhileImpl'/2(F, Xs)

'dropWhile'/2 =
  fun (F, Xs) ->
    apply 'dropWhileImpl'/2(F, Xs)

'range'/2 =
  fun (Start, End) ->
    apply 'rangeImpl'/2(Start, End)

'elem'/2 =
  fun (X, Xs) ->
    apply 'elemImpl'/2(X, Xs)

'fromFoldableImpl'/1 = fun (V0) -> V0

'toUnfoldableImpl'/1 = fun (V0) -> V0

'nullImpl'/1 = fun (V0) -> case V0 of
        <[]> when 'true' -> 'true'
        <_> when 'true' -> 'false'
      end

'unconsImpl'/1 = fun (V0) -> case V0 of
        <[]> when 'true' -> 'Nothing'
        <[H|T]> when 'true' -> {'Just', ц遽洄骄痊翎殪Ы驹
      end

'headImpl'/1 = fun (V0) -> case V0 of
        <[]> when 'true' -> 'Nothing'
        <[H|_]> when 'true' -> {'Just', H}
      end

'tailImpl'/1 = fun (V0) -> case V0 of
        <[]> when 'true' -> 'Nothing'
        <[_|T]> when 'true' -> {'Just', T}
      end

'reverseImpl'/1 = fun (V0) -> call 'lists':'reverse'(V0)

'lengthImpl'/1 = fun (V0) -> call 'erlang':'length'(V0)

'consImpl'/2 = fun (V0, V1) -> [V0|V1]

'singletonImpl'/1 = fun (V0) -> [V0]

'appendImpl'/2 = fun (V0, V1) -> call 'lists':'append'(V0, V1)

'mapImpl'/2 = fun (V0, V1) -> call 'lists':'map'(V0, V1)

'filterImpl'/2 = fun (V0, V1) -> call 'lists':'filter'(V0, V1)

'foldrImpl'/3 = fun (V0, V1, V2) -> call 'lists':'foldr'(fun (E, A) -> let <F1> = apply V0 (E) in apply F1 (A), V1, V2)

'takeImpl'/2 = fun (V0, V1) -> call 'lists':'sublist'(V1, V0)

'dropImpl'/2 = fun (V0, V1) -> call 'lists':'nthtail'(V0, V1)

'anyImpl'/2 = fun (V0, V1) -> call 'lists':'any'(V0, V1)

'mapMaybeImpl'/2 = fun (V0, V1) -> call 'lists':'filtermap'(fun (X) -> case apply V0 (X) of
        <'Nothing'> when 'true' -> 'false'
        <{'Just', V}> when 'true' -> {'true', V}
      end, V1)

'takeWhileImpl'/2 = fun (V0, V1) -> call 'lists':'takewhile'(V0, V1)

'dropWhileImpl'/2 = fun (V0, V1) -> call 'lists':'dropwhile'(V0, V1)

'rangeImpl'/2 = fun (V0, V1) -> call 'lists':'seq'(V0, V1)

'elemImpl'/2 = fun (V0, V1) -> call 'lists':'member'(V0, V1)

'fromFoldable'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'fromFoldable'/1(_A0)
      in _F0

'toUnfoldable'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'toUnfoldable'/1(_A0)
      in _F0

'null'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'null'/1(_A0)
      in _F0

'uncons'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'uncons'/1(_A0)
      in _F0

'head'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'head'/1(_A0)
      in _F0

'tail'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'tail'/1(_A0)
      in _F0

'reverse'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'reverse'/1(_A0)
      in _F0

'length'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'length'/1(_A0)
      in _F0

'cons'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'cons'/2(_A0, _A1)
      in _F1
      in _F0

'cons'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'cons'/2(_A0, _A1)
      in _F0

'singleton'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'singleton'/1(_A0)
      in _F0

'append'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'append'/2(_A0, _A1)
      in _F1
      in _F0

'append'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'append'/2(_A0, _A1)
      in _F0

'map'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'map'/2(_A0, _A1)
      in _F1
      in _F0

'map'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'map'/2(_A0, _A1)
      in _F0

'filter'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'filter'/2(_A0, _A1)
      in _F1
      in _F0

'filter'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'filter'/2(_A0, _A1)
      in _F0

'foldr'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'foldr'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'foldr'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'foldr'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'foldr'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'foldr'/3(_A0, _A1, _A2)
      in _F0

'foldl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'foldl'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'foldl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'foldl'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'foldl'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'foldl'/3(_A0, _A1, _A2)
      in _F0

'take'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'take'/2(_A0, _A1)
      in _F1
      in _F0

'take'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'take'/2(_A0, _A1)
      in _F0

'drop'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'drop'/2(_A0, _A1)
      in _F1
      in _F0

'drop'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'drop'/2(_A0, _A1)
      in _F0

'any'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'any'/2(_A0, _A1)
      in _F1
      in _F0

'any'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'any'/2(_A0, _A1)
      in _F0

'mapMaybe'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'mapMaybe'/2(_A0, _A1)
      in _F1
      in _F0

'mapMaybe'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'mapMaybe'/2(_A0, _A1)
      in _F0

'takeWhile'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'takeWhile'/2(_A0, _A1)
      in _F1
      in _F0

'takeWhile'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'takeWhile'/2(_A0, _A1)
      in _F0

'dropWhile'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'dropWhile'/2(_A0, _A1)
      in _F1
      in _F0

'dropWhile'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'dropWhile'/2(_A0, _A1)
      in _F0

'range'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'range'/2(_A0, _A1)
      in _F1
      in _F0

'range'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'range'/2(_A0, _A1)
      in _F0

'elem'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'elem'/2(_A0, _A1)
      in _F1
      in _F0

'elem'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'elem'/2(_A0, _A1)
      in _F0

'fromFoldableImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'fromFoldableImpl'/1(_A0)
      in _F0

'toUnfoldableImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'toUnfoldableImpl'/1(_A0)
      in _F0

'nullImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'nullImpl'/1(_A0)
      in _F0

'unconsImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'unconsImpl'/1(_A0)
      in _F0

'headImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'headImpl'/1(_A0)
      in _F0

'tailImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'tailImpl'/1(_A0)
      in _F0

'reverseImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'reverseImpl'/1(_A0)
      in _F0

'lengthImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'lengthImpl'/1(_A0)
      in _F0

'consImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'consImpl'/2(_A0, _A1)
      in _F1
      in _F0

'consImpl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'consImpl'/2(_A0, _A1)
      in _F0

'singletonImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'singletonImpl'/1(_A0)
      in _F0

'appendImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'appendImpl'/2(_A0, _A1)
      in _F1
      in _F0

'appendImpl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'appendImpl'/2(_A0, _A1)
      in _F0

'mapImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'mapImpl'/2(_A0, _A1)
      in _F1
      in _F0

'mapImpl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'mapImpl'/2(_A0, _A1)
      in _F0

'filterImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'filterImpl'/2(_A0, _A1)
      in _F1
      in _F0

'filterImpl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'filterImpl'/2(_A0, _A1)
      in _F0

'foldrImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'foldrImpl'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'foldrImpl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'foldrImpl'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'foldrImpl'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'foldrImpl'/3(_A0, _A1, _A2)
      in _F0

'takeImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'takeImpl'/2(_A0, _A1)
      in _F1
      in _F0

'takeImpl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'takeImpl'/2(_A0, _A1)
      in _F0

'dropImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'dropImpl'/2(_A0, _A1)
      in _F1
      in _F0

'dropImpl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'dropImpl'/2(_A0, _A1)
      in _F0

'anyImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'anyImpl'/2(_A0, _A1)
      in _F1
      in _F0

'anyImpl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'anyImpl'/2(_A0, _A1)
      in _F0

'mapMaybeImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'mapMaybeImpl'/2(_A0, _A1)
      in _F1
      in _F0

'mapMaybeImpl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'mapMaybeImpl'/2(_A0, _A1)
      in _F0

'takeWhileImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'takeWhileImpl'/2(_A0, _A1)
      in _F1
      in _F0

'takeWhileImpl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'takeWhileImpl'/2(_A0, _A1)
      in _F0

'dropWhileImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'dropWhileImpl'/2(_A0, _A1)
      in _F1
      in _F0

'dropWhileImpl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'dropWhileImpl'/2(_A0, _A1)
      in _F0

'rangeImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'rangeImpl'/2(_A0, _A1)
      in _F1
      in _F0

'rangeImpl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'rangeImpl'/2(_A0, _A1)
      in _F0

'elemImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'elemImpl'/2(_A0, _A1)
      in _F1
      in _F0

'elemImpl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'elemImpl'/2(_A0, _A1)
      in _F0
end
