module 'Data.String.CodeUnits' ['singleton'/1, 'take'/2, 'drop'/2, 'length'/1, 'charAt'/2, 'uncons'/1, 'toCharArray'/1, 'fromCharArray'/1, 'singletonImpl'/1, 'takeImpl'/2, 'dropImpl'/2, 'lengthImpl'/1, 'charAtImpl'/2, 'unconsImpl'/1, 'toCharArrayImpl'/1, 'fromCharArrayImpl'/1, 'singleton'/0, 'take'/0, 'take'/1, 'drop'/0, 'drop'/1, 'length'/0, 'charAt'/0, 'charAt'/1, 'uncons'/0, 'toCharArray'/0, 'fromCharArray'/0, 'singletonImpl'/0, 'takeImpl'/0, 'takeImpl'/1, 'dropImpl'/0, 'dropImpl'/1, 'lengthImpl'/0, 'charAtImpl'/0, 'charAtImpl'/1, 'unconsImpl'/0, 'toCharArrayImpl'/0, 'fromCharArrayImpl'/0, 'module_info'/0, 'module_info'/1]
  attributes []
'singleton'/1 =
  fun (C) ->
    apply 'singletonImpl'/1(C)

'take'/2 =
  fun (N, S) ->
    apply 'takeImpl'/2(N, S)

'drop'/2 =
  fun (N, S) ->
    apply 'dropImpl'/2(N, S)

'length'/1 =
  fun (S) ->
    apply 'lengthImpl'/1(S)

'charAt'/2 =
  fun (I, S) ->
    apply 'charAtImpl'/2(I, S)

'uncons'/1 =
  fun (S) ->
    apply 'unconsImpl'/1(S)

'toCharArray'/1 =
  fun (S) ->
    apply 'toCharArrayImpl'/1(S)

'fromCharArray'/1 =
  fun (Cs) ->
    apply 'fromCharArrayImpl'/1(Cs)

'singletonImpl'/1 = fun (V0) -> call 'unicode':'characters_to_binary'([V0])

'takeImpl'/2 = fun (V0, V1) -> let <Len> = call 'erlang':'byte_size'(V1) in let <N> = case call 'erlang':'>'(V0, Len) of <'true'> when 'true' -> Len <'false'> when 'true' -> V0 end in call 'erlang':'binary_part'(V1, 0, N)

'dropImpl'/2 = fun (V0, V1) -> let <Len> = call 'erlang':'byte_size'(V1) in case call 'erlang':'>='(V0, Len) of <'true'> when 'true' -> #{}# <'false'> when 'true' -> call 'erlang':'binary_part'(V1, V0, call 'erlang':'-'(Len, V0)) end

'lengthImpl'/1 = fun (V0) -> call 'erlang':'byte_size'(V0)

'charAtImpl'/2 = fun (V0, V1) -> let <Len> = call 'erlang':'byte_size'(V1) in case call 'erlang':'and'(call 'erlang':'>='(V0, 0), call 'erlang':'<'(V0, Len)) of <'false'> when 'true' -> 'Nothing' <'true'> when 'true' -> {'Just', call 'erlang':'binary_part'(V1, V0, 1)} end

'unconsImpl'/1 = fun (V0) -> case call 'erlang':'byte_size'(V0) of <0> when 'true' -> 'Nothing' <_> when 'true' -> let <H> = call 'erlang':'binary_part'(V0, 0, 1) in let <T> = call 'erlang':'binary_part'(V0, 1, call 'erlang':'-'(call 'erlang':'byte_size'(V0), 1)) in {'Just', ц遽洄骄痊翎殪Ы驹 end

'toCharArrayImpl'/1 = fun (V0) -> call 'unicode':'characters_to_list'(V0)

'fromCharArrayImpl'/1 = fun (V0) -> call 'unicode':'characters_to_binary'(V0)

'singleton'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'singleton'/1(_A0)
      in _F0

'take'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'take'/2(_A0, _A1)
      in _F1
      in _F0

'take'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'take'/2(_A0, _A1)
      in _F0

'drop'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'drop'/2(_A0, _A1)
      in _F1
      in _F0

'drop'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'drop'/2(_A0, _A1)
      in _F0

'length'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'length'/1(_A0)
      in _F0

'charAt'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'charAt'/2(_A0, _A1)
      in _F1
      in _F0

'charAt'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'charAt'/2(_A0, _A1)
      in _F0

'uncons'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'uncons'/1(_A0)
      in _F0

'toCharArray'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'toCharArray'/1(_A0)
      in _F0

'fromCharArray'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'fromCharArray'/1(_A0)
      in _F0

'singletonImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'singletonImpl'/1(_A0)
      in _F0

'takeImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'takeImpl'/2(_A0, _A1)
      in _F1
      in _F0

'takeImpl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'takeImpl'/2(_A0, _A1)
      in _F0

'dropImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'dropImpl'/2(_A0, _A1)
      in _F1
      in _F0

'dropImpl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'dropImpl'/2(_A0, _A1)
      in _F0

'lengthImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'lengthImpl'/1(_A0)
      in _F0

'charAtImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'charAtImpl'/2(_A0, _A1)
      in _F1
      in _F0

'charAtImpl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'charAtImpl'/2(_A0, _A1)
      in _F0

'unconsImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'unconsImpl'/1(_A0)
      in _F0

'toCharArrayImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'toCharArrayImpl'/1(_A0)
      in _F0

'fromCharArrayImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'fromCharArrayImpl'/1(_A0)
      in _F0

'module_info'/0 = fun () -> call 'erlang':'get_module_info'('Data.String.CodeUnits')

'module_info'/1 = fun (_0) -> call 'erlang':'get_module_info'('Data.String.CodeUnits', _0)
end
