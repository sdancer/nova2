module 'Data.String.CodeUnits' ['singleton'/1, 'take'/2, 'drop'/2, 'length'/1, 'charAt'/2, 'uncons'/1, 'toCharArray'/1, 'fromCharArray'/1, 'singletonImpl'/1, 'takeImpl'/2, 'dropImpl'/2, 'lengthImpl'/1, 'charAtImpl'/2, 'unconsImpl'/1, 'toCharArrayImpl'/1, 'fromCharArrayImpl'/1, 'singleton'/0, 'take'/0, 'take'/1, 'drop'/0, 'drop'/1, 'length'/0, 'charAt'/0, 'charAt'/1, 'uncons'/0, 'toCharArray'/0, 'fromCharArray'/0, 'singletonImpl'/0, 'takeImpl'/0, 'takeImpl'/1, 'dropImpl'/0, 'dropImpl'/1, 'lengthImpl'/0, 'charAtImpl'/0, 'charAtImpl'/1, 'unconsImpl'/0, 'toCharArrayImpl'/0, 'fromCharArrayImpl'/0]
  attributes []
'singleton'/1 =
  fun (C) ->
    apply 'singletonImpl'/1(C)

'take'/2 =
  fun (N, S) ->
    apply 'takeImpl'/2(N, S)

'drop'/2 =
  fun (N, S) ->
    apply 'dropImpl'/2(N, S)

'length'/1 =
  fun (S) ->
    apply 'lengthImpl'/1(S)

'charAt'/2 =
  fun (I, S) ->
    apply 'charAtImpl'/2(I, S)

'uncons'/1 =
  fun (S) ->
    apply 'unconsImpl'/1(S)

'toCharArray'/1 =
  fun (S) ->
    apply 'toCharArrayImpl'/1(S)

'fromCharArray'/1 =
  fun (Cs) ->
    apply 'fromCharArrayImpl'/1(Cs)

'singletonImpl'/1 = fun (V0) -> [V0]

'takeImpl'/2 = fun (V0, V1) -> call 'lists':'sublist'(V1, V0)

'dropImpl'/2 = fun (V0, V1) -> case V0 of
        <0> when 'true' -> V1
        <N> when 'true' -> call 'lists':'nthtail'(N, V1)
      end

'lengthImpl'/1 = fun (V0) -> call 'erlang':'length'(V0)

'charAtImpl'/2 = fun (V0, V1) -> case call 'erlang':'and'(call 'erlang':'>='(V0, 0), call 'erlang':'<'(V0, call 'erlang':'length'(V1))) of
        <'false'> when 'true' -> 'Nothing'
        <'true'> when 'true' -> {'Just', call 'lists':'nth'(call 'erlang':'+'(V0, 1), V1)}
      end

'unconsImpl'/1 = fun (V0) -> case V0 of
        <[]> when 'true' -> 'Nothing'
        <[H|T]> when 'true' -> {'Just', ц遽洄骄痊翎殪Ы驹
      end

'toCharArrayImpl'/1 = fun (V0) -> V0

'fromCharArrayImpl'/1 = fun (V0) -> V0

'singleton'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'singleton'/1(_A0)
      in _F0

'take'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'take'/2(_A0, _A1)
      in _F1
      in _F0

'take'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'take'/2(_A0, _A1)
      in _F0

'drop'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'drop'/2(_A0, _A1)
      in _F1
      in _F0

'drop'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'drop'/2(_A0, _A1)
      in _F0

'length'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'length'/1(_A0)
      in _F0

'charAt'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'charAt'/2(_A0, _A1)
      in _F1
      in _F0

'charAt'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'charAt'/2(_A0, _A1)
      in _F0

'uncons'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'uncons'/1(_A0)
      in _F0

'toCharArray'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'toCharArray'/1(_A0)
      in _F0

'fromCharArray'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'fromCharArray'/1(_A0)
      in _F0

'singletonImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'singletonImpl'/1(_A0)
      in _F0

'takeImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'takeImpl'/2(_A0, _A1)
      in _F1
      in _F0

'takeImpl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'takeImpl'/2(_A0, _A1)
      in _F0

'dropImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'dropImpl'/2(_A0, _A1)
      in _F1
      in _F0

'dropImpl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'dropImpl'/2(_A0, _A1)
      in _F0

'lengthImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'lengthImpl'/1(_A0)
      in _F0

'charAtImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'charAtImpl'/2(_A0, _A1)
      in _F1
      in _F0

'charAtImpl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'charAtImpl'/2(_A0, _A1)
      in _F0

'unconsImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'unconsImpl'/1(_A0)
      in _F0

'toCharArrayImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'toCharArrayImpl'/1(_A0)
      in _F0

'fromCharArrayImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'fromCharArrayImpl'/1(_A0)
      in _F0
end
