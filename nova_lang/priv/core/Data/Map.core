module 'Data.Map' ['empty'/0, 'findMax'/1, 'findMin'/1, 'fromFoldable'/1, 'isEmpty'/1, 'keys'/1, 'size'/1, 'toUnfoldable'/1, 'values'/1, 'delete'/2, 'difference'/2, 'filter'/2, 'filterWithKey'/2, 'intersection'/2, 'lookup'/2, 'map'/2, 'mapMaybe'/2, 'mapWithKey'/2, 'member'/2, 'singleton'/2, 'union'/2, 'alter'/3, 'foldl'/3, 'foldlWithKey'/3, 'foldr'/3, 'insert'/3, 'lookupDefault'/3, 'unionWith'/3, 'update'/3, 'emptyImpl'/0, 'singletonImpl'/2, 'lookupImpl'/2, 'memberImpl'/2, 'insertImpl'/3, 'deleteImpl'/2, 'updateImpl'/3, 'alterImpl'/3, 'keysImpl'/1, 'valuesImpl'/1, 'sizeImpl'/1, 'isEmptyImpl'/1, 'fromFoldableImpl'/1, 'toUnfoldableImpl'/1, 'unionImpl'/2, 'unionWithImpl'/3, 'intersectionImpl'/2, 'differenceImpl'/2, 'mapImpl'/2, 'mapWithKeyImpl'/2, 'filterImpl'/2, 'filterWithKeyImpl'/2, 'foldlImpl'/3, 'foldlWithKeyImpl'/3, 'foldrImpl'/3, 'findMinImpl'/1, 'findMaxImpl'/1, 'lookupDefaultImpl'/3, 'mapMaybeImpl'/2, 'findMax'/0, 'findMin'/0, 'fromFoldable'/0, 'isEmpty'/0, 'keys'/0, 'size'/0, 'toUnfoldable'/0, 'values'/0, 'delete'/0, 'delete'/1, 'difference'/0, 'difference'/1, 'filter'/0, 'filter'/1, 'filterWithKey'/0, 'filterWithKey'/1, 'intersection'/0, 'intersection'/1, 'lookup'/0, 'lookup'/1, 'map'/0, 'map'/1, 'mapMaybe'/0, 'mapMaybe'/1, 'mapWithKey'/0, 'mapWithKey'/1, 'member'/0, 'member'/1, 'singleton'/0, 'singleton'/1, 'union'/0, 'union'/1, 'alter'/0, 'alter'/1, 'alter'/2, 'foldl'/0, 'foldl'/1, 'foldl'/2, 'foldlWithKey'/0, 'foldlWithKey'/1, 'foldlWithKey'/2, 'foldr'/0, 'foldr'/1, 'foldr'/2, 'insert'/0, 'insert'/1, 'insert'/2, 'lookupDefault'/0, 'lookupDefault'/1, 'lookupDefault'/2, 'unionWith'/0, 'unionWith'/1, 'unionWith'/2, 'update'/0, 'update'/1, 'update'/2, 'singletonImpl'/0, 'singletonImpl'/1, 'lookupImpl'/0, 'lookupImpl'/1, 'memberImpl'/0, 'memberImpl'/1, 'insertImpl'/0, 'insertImpl'/1, 'insertImpl'/2, 'deleteImpl'/0, 'deleteImpl'/1, 'updateImpl'/0, 'updateImpl'/1, 'updateImpl'/2, 'alterImpl'/0, 'alterImpl'/1, 'alterImpl'/2, 'keysImpl'/0, 'valuesImpl'/0, 'sizeImpl'/0, 'isEmptyImpl'/0, 'fromFoldableImpl'/0, 'toUnfoldableImpl'/0, 'unionImpl'/0, 'unionImpl'/1, 'unionWithImpl'/0, 'unionWithImpl'/1, 'unionWithImpl'/2, 'intersectionImpl'/0, 'intersectionImpl'/1, 'differenceImpl'/0, 'differenceImpl'/1, 'mapImpl'/0, 'mapImpl'/1, 'mapWithKeyImpl'/0, 'mapWithKeyImpl'/1, 'filterImpl'/0, 'filterImpl'/1, 'filterWithKeyImpl'/0, 'filterWithKeyImpl'/1, 'foldlImpl'/0, 'foldlImpl'/1, 'foldlImpl'/2, 'foldlWithKeyImpl'/0, 'foldlWithKeyImpl'/1, 'foldlWithKeyImpl'/2, 'foldrImpl'/0, 'foldrImpl'/1, 'foldrImpl'/2, 'findMinImpl'/0, 'findMaxImpl'/0, 'lookupDefaultImpl'/0, 'lookupDefaultImpl'/1, 'lookupDefaultImpl'/2, 'mapMaybeImpl'/0, 'mapMaybeImpl'/1, 'module_info'/0, 'module_info'/1]
  attributes []
'empty'/0 =
  fun () ->
    apply 'emptyImpl'/0()

'findMax'/1 =
  fun (M) ->
    apply 'findMaxImpl'/1(M)

'findMin'/1 =
  fun (M) ->
    apply 'findMinImpl'/1(M)

'fromFoldable'/1 =
  fun (Xs) ->
    apply 'fromFoldableImpl'/1(Xs)

'isEmpty'/1 =
  fun (M) ->
    apply 'isEmptyImpl'/1(M)

'keys'/1 =
  fun (M) ->
    apply 'keysImpl'/1(M)

'size'/1 =
  fun (M) ->
    apply 'sizeImpl'/1(M)

'toUnfoldable'/1 =
  fun (M) ->
    apply 'toUnfoldableImpl'/1(M)

'values'/1 =
  fun (M) ->
    apply 'valuesImpl'/1(M)

'delete'/2 =
  fun (K, M) ->
    apply 'deleteImpl'/2(K, M)

'difference'/2 =
  fun (M1, M2) ->
    apply 'differenceImpl'/2(M1, M2)

'filter'/2 =
  fun (F, M) ->
    apply 'filterImpl'/2(F, M)

'filterWithKey'/2 =
  fun (F, M) ->
    apply 'filterWithKeyImpl'/2(F, M)

'intersection'/2 =
  fun (M1, M2) ->
    apply 'intersectionImpl'/2(M1, M2)

'lookup'/2 =
  fun (K, M) ->
    apply 'lookupImpl'/2(K, M)

'map'/2 =
  fun (F, M) ->
    apply 'mapImpl'/2(F, M)

'mapMaybe'/2 =
  fun (F, M) ->
    apply 'mapMaybeImpl'/2(F, M)

'mapWithKey'/2 =
  fun (F, M) ->
    apply 'mapWithKeyImpl'/2(F, M)

'member'/2 =
  fun (K, M) ->
    apply 'memberImpl'/2(K, M)

'singleton'/2 =
  fun (K, V) ->
    apply 'singletonImpl'/2(K, V)

'union'/2 =
  fun (M1, M2) ->
    apply 'unionImpl'/2(M1, M2)

'alter'/3 =
  fun (F, K, M) ->
    apply 'alterImpl'/3(F, K, M)

'foldl'/3 =
  fun (F, Acc, M) ->
    apply 'foldlImpl'/3(F, Acc, M)

'foldlWithKey'/3 =
  fun (F, Acc, M) ->
    apply 'foldlWithKeyImpl'/3(F, Acc, M)

'foldr'/3 =
  fun (F, Acc, M) ->
    apply 'foldrImpl'/3(F, Acc, M)

'insert'/3 =
  fun (K, V, M) ->
    apply 'insertImpl'/3(K, V, M)

'lookupDefault'/3 =
  fun (Def, K, M) ->
    apply 'lookupDefaultImpl'/3(Def, K, M)

'unionWith'/3 =
  fun (F, M1, M2) ->
    apply 'unionWithImpl'/3(F, M1, M2)

'update'/3 =
  fun (F, K, M) ->
    apply 'updateImpl'/3(F, K, M)

'emptyImpl'/0 = fun () -> call 'maps':'new'()

'singletonImpl'/2 = fun (V0, V1) -> call 'maps':'from_list'([{V0, V1}])

'lookupImpl'/2 = fun (V0, V1) -> case call 'maps':'find'(V0, V1) of
        <{'ok', V}> when 'true' -> {'Just', V}
        <'error'> when 'true' -> 'Nothing'
      end

'memberImpl'/2 = fun (V0, V1) -> call 'maps':'is_key'(V0, V1)

'insertImpl'/3 = fun (V0, V1, V2) -> call 'maps':'put'(V0, V1, V2)

'deleteImpl'/2 = fun (V0, V1) -> call 'maps':'remove'(V0, V1)

'updateImpl'/3 = fun (V0, V1, V2) -> case call 'maps':'find'(V1, V2) of
        <'error'> when 'true' -> V2
        <{'ok', V}> when 'true' -> case apply V0 (V) of
          <'Nothing'> when 'true' -> call 'maps':'remove'(V1, V2)
          <{'Just', NewV}> when 'true' -> call 'maps':'put'(V1, NewV, V2)
        end
      end

'alterImpl'/3 = fun (V0, V1, V2) -> let <MaybeV> = case call 'maps':'find'(V1, V2) of
        <'error'> when 'true' -> 'Nothing'
        <{'ok', V}> when 'true' -> {'Just', V}
      end in case apply V0 (MaybeV) of
        <'Nothing'> when 'true' -> call 'maps':'remove'(V1, V2)
        <{'Just', NewV}> when 'true' -> call 'maps':'put'(V1, NewV, V2)
      end

'keysImpl'/1 = fun (V0) -> call 'maps':'keys'(V0)

'valuesImpl'/1 = fun (V0) -> call 'maps':'values'(V0)

'sizeImpl'/1 = fun (V0) -> call 'maps':'size'(V0)

'isEmptyImpl'/1 = fun (V0) -> call 'erlang':'=='(call 'maps':'size'(V0), 0)

'fromFoldableImpl'/1 = fun (V0) -> call 'maps':'from_list'(call 'lists':'map'(fun (_T) -> case _T of <{'Tuple', _K, _V}> when 'true' -> {_K, _V} end, V0))

'toUnfoldableImpl'/1 = fun (V0) -> call 'lists':'map'(fun (_T) -> case _T of <{_K, _V}> when 'true' -> {'Tuple', _K, _V} end, call 'maps':'to_list'(V0))

'unionImpl'/2 = fun (V0, V1) -> call 'maps':'merge'(V1, V0)

'unionWithImpl'/3 = fun (V0, V1, V2) -> call 'maps':'merge'(fun (_K, V1, V2) -> apply V0 (V2, V1), V1, V0)

'intersectionImpl'/2 = fun (V0, V1) -> call 'maps':'with'(call 'maps':'keys'(V1), V0)

'differenceImpl'/2 = fun (V0, V1) -> call 'maps':'without'(call 'maps':'keys'(V1), V0)

'mapImpl'/2 = fun (V0, V1) -> call 'maps':'map'(fun (_K, V) -> apply V0 (V), V1)

'mapWithKeyImpl'/2 = fun (V0, V1) -> call 'maps':'map'(fun (K, V) -> apply V0 (K, V), V1)

'filterImpl'/2 = fun (V0, V1) -> call 'maps':'filter'(fun (_K, V) -> apply V0 (V), V1)

'filterWithKeyImpl'/2 = fun (V0, V1) -> call 'maps':'filter'(fun (K, V) -> apply V0 (K, V), V1)

'foldlImpl'/3 = fun (V0, V1, V2) -> call 'maps':'fold'(fun (_K, V, A) -> apply V0 (A, V), V1, V2)

'foldlWithKeyImpl'/3 = fun (V0, V1, V2) -> call 'maps':'fold'(fun (K, V, A) -> apply V0 (A, K, V), V1, V2)

'foldrImpl'/3 = fun (V0, V1, V2) -> call 'lists':'foldr'(fun (KV, A) -> case KV of <{_K, V}> when 'true' -> apply V0 (V, A) end, V1, call 'maps':'to_list'(V2))

'findMinImpl'/1 = fun (V0) -> case call 'maps':'size'(V0) of
        <0> when 'true' -> 'Nothing'
        <_> when 'true' -> let <Keys> = call 'lists':'sort'(call 'maps':'keys'(V0)) in
          let <K> = call 'erlang':'hd'(Keys) in
            {'Just', {'Tuple', K, call 'maps':'get'(K, V0)}}
      end

'findMaxImpl'/1 = fun (V0) -> case call 'maps':'size'(V0) of
        <0> when 'true' -> 'Nothing'
        <_> when 'true' -> let <Keys> = call 'lists':'sort'(call 'maps':'keys'(V0)) in
          let <K> = call 'lists':'last'(Keys) in
            {'Just', {'Tuple', K, call 'maps':'get'(K, V0)}}
      end

'lookupDefaultImpl'/3 = fun (V0, V1, V2) -> case call 'maps':'find'(V1, V2) of
        <{'ok', V}> when 'true' -> V
        <'error'> when 'true' -> V0
      end

'mapMaybeImpl'/2 = fun (V0, V1) -> call 'maps':'fold'(fun (K, V, Acc) -> case apply V0 (V) of
        <'Nothing'> when 'true' -> Acc
        <{'Just', NewV}> when 'true' -> call 'maps':'put'(K, NewV, Acc)
      end, call 'maps':'new'(), V1)

'findMax'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'findMax'/1(_A0)
      in _F0

'findMin'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'findMin'/1(_A0)
      in _F0

'fromFoldable'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'fromFoldable'/1(_A0)
      in _F0

'isEmpty'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'isEmpty'/1(_A0)
      in _F0

'keys'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'keys'/1(_A0)
      in _F0

'size'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'size'/1(_A0)
      in _F0

'toUnfoldable'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'toUnfoldable'/1(_A0)
      in _F0

'values'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'values'/1(_A0)
      in _F0

'delete'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'delete'/2(_A0, _A1)
      in _F1
      in _F0

'delete'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'delete'/2(_A0, _A1)
      in _F0

'difference'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'difference'/2(_A0, _A1)
      in _F1
      in _F0

'difference'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'difference'/2(_A0, _A1)
      in _F0

'filter'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'filter'/2(_A0, _A1)
      in _F1
      in _F0

'filter'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'filter'/2(_A0, _A1)
      in _F0

'filterWithKey'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'filterWithKey'/2(_A0, _A1)
      in _F1
      in _F0

'filterWithKey'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'filterWithKey'/2(_A0, _A1)
      in _F0

'intersection'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'intersection'/2(_A0, _A1)
      in _F1
      in _F0

'intersection'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'intersection'/2(_A0, _A1)
      in _F0

'lookup'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'lookup'/2(_A0, _A1)
      in _F1
      in _F0

'lookup'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'lookup'/2(_A0, _A1)
      in _F0

'map'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'map'/2(_A0, _A1)
      in _F1
      in _F0

'map'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'map'/2(_A0, _A1)
      in _F0

'mapMaybe'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'mapMaybe'/2(_A0, _A1)
      in _F1
      in _F0

'mapMaybe'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'mapMaybe'/2(_A0, _A1)
      in _F0

'mapWithKey'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'mapWithKey'/2(_A0, _A1)
      in _F1
      in _F0

'mapWithKey'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'mapWithKey'/2(_A0, _A1)
      in _F0

'member'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'member'/2(_A0, _A1)
      in _F1
      in _F0

'member'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'member'/2(_A0, _A1)
      in _F0

'singleton'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'singleton'/2(_A0, _A1)
      in _F1
      in _F0

'singleton'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'singleton'/2(_A0, _A1)
      in _F0

'union'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'union'/2(_A0, _A1)
      in _F1
      in _F0

'union'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'union'/2(_A0, _A1)
      in _F0

'alter'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'alter'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'alter'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'alter'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'alter'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'alter'/3(_A0, _A1, _A2)
      in _F0

'foldl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'foldl'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'foldl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'foldl'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'foldl'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'foldl'/3(_A0, _A1, _A2)
      in _F0

'foldlWithKey'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'foldlWithKey'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'foldlWithKey'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'foldlWithKey'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'foldlWithKey'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'foldlWithKey'/3(_A0, _A1, _A2)
      in _F0

'foldr'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'foldr'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'foldr'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'foldr'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'foldr'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'foldr'/3(_A0, _A1, _A2)
      in _F0

'insert'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'insert'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'insert'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'insert'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'insert'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'insert'/3(_A0, _A1, _A2)
      in _F0

'lookupDefault'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'lookupDefault'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'lookupDefault'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'lookupDefault'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'lookupDefault'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'lookupDefault'/3(_A0, _A1, _A2)
      in _F0

'unionWith'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'unionWith'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'unionWith'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'unionWith'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'unionWith'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'unionWith'/3(_A0, _A1, _A2)
      in _F0

'update'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'update'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'update'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'update'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'update'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'update'/3(_A0, _A1, _A2)
      in _F0

'singletonImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'singletonImpl'/2(_A0, _A1)
      in _F1
      in _F0

'singletonImpl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'singletonImpl'/2(_A0, _A1)
      in _F0

'lookupImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'lookupImpl'/2(_A0, _A1)
      in _F1
      in _F0

'lookupImpl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'lookupImpl'/2(_A0, _A1)
      in _F0

'memberImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'memberImpl'/2(_A0, _A1)
      in _F1
      in _F0

'memberImpl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'memberImpl'/2(_A0, _A1)
      in _F0

'insertImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'insertImpl'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'insertImpl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'insertImpl'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'insertImpl'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'insertImpl'/3(_A0, _A1, _A2)
      in _F0

'deleteImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'deleteImpl'/2(_A0, _A1)
      in _F1
      in _F0

'deleteImpl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'deleteImpl'/2(_A0, _A1)
      in _F0

'updateImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'updateImpl'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'updateImpl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'updateImpl'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'updateImpl'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'updateImpl'/3(_A0, _A1, _A2)
      in _F0

'alterImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'alterImpl'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'alterImpl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'alterImpl'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'alterImpl'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'alterImpl'/3(_A0, _A1, _A2)
      in _F0

'keysImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'keysImpl'/1(_A0)
      in _F0

'valuesImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'valuesImpl'/1(_A0)
      in _F0

'sizeImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'sizeImpl'/1(_A0)
      in _F0

'isEmptyImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'isEmptyImpl'/1(_A0)
      in _F0

'fromFoldableImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'fromFoldableImpl'/1(_A0)
      in _F0

'toUnfoldableImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'toUnfoldableImpl'/1(_A0)
      in _F0

'unionImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'unionImpl'/2(_A0, _A1)
      in _F1
      in _F0

'unionImpl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'unionImpl'/2(_A0, _A1)
      in _F0

'unionWithImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'unionWithImpl'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'unionWithImpl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'unionWithImpl'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'unionWithImpl'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'unionWithImpl'/3(_A0, _A1, _A2)
      in _F0

'intersectionImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'intersectionImpl'/2(_A0, _A1)
      in _F1
      in _F0

'intersectionImpl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'intersectionImpl'/2(_A0, _A1)
      in _F0

'differenceImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'differenceImpl'/2(_A0, _A1)
      in _F1
      in _F0

'differenceImpl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'differenceImpl'/2(_A0, _A1)
      in _F0

'mapImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'mapImpl'/2(_A0, _A1)
      in _F1
      in _F0

'mapImpl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'mapImpl'/2(_A0, _A1)
      in _F0

'mapWithKeyImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'mapWithKeyImpl'/2(_A0, _A1)
      in _F1
      in _F0

'mapWithKeyImpl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'mapWithKeyImpl'/2(_A0, _A1)
      in _F0

'filterImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'filterImpl'/2(_A0, _A1)
      in _F1
      in _F0

'filterImpl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'filterImpl'/2(_A0, _A1)
      in _F0

'filterWithKeyImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'filterWithKeyImpl'/2(_A0, _A1)
      in _F1
      in _F0

'filterWithKeyImpl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'filterWithKeyImpl'/2(_A0, _A1)
      in _F0

'foldlImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'foldlImpl'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'foldlImpl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'foldlImpl'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'foldlImpl'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'foldlImpl'/3(_A0, _A1, _A2)
      in _F0

'foldlWithKeyImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'foldlWithKeyImpl'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'foldlWithKeyImpl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'foldlWithKeyImpl'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'foldlWithKeyImpl'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'foldlWithKeyImpl'/3(_A0, _A1, _A2)
      in _F0

'foldrImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'foldrImpl'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'foldrImpl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'foldrImpl'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'foldrImpl'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'foldrImpl'/3(_A0, _A1, _A2)
      in _F0

'findMinImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'findMinImpl'/1(_A0)
      in _F0

'findMaxImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'findMaxImpl'/1(_A0)
      in _F0

'lookupDefaultImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'lookupDefaultImpl'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'lookupDefaultImpl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'lookupDefaultImpl'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'lookupDefaultImpl'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'lookupDefaultImpl'/3(_A0, _A1, _A2)
      in _F0

'mapMaybeImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'mapMaybeImpl'/2(_A0, _A1)
      in _F1
      in _F0

'mapMaybeImpl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'mapMaybeImpl'/2(_A0, _A1)
      in _F0

'module_info'/0 = fun () -> call 'erlang':'get_module_info'('Data.Map')

'module_info'/1 = fun (_0) -> call 'erlang':'get_module_info'('Data.Map', _0)
end
