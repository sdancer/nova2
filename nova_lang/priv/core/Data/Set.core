module 'Data.Set' ['empty'/0, 'findMax'/1, 'findMin'/1, 'fromFoldable'/1, 'isEmpty'/1, 'singleton'/1, 'size'/1, 'toUnfoldable'/1, 'unions'/1, 'delete'/2, 'difference'/2, 'filter'/2, 'insert'/2, 'intersection'/2, 'map'/2, 'mapMaybe'/2, 'member'/2, 'properSubset'/2, 'subset'/2, 'toggle'/2, 'union'/2, 'foldl'/3, 'foldr'/3, 'emptyImpl'/0, 'singletonImpl'/1, 'memberImpl'/2, 'insertImpl'/2, 'deleteImpl'/2, 'sizeImpl'/1, 'isEmptyImpl'/1, 'fromFoldableImpl'/1, 'toUnfoldableImpl'/1, 'unionImpl'/2, 'intersectionImpl'/2, 'differenceImpl'/2, 'subsetImpl'/2, 'properSubsetImpl'/2, 'mapImpl'/2, 'filterImpl'/2, 'foldlImpl'/3, 'foldrImpl'/3, 'findMinImpl'/1, 'findMaxImpl'/1, 'toggleImpl'/2, 'unionsImpl'/1, 'findMax'/0, 'findMin'/0, 'fromFoldable'/0, 'isEmpty'/0, 'singleton'/0, 'size'/0, 'toUnfoldable'/0, 'unions'/0, 'delete'/0, 'delete'/1, 'difference'/0, 'difference'/1, 'filter'/0, 'filter'/1, 'insert'/0, 'insert'/1, 'intersection'/0, 'intersection'/1, 'map'/0, 'map'/1, 'mapMaybe'/0, 'mapMaybe'/1, 'member'/0, 'member'/1, 'properSubset'/0, 'properSubset'/1, 'subset'/0, 'subset'/1, 'toggle'/0, 'toggle'/1, 'union'/0, 'union'/1, 'foldl'/0, 'foldl'/1, 'foldl'/2, 'foldr'/0, 'foldr'/1, 'foldr'/2, 'singletonImpl'/0, 'memberImpl'/0, 'memberImpl'/1, 'insertImpl'/0, 'insertImpl'/1, 'deleteImpl'/0, 'deleteImpl'/1, 'sizeImpl'/0, 'isEmptyImpl'/0, 'fromFoldableImpl'/0, 'toUnfoldableImpl'/0, 'unionImpl'/0, 'unionImpl'/1, 'intersectionImpl'/0, 'intersectionImpl'/1, 'differenceImpl'/0, 'differenceImpl'/1, 'subsetImpl'/0, 'subsetImpl'/1, 'properSubsetImpl'/0, 'properSubsetImpl'/1, 'mapImpl'/0, 'mapImpl'/1, 'filterImpl'/0, 'filterImpl'/1, 'foldlImpl'/0, 'foldlImpl'/1, 'foldlImpl'/2, 'foldrImpl'/0, 'foldrImpl'/1, 'foldrImpl'/2, 'findMinImpl'/0, 'findMaxImpl'/0, 'toggleImpl'/0, 'toggleImpl'/1, 'unionsImpl'/0, 'module_info'/0, 'module_info'/1]
  attributes []
'empty'/0 =
  fun () ->
    apply 'emptyImpl'/0()

'findMax'/1 =
  fun (S) ->
    apply 'findMaxImpl'/1(S)

'findMin'/1 =
  fun (S) ->
    apply 'findMinImpl'/1(S)

'fromFoldable'/1 =
  fun (Xs) ->
    apply 'fromFoldableImpl'/1(Xs)

'isEmpty'/1 =
  fun (S) ->
    apply 'isEmptyImpl'/1(S)

'singleton'/1 =
  fun (X) ->
    apply 'singletonImpl'/1(X)

'size'/1 =
  fun (S) ->
    apply 'sizeImpl'/1(S)

'toUnfoldable'/1 =
  fun (S) ->
    apply 'toUnfoldableImpl'/1(S)

'unions'/1 =
  fun (Sets) ->
    apply 'unionsImpl'/1(Sets)

'delete'/2 =
  fun (X, S) ->
    apply 'deleteImpl'/2(X, S)

'difference'/2 =
  fun (S1, S2) ->
    apply 'differenceImpl'/2(S1, S2)

'filter'/2 =
  fun (F, S) ->
    apply 'filterImpl'/2(F, S)

'insert'/2 =
  fun (X, S) ->
    apply 'insertImpl'/2(X, S)

'intersection'/2 =
  fun (S1, S2) ->
    apply 'intersectionImpl'/2(S1, S2)

'map'/2 =
  fun (F, S) ->
    apply 'mapImpl'/2(F, S)

'mapMaybe'/2 =
  fun (F, S) ->
    apply 'foldl'/3(fun (Acc, X) ->
      case apply F(X) of
      <{'Just', Y}> when 'true' ->
        apply 'insert'/2(Y, Acc)
      <'Nothing'> when 'true' ->
        Acc
    end, apply 'empty'/0(), S)

'member'/2 =
  fun (X, S) ->
    apply 'memberImpl'/2(X, S)

'properSubset'/2 =
  fun (S1, S2) ->
    apply 'properSubsetImpl'/2(S1, S2)

'subset'/2 =
  fun (S1, S2) ->
    apply 'subsetImpl'/2(S1, S2)

'toggle'/2 =
  fun (X, S) ->
    apply 'toggleImpl'/2(X, S)

'union'/2 =
  fun (S1, S2) ->
    apply 'unionImpl'/2(S1, S2)

'foldl'/3 =
  fun (F, Acc, S) ->
    apply 'foldlImpl'/3(F, Acc, S)

'foldr'/3 =
  fun (F, Acc, S) ->
    apply 'foldrImpl'/3(F, Acc, S)

'emptyImpl'/0 = fun () -> call 'sets':'new'()

'singletonImpl'/1 = fun (V0) -> call 'sets':'from_list'([V0])

'memberImpl'/2 = fun (V0, V1) -> call 'sets':'is_element'(V0, V1)

'insertImpl'/2 = fun (V0, V1) -> call 'sets':'add_element'(V0, V1)

'deleteImpl'/2 = fun (V0, V1) -> call 'sets':'del_element'(V0, V1)

'sizeImpl'/1 = fun (V0) -> call 'sets':'size'(V0)

'isEmptyImpl'/1 = fun (V0) -> call 'erlang':'=='(call 'sets':'size'(V0), 0)

'fromFoldableImpl'/1 = fun (V0) -> call 'sets':'from_list'(V0)

'toUnfoldableImpl'/1 = fun (V0) -> call 'sets':'to_list'(V0)

'unionImpl'/2 = fun (V0, V1) -> call 'sets':'union'(V0, V1)

'intersectionImpl'/2 = fun (V0, V1) -> call 'sets':'intersection'(V0, V1)

'differenceImpl'/2 = fun (V0, V1) -> call 'sets':'subtract'(V0, V1)

'subsetImpl'/2 = fun (V0, V1) -> call 'sets':'is_subset'(V0, V1)

'properSubsetImpl'/2 = fun (V0, V1) -> call 'erlang':'and'(call 'sets':'is_subset'(V0, V1), call 'erlang':'<'(call 'sets':'size'(V0), call 'sets':'size'(V1)))

'mapImpl'/2 = fun (V0, V1) -> call 'sets':'from_list'(call 'lists':'map'(V0, call 'sets':'to_list'(V1)))

'filterImpl'/2 = fun (V0, V1) -> call 'sets':'filter'(V0, V1)

'foldlImpl'/3 = fun (V0, V1, V2) -> call 'sets':'fold'(fun (E, A) -> apply V0 (A, E), V1, V2)

'foldrImpl'/3 = fun (V0, V1, V2) -> call 'lists':'foldr'(fun (E, A) -> apply V0 (E, A), V1, call 'sets':'to_list'(V2))

'findMinImpl'/1 = fun (V0) -> case call 'sets':'size'(V0) of
        <0> when 'true' -> 'Nothing'
        <_> when 'true' -> {'Just', call 'lists':'min'(call 'sets':'to_list'(V0))}
      end

'findMaxImpl'/1 = fun (V0) -> case call 'sets':'size'(V0) of
        <0> when 'true' -> 'Nothing'
        <_> when 'true' -> {'Just', call 'lists':'max'(call 'sets':'to_list'(V0))}
      end

'toggleImpl'/2 = fun (V0, V1) -> case call 'sets':'is_element'(V0, V1) of
        <'true'> when 'true' -> call 'sets':'del_element'(V0, V1)
        <'false'> when 'true' -> call 'sets':'add_element'(V0, V1)
      end

'unionsImpl'/1 = fun (V0) -> call 'lists':'foldl'(fun (S, Acc) -> call 'sets':'union'(S, Acc), call 'sets':'new'(), V0)

'findMax'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'findMax'/1(_A0)
      in _F0

'findMin'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'findMin'/1(_A0)
      in _F0

'fromFoldable'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'fromFoldable'/1(_A0)
      in _F0

'isEmpty'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'isEmpty'/1(_A0)
      in _F0

'singleton'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'singleton'/1(_A0)
      in _F0

'size'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'size'/1(_A0)
      in _F0

'toUnfoldable'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'toUnfoldable'/1(_A0)
      in _F0

'unions'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'unions'/1(_A0)
      in _F0

'delete'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'delete'/2(_A0, _A1)
      in _F1
      in _F0

'delete'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'delete'/2(_A0, _A1)
      in _F0

'difference'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'difference'/2(_A0, _A1)
      in _F1
      in _F0

'difference'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'difference'/2(_A0, _A1)
      in _F0

'filter'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'filter'/2(_A0, _A1)
      in _F1
      in _F0

'filter'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'filter'/2(_A0, _A1)
      in _F0

'insert'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'insert'/2(_A0, _A1)
      in _F1
      in _F0

'insert'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'insert'/2(_A0, _A1)
      in _F0

'intersection'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'intersection'/2(_A0, _A1)
      in _F1
      in _F0

'intersection'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'intersection'/2(_A0, _A1)
      in _F0

'map'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'map'/2(_A0, _A1)
      in _F1
      in _F0

'map'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'map'/2(_A0, _A1)
      in _F0

'mapMaybe'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'mapMaybe'/2(_A0, _A1)
      in _F1
      in _F0

'mapMaybe'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'mapMaybe'/2(_A0, _A1)
      in _F0

'member'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'member'/2(_A0, _A1)
      in _F1
      in _F0

'member'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'member'/2(_A0, _A1)
      in _F0

'properSubset'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'properSubset'/2(_A0, _A1)
      in _F1
      in _F0

'properSubset'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'properSubset'/2(_A0, _A1)
      in _F0

'subset'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'subset'/2(_A0, _A1)
      in _F1
      in _F0

'subset'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'subset'/2(_A0, _A1)
      in _F0

'toggle'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'toggle'/2(_A0, _A1)
      in _F1
      in _F0

'toggle'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'toggle'/2(_A0, _A1)
      in _F0

'union'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'union'/2(_A0, _A1)
      in _F1
      in _F0

'union'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'union'/2(_A0, _A1)
      in _F0

'foldl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'foldl'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'foldl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'foldl'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'foldl'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'foldl'/3(_A0, _A1, _A2)
      in _F0

'foldr'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'foldr'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'foldr'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'foldr'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'foldr'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'foldr'/3(_A0, _A1, _A2)
      in _F0

'singletonImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'singletonImpl'/1(_A0)
      in _F0

'memberImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'memberImpl'/2(_A0, _A1)
      in _F1
      in _F0

'memberImpl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'memberImpl'/2(_A0, _A1)
      in _F0

'insertImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'insertImpl'/2(_A0, _A1)
      in _F1
      in _F0

'insertImpl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'insertImpl'/2(_A0, _A1)
      in _F0

'deleteImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'deleteImpl'/2(_A0, _A1)
      in _F1
      in _F0

'deleteImpl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'deleteImpl'/2(_A0, _A1)
      in _F0

'sizeImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'sizeImpl'/1(_A0)
      in _F0

'isEmptyImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'isEmptyImpl'/1(_A0)
      in _F0

'fromFoldableImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'fromFoldableImpl'/1(_A0)
      in _F0

'toUnfoldableImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'toUnfoldableImpl'/1(_A0)
      in _F0

'unionImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'unionImpl'/2(_A0, _A1)
      in _F1
      in _F0

'unionImpl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'unionImpl'/2(_A0, _A1)
      in _F0

'intersectionImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'intersectionImpl'/2(_A0, _A1)
      in _F1
      in _F0

'intersectionImpl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'intersectionImpl'/2(_A0, _A1)
      in _F0

'differenceImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'differenceImpl'/2(_A0, _A1)
      in _F1
      in _F0

'differenceImpl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'differenceImpl'/2(_A0, _A1)
      in _F0

'subsetImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'subsetImpl'/2(_A0, _A1)
      in _F1
      in _F0

'subsetImpl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'subsetImpl'/2(_A0, _A1)
      in _F0

'properSubsetImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'properSubsetImpl'/2(_A0, _A1)
      in _F1
      in _F0

'properSubsetImpl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'properSubsetImpl'/2(_A0, _A1)
      in _F0

'mapImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'mapImpl'/2(_A0, _A1)
      in _F1
      in _F0

'mapImpl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'mapImpl'/2(_A0, _A1)
      in _F0

'filterImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'filterImpl'/2(_A0, _A1)
      in _F1
      in _F0

'filterImpl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'filterImpl'/2(_A0, _A1)
      in _F0

'foldlImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'foldlImpl'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'foldlImpl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'foldlImpl'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'foldlImpl'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'foldlImpl'/3(_A0, _A1, _A2)
      in _F0

'foldrImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        let <_F2> = fun (_A2) ->
        apply 'foldrImpl'/3(_A0, _A1, _A2)
      in _F2
      in _F1
      in _F0

'foldrImpl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        let <_F1> = fun (_A2) ->
        apply 'foldrImpl'/3(_A0, _A1, _A2)
      in _F1
      in _F0

'foldrImpl'/2 =
  fun (_A0, _A1) ->
    let <_F0> = fun (_A2) ->
        apply 'foldrImpl'/3(_A0, _A1, _A2)
      in _F0

'findMinImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'findMinImpl'/1(_A0)
      in _F0

'findMaxImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'findMaxImpl'/1(_A0)
      in _F0

'toggleImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'toggleImpl'/2(_A0, _A1)
      in _F1
      in _F0

'toggleImpl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'toggleImpl'/2(_A0, _A1)
      in _F0

'unionsImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'unionsImpl'/1(_A0)
      in _F0

'module_info'/0 = fun () -> call 'erlang':'get_module_info'('Data.Set')

'module_info'/1 = fun (_0) -> call 'erlang':'get_module_info'('Data.Set', _0)
end
