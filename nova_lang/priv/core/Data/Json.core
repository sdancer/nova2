module 'Data.Json' ['decode'/1, 'getString'/2, 'encode'/1, 'decodeImpl'/1, 'getStringImpl'/2, 'encodeImpl'/1, 'decode'/0, 'getString'/0, 'getString'/1, 'encode'/0, 'decodeImpl'/0, 'getStringImpl'/0, 'getStringImpl'/1, 'encodeImpl'/0]
  attributes []
'decode'/1 =
  fun (Str) ->
    apply 'decodeImpl'/1(Str)

'getString'/2 =
  fun (Json, Field) ->
    apply 'getStringImpl'/2(Json, Field)

'encode'/1 =
  fun (Val) ->
    apply 'encodeImpl'/1(Val)

'decodeImpl'/1 = fun (V0) -> case catch call 'json':'decode'(V0) of <{'EXIT', _}> when 'true' -> 'Nothing' <V> when call 'erlang':'is_map'(V) -> {'Just', V} <_> when 'true' -> 'Nothing' end

'getStringImpl'/2 = fun (V0, V1) -> case call 'erlang':'is_map'(V0) of <'true'> when 'true' -> case call 'maps':'find'(V1, V0) of <{'ok', V}> when call 'erlang':'is_binary'(V) -> {'Just', V} <_> when 'true' -> 'Nothing' end <_> when 'true' -> 'Nothing' end

'encodeImpl'/1 = fun (V0) -> call 'json':'encode'(V0)

'decode'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'decode'/1(_A0)
      in _F0

'getString'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'getString'/2(_A0, _A1)
      in _F1
      in _F0

'getString'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'getString'/2(_A0, _A1)
      in _F0

'encode'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'encode'/1(_A0)
      in _F0

'decodeImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'decodeImpl'/1(_A0)
      in _F0

'getStringImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'getStringImpl'/2(_A0, _A1)
      in _F1
      in _F0

'getStringImpl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'getStringImpl'/2(_A0, _A1)
      in _F0

'encodeImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'encodeImpl'/1(_A0)
      in _F0
end
