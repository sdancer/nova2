module 'OTP.TCP' ['defaultListenOptions'/0, 'listen'/1, 'accept'/1, 'acceptTimeout'/2, 'recv'/1, 'recvTimeout'/2, 'send'/2, 'close'/1, 'closeListen'/1, 'setOpts'/2, 'controlling_process'/2, 'listenImpl'/1, 'acceptImpl'/1, 'acceptTimeoutImpl'/2, 'recvImpl'/1, 'recvTimeoutImpl'/2, 'sendImpl'/2, 'closeImpl'/1, 'closeListenImpl'/1, 'setOptsImpl'/2, 'controllingProcessImpl'/2, 'listen'/0, 'accept'/0, 'acceptTimeout'/0, 'acceptTimeout'/1, 'recv'/0, 'recvTimeout'/0, 'recvTimeout'/1, 'send'/0, 'send'/1, 'close'/0, 'closeListen'/0, 'setOpts'/0, 'setOpts'/1, 'controlling_process'/0, 'controlling_process'/1, 'listenImpl'/0, 'acceptImpl'/0, 'acceptTimeoutImpl'/0, 'acceptTimeoutImpl'/1, 'recvImpl'/0, 'recvTimeoutImpl'/0, 'recvTimeoutImpl'/1, 'sendImpl'/0, 'sendImpl'/1, 'closeImpl'/0, 'closeListenImpl'/0, 'setOptsImpl'/0, 'setOptsImpl'/1, 'controllingProcessImpl'/0, 'controllingProcessImpl'/1, 'module_info'/0, 'module_info'/1]
  attributes []
'defaultListenOptions'/0 =
  fun () ->
    ~{'port'=>9999,'reuseaddr'=>'true','active'=>'false','packet'=>#{#<108>(8,1,'integer',['unsigned'|['big']]),#<105>(8,1,'integer',['unsigned'|['big']]),#<110>(8,1,'integer',['unsigned'|['big']]),#<101>(8,1,'integer',['unsigned'|['big']])}#}~

'listen'/1 =
  fun (Port) ->
    apply 'listenImpl'/1(Port)

'accept'/1 =
  fun (ListenSocket) ->
    apply 'acceptImpl'/1(ListenSocket)

'acceptTimeout'/2 =
  fun (ListenSocket, Timeout) ->
    apply 'acceptTimeoutImpl'/2(ListenSocket, Timeout)

'recv'/1 =
  fun (Socket) ->
    apply 'recvImpl'/1(Socket)

'recvTimeout'/2 =
  fun (Socket, Timeout) ->
    apply 'recvTimeoutImpl'/2(Socket, Timeout)

'send'/2 =
  fun (Socket, Data_) ->
    apply 'sendImpl'/2(Socket, Data_)

'close'/1 =
  fun (Socket) ->
    apply 'closeImpl'/1(Socket)

'closeListen'/1 =
  fun (Socket) ->
    apply 'closeListenImpl'/1(Socket)

'setOpts'/2 =
  fun (Socket, Active) ->
    apply 'setOptsImpl'/2(Socket, Active)

'controlling_process'/2 =
  fun (Socket, Pid) ->
    apply 'controllingProcessImpl'/2(Socket, Pid)

'listenImpl'/1 = fun (V0) -> case call 'gen_tcp':'listen'(V0, ['binary', {'packet', 'line'}, {'active', 'false'}, {'reuseaddr', 'true'}]) of <{'ok', Socket}> when 'true' -> {'Right', Socket} <{'error', Reason}> when 'true' -> {'Left', call 'erlang':'iolist_to_binary'(call 'io_lib':'format'("~p", [Reason]))} end

'acceptImpl'/1 = fun (V0) -> case call 'gen_tcp':'accept'(V0) of <{'ok', Socket}> when 'true' -> {'Right', Socket} <{'error', Reason}> when 'true' -> {'Left', call 'erlang':'iolist_to_binary'(call 'io_lib':'format'("~p", [Reason]))} end

'acceptTimeoutImpl'/2 = fun (V0, V1) -> case call 'gen_tcp':'accept'(V0, V1) of <{'ok', Socket}> when 'true' -> {'Right', Socket} <{'error', Reason}> when 'true' -> {'Left', call 'erlang':'iolist_to_binary'(call 'io_lib':'format'("~p", [Reason]))} end

'recvImpl'/1 = fun (V0) -> case call 'gen_tcp':'recv'(V0, 0) of <{'ok', Data}> when 'true' -> {'Right', Data} <{'error', Reason}> when 'true' -> {'Left', call 'erlang':'iolist_to_binary'(call 'io_lib':'format'("~p", [Reason]))} end

'recvTimeoutImpl'/2 = fun (V0, V1) -> case call 'gen_tcp':'recv'(V0, 0, V1) of <{'ok', Data}> when 'true' -> {'Right', Data} <{'error', Reason}> when 'true' -> {'Left', call 'erlang':'iolist_to_binary'(call 'io_lib':'format'("~p", [Reason]))} end

'sendImpl'/2 = fun (V0, V1) -> case call 'gen_tcp':'send'(V0, V1) of <'ok'> when 'true' -> {'Right', 'unit'} <{'error', Reason}> when 'true' -> {'Left', call 'erlang':'iolist_to_binary'(call 'io_lib':'format'("~p", [Reason]))} end

'closeImpl'/1 = fun (V0) -> do call 'gen_tcp':'close'(V0) 'unit'

'closeListenImpl'/1 = fun (V0) -> do call 'gen_tcp':'close'(V0) 'unit'

'setOptsImpl'/2 = fun (V0, V1) -> case call 'inet':'setopts'(V0, [{'active', V1}]) of <'ok'> when 'true' -> {'Right', 'unit'} <{'error', Reason}> when 'true' -> {'Left', call 'erlang':'iolist_to_binary'(call 'io_lib':'format'("~p", [Reason]))} end

'controllingProcessImpl'/2 = fun (V0, V1) -> case call 'gen_tcp':'controlling_process'(V0, V1) of <'ok'> when 'true' -> {'Right', 'unit'} <{'error', Reason}> when 'true' -> {'Left', call 'erlang':'iolist_to_binary'(call 'io_lib':'format'("~p", [Reason]))} end

'listen'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'listen'/1(_A0)
      in _F0

'accept'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'accept'/1(_A0)
      in _F0

'acceptTimeout'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'acceptTimeout'/2(_A0, _A1)
      in _F1
      in _F0

'acceptTimeout'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'acceptTimeout'/2(_A0, _A1)
      in _F0

'recv'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'recv'/1(_A0)
      in _F0

'recvTimeout'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'recvTimeout'/2(_A0, _A1)
      in _F1
      in _F0

'recvTimeout'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'recvTimeout'/2(_A0, _A1)
      in _F0

'send'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'send'/2(_A0, _A1)
      in _F1
      in _F0

'send'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'send'/2(_A0, _A1)
      in _F0

'close'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'close'/1(_A0)
      in _F0

'closeListen'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'closeListen'/1(_A0)
      in _F0

'setOpts'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'setOpts'/2(_A0, _A1)
      in _F1
      in _F0

'setOpts'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'setOpts'/2(_A0, _A1)
      in _F0

'controlling_process'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'controlling_process'/2(_A0, _A1)
      in _F1
      in _F0

'controlling_process'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'controlling_process'/2(_A0, _A1)
      in _F0

'listenImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'listenImpl'/1(_A0)
      in _F0

'acceptImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'acceptImpl'/1(_A0)
      in _F0

'acceptTimeoutImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'acceptTimeoutImpl'/2(_A0, _A1)
      in _F1
      in _F0

'acceptTimeoutImpl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'acceptTimeoutImpl'/2(_A0, _A1)
      in _F0

'recvImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'recvImpl'/1(_A0)
      in _F0

'recvTimeoutImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'recvTimeoutImpl'/2(_A0, _A1)
      in _F1
      in _F0

'recvTimeoutImpl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'recvTimeoutImpl'/2(_A0, _A1)
      in _F0

'sendImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'sendImpl'/2(_A0, _A1)
      in _F1
      in _F0

'sendImpl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'sendImpl'/2(_A0, _A1)
      in _F0

'closeImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'closeImpl'/1(_A0)
      in _F0

'closeListenImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'closeListenImpl'/1(_A0)
      in _F0

'setOptsImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'setOptsImpl'/2(_A0, _A1)
      in _F1
      in _F0

'setOptsImpl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'setOptsImpl'/2(_A0, _A1)
      in _F0

'controllingProcessImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'controllingProcessImpl'/2(_A0, _A1)
      in _F1
      in _F0

'controllingProcessImpl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'controllingProcessImpl'/2(_A0, _A1)
      in _F0

'module_info'/0 = fun () -> call 'erlang':'get_module_info'('OTP.TCP')

'module_info'/1 = fun (_0) -> call 'erlang':'get_module_info'('OTP.TCP', _0)
end
