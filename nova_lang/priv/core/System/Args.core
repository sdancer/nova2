module 'System.Args' ['getArgs'/0, 'getProgName'/0, 'defaultArgs'/0, 'parseArgs'/1, 'parseArgsLoop'/2, 'parseInt'/1, 'startsWith'/2, 'getArgsImpl'/0, 'getProgNameImpl'/0, 'parseIntImpl'/1, 'startsWithImpl'/2, 'parseArgs'/0, 'parseArgsLoop'/0, 'parseArgsLoop'/1, 'parseInt'/0, 'startsWith'/0, 'startsWith'/1, 'parseIntImpl'/0, 'startsWithImpl'/0, 'startsWithImpl'/1]
  attributes []
'getArgs'/0 =
  fun () ->
    apply 'getArgsImpl'/0()

'getProgName'/0 =
  fun () ->
    apply 'getProgNameImpl'/0()

'defaultArgs'/0 =
  fun () ->
    ~{'command'=>"compile",'files'=>[],'outputDir'=>".",'deps'=>[],'port'=>9999,'shared'=>'false','help'=>'false','version'=>'false'}~

'parseArgs'/1 =
  fun (Args) ->
    apply 'parseArgsLoop'/2(Args, apply 'defaultArgs'/0())

'parseArgsLoop'/2 =
  fun (Args, Acc) ->
    case call 'Data.Array':'uncons'(Args) of
      <'Nothing'> when 'true' ->
        case case case call 'Data.Array':'null'(call 'maps':'get'('files', Acc)) of <'true'> when 'true' -> call 'erlang':'not'(call 'maps':'get'('help', Acc)) <_> when 'true' -> 'false' end of <'true'> when 'true' -> call 'erlang':'not'(call 'maps':'get'('version', Acc)) <_> when 'true' -> 'false' end of
      <'true'> when 'true' -> {'Right', call 'maps':'merge'(Acc, ~{'help'=>'true'}~)}
      <'false'> when 'true' -> {'Right', Acc}
    end
      <{'Just', ~{'head':=Arg,'tail':=Rest}~}> when 'true' ->
        case Arg of
      <"mcp"> when 'true' ->
        apply 'parseArgsLoop'/2(Rest, call 'maps':'merge'(Acc, ~{'command'=>"mcp"}~))
      <"--help"> when 'true' ->
        {'Right', call 'maps':'merge'(Acc, ~{'help'=>'true'}~)}
      <"-h"> when 'true' ->
        {'Right', call 'maps':'merge'(Acc, ~{'help'=>'true'}~)}
      <"--version"> when 'true' ->
        {'Right', call 'maps':'merge'(Acc, ~{'version'=>'true'}~)}
      <"-v"> when 'true' ->
        {'Right', call 'maps':'merge'(Acc, ~{'version'=>'true'}~)}
      <"--output"> when 'true' ->
        case call 'Data.Array':'head'(Rest) of
      <{'Just', Dir}> when 'true' ->
        apply 'parseArgsLoop'/2(call 'Data.Array':'drop'(1, Rest), call 'maps':'merge'(Acc, ~{'outputDir'=>Dir}~))
      <'Nothing'> when 'true' ->
        {'Left', "Missing argument for --output"}
    end
      <"-o"> when 'true' ->
        case call 'Data.Array':'head'(Rest) of
      <{'Just', Dir}> when 'true' ->
        apply 'parseArgsLoop'/2(call 'Data.Array':'drop'(1, Rest), call 'maps':'merge'(Acc, ~{'outputDir'=>Dir}~))
      <'Nothing'> when 'true' ->
        {'Left', "Missing argument for -o"}
    end
      <"--dep"> when 'true' ->
        case call 'Data.Array':'head'(Rest) of
      <{'Just', Dep}> when 'true' ->
        apply 'parseArgsLoop'/2(call 'Data.Array':'drop'(1, Rest), call 'maps':'merge'(Acc, ~{'deps'=>call 'Data.Array':'snoc'(call 'maps':'get'('deps', Acc), Dep)}~))
      <'Nothing'> when 'true' ->
        {'Left', "Missing argument for --dep"}
    end
      <"-d"> when 'true' ->
        case call 'Data.Array':'head'(Rest) of
      <{'Just', Dep}> when 'true' ->
        apply 'parseArgsLoop'/2(call 'Data.Array':'drop'(1, Rest), call 'maps':'merge'(Acc, ~{'deps'=>call 'Data.Array':'snoc'(call 'maps':'get'('deps', Acc), Dep)}~))
      <'Nothing'> when 'true' ->
        {'Left', "Missing argument for -d"}
    end
      <"--port"> when 'true' ->
        case call 'Data.Array':'head'(Rest) of
      <{'Just', PortStr}> when 'true' ->
        case apply 'parseInt'/1(PortStr) of
      <{'Just', Port}> when 'true' ->
        apply 'parseArgsLoop'/2(call 'Data.Array':'drop'(1, Rest), call 'maps':'merge'(Acc, ~{'port'=>Port}~))
      <'Nothing'> when 'true' ->
        {'Left', call 'erlang':'++'("Invalid port number: ", PortStr)}
    end
      <'Nothing'> when 'true' ->
        {'Left', "Missing argument for --port"}
    end
      <"-p"> when 'true' ->
        case call 'Data.Array':'head'(Rest) of
      <{'Just', PortStr}> when 'true' ->
        case apply 'parseInt'/1(PortStr) of
      <{'Just', Port}> when 'true' ->
        apply 'parseArgsLoop'/2(call 'Data.Array':'drop'(1, Rest), call 'maps':'merge'(Acc, ~{'port'=>Port}~))
      <'Nothing'> when 'true' ->
        {'Left', call 'erlang':'++'("Invalid port number: ", PortStr)}
    end
      <'Nothing'> when 'true' ->
        {'Left', "Missing argument for -p"}
    end
      <"--shared"> when 'true' ->
        apply 'parseArgsLoop'/2(Rest, call 'maps':'merge'(Acc, ~{'shared'=>'true'}~))
      <"-s"> when 'true' ->
        apply 'parseArgsLoop'/2(Rest, call 'maps':'merge'(Acc, ~{'shared'=>'true'}~))
      <_W0> when 'true' ->
        case apply 'startsWith'/2("-", Arg) of
      <'true'> when 'true' -> {'Left', call 'erlang':'++'("Unknown option: ", Arg)}
      <'false'> when 'true' -> apply 'parseArgsLoop'/2(Rest, call 'maps':'merge'(Acc, ~{'files'=>call 'Data.Array':'snoc'(call 'maps':'get'('files', Acc), Arg)}~))
    end
    end
    end

'parseInt'/1 =
  fun (S) ->
    apply 'parseIntImpl'/1(S)

'startsWith'/2 =
  fun (Prefix, Str) ->
    apply 'startsWithImpl'/2(Prefix, Str)

'getArgsImpl'/0 = fun () -> call 'lists':'map'(fun (A) -> call 'erlang':'list_to_binary'(A), call 'init':'get_plain_arguments'())

'getProgNameImpl'/0 = fun () -> case call 'init':'get_argument'('progname') of <{'ok', [[Name]]}> when 'true' -> call 'erlang':'list_to_binary'(Name) <_> when 'true' -> <<"nova">> end

'parseIntImpl'/1 = fun (V0) -> case catch call 'erlang':'binary_to_integer'(V0) of <N> when call 'erlang':'is_integer'(N) -> {'Just', N} <_> when 'true' -> 'Nothing' end

'startsWithImpl'/2 = fun (V0, V1) -> let <PrefixLen> = call 'erlang':'byte_size'(V0) in let <StrLen> = call 'erlang':'byte_size'(V1) in case call 'erlang':'>='(StrLen, PrefixLen) of <'true'> when 'true' -> call 'erlang':'=:='(call 'erlang':'binary_part'(V1, 0, PrefixLen), V0) <'false'> when 'true' -> 'false' end

'parseArgs'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'parseArgs'/1(_A0)
      in _F0

'parseArgsLoop'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'parseArgsLoop'/2(_A0, _A1)
      in _F1
      in _F0

'parseArgsLoop'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'parseArgsLoop'/2(_A0, _A1)
      in _F0

'parseInt'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'parseInt'/1(_A0)
      in _F0

'startsWith'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'startsWith'/2(_A0, _A1)
      in _F1
      in _F0

'startsWith'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'startsWith'/2(_A0, _A1)
      in _F0

'parseIntImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'parseIntImpl'/1(_A0)
      in _F0

'startsWithImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'startsWithImpl'/2(_A0, _A1)
      in _F1
      in _F0

'startsWithImpl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'startsWithImpl'/2(_A0, _A1)
      in _F0
end
