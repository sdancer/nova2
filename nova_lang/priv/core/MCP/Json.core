module 'MCP.Json' ['encode'/1, 'decode'/1, 'isNull'/1, 'isString'/1, 'isNumber'/1, 'isMap'/1, 'getField'/2, 'jsonStringToString'/1, 'jsonNumberToInt'/1, 'object'/1, 'toJsonString'/1, 'toJsonInt'/1, 'toJsonBool'/1, 'jsonNull'/0, 'toJsonArray'/1, 'kv'/2, 'encodeImpl'/1, 'decodeImpl'/1, 'isNullImpl'/1, 'isStringImpl'/1, 'isNumberImpl'/1, 'isMapImpl'/1, 'getFieldImpl'/2, 'jsonStringToStringImpl'/1, 'jsonNumberToIntImpl'/1, 'objectImpl'/1, 'toJsonStringImpl'/1, 'toJsonIntImpl'/1, 'toJsonBoolImpl'/1, 'jsonNullImpl'/0, 'toJsonArrayImpl'/1, 'encode'/0, 'decode'/0, 'isNull'/0, 'isString'/0, 'isNumber'/0, 'isMap'/0, 'getField'/0, 'getField'/1, 'jsonStringToString'/0, 'jsonNumberToInt'/0, 'object'/0, 'toJsonString'/0, 'toJsonInt'/0, 'toJsonBool'/0, 'toJsonArray'/0, 'kv'/0, 'kv'/1, 'encodeImpl'/0, 'decodeImpl'/0, 'isNullImpl'/0, 'isStringImpl'/0, 'isNumberImpl'/0, 'isMapImpl'/0, 'getFieldImpl'/0, 'getFieldImpl'/1, 'jsonStringToStringImpl'/0, 'jsonNumberToIntImpl'/0, 'objectImpl'/0, 'toJsonStringImpl'/0, 'toJsonIntImpl'/0, 'toJsonBoolImpl'/0, 'toJsonArrayImpl'/0, 'module_info'/0, 'module_info'/1]
  attributes []
'encode'/1 =
  fun (X) ->
    apply 'encodeImpl'/1(X)

'decode'/1 =
  fun (S) ->
    apply 'decodeImpl'/1(S)

'isNull'/1 =
  fun (V) ->
    apply 'isNullImpl'/1(V)

'isString'/1 =
  fun (V) ->
    apply 'isStringImpl'/1(V)

'isNumber'/1 =
  fun (V) ->
    apply 'isNumberImpl'/1(V)

'isMap'/1 =
  fun (V) ->
    apply 'isMapImpl'/1(V)

'getField'/2 =
  fun (K, Obj) ->
    apply 'getFieldImpl'/2(K, Obj)

'jsonStringToString'/1 =
  fun (V) ->
    apply 'jsonStringToStringImpl'/1(V)

'jsonNumberToInt'/1 =
  fun (V) ->
    apply 'jsonNumberToIntImpl'/1(V)

'object'/1 =
  fun (Pairs) ->
    apply 'objectImpl'/1(Pairs)

'toJsonString'/1 =
  fun (S) ->
    apply 'toJsonStringImpl'/1(S)

'toJsonInt'/1 =
  fun (N) ->
    apply 'toJsonIntImpl'/1(N)

'toJsonBool'/1 =
  fun (B) ->
    apply 'toJsonBoolImpl'/1(B)

'jsonNull'/0 =
  fun () ->
    apply 'jsonNullImpl'/0()

'toJsonArray'/1 =
  fun (Arr) ->
    apply 'toJsonArrayImpl'/1(Arr)

'kv'/2 =
  fun (K, V) ->
    ~{'key'=>K,'value'=>V}~

'encodeImpl'/1 = fun (V0) -> call 'erlang':'binary_to_list'(call 'erlang':'iolist_to_binary'(call 'json':'encode'(V0)))

'decodeImpl'/1 = fun (V0) -> case catch call 'json':'decode'(call 'erlang':'list_to_binary'(V0)) of <{'EXIT', _R}> when 'true' -> {'Left', []} <Result> when 'true' -> {'Right', Result} end

'isNullImpl'/1 = fun (V0) -> case V0 of <'null'> when 'true' -> 'true' <_> when 'true' -> 'false' end

'isStringImpl'/1 = fun (V0) -> call 'erlang':'is_binary'(V0)

'isNumberImpl'/1 = fun (V0) -> call 'erlang':'is_number'(V0)

'isMapImpl'/1 = fun (V0) -> call 'erlang':'is_map'(V0)

'getFieldImpl'/2 = fun (V0, V1) -> case call 'maps':'find'(call 'erlang':'list_to_binary'(V0), V1) of <{'ok', Val}> when 'true' -> {'Just', Val} <'error'> when 'true' -> 'Nothing' end

'jsonStringToStringImpl'/1 = fun (V0) -> call 'erlang':'binary_to_list'(V0)

'jsonNumberToIntImpl'/1 = fun (V0) -> call 'erlang':'trunc'(V0)

'objectImpl'/1 = fun (V0) -> let <List> = call 'erlang':'tl'(call 'erlang':'tuple_to_list'(V0)) in let <F> = fun (R) -> let <K> = call 'erlang':'list_to_binary'(call 'maps':'get'('key',R)) in let <V> = call 'maps':'get'('value',R) in {K,V} in call 'maps':'from_list'(call 'lists':'map'(F, List))

'toJsonStringImpl'/1 = fun (V0) -> call 'erlang':'list_to_binary'(V0)

'toJsonIntImpl'/1 = fun (V0) -> V0

'toJsonBoolImpl'/1 = fun (V0) -> V0

'jsonNullImpl'/0 = fun () -> 'null'

'toJsonArrayImpl'/1 = fun (V0) -> call 'erlang':'tl'(call 'erlang':'tuple_to_list'(V0))

'encode'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'encode'/1(_A0)
      in _F0

'decode'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'decode'/1(_A0)
      in _F0

'isNull'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'isNull'/1(_A0)
      in _F0

'isString'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'isString'/1(_A0)
      in _F0

'isNumber'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'isNumber'/1(_A0)
      in _F0

'isMap'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'isMap'/1(_A0)
      in _F0

'getField'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'getField'/2(_A0, _A1)
      in _F1
      in _F0

'getField'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'getField'/2(_A0, _A1)
      in _F0

'jsonStringToString'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'jsonStringToString'/1(_A0)
      in _F0

'jsonNumberToInt'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'jsonNumberToInt'/1(_A0)
      in _F0

'object'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'object'/1(_A0)
      in _F0

'toJsonString'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'toJsonString'/1(_A0)
      in _F0

'toJsonInt'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'toJsonInt'/1(_A0)
      in _F0

'toJsonBool'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'toJsonBool'/1(_A0)
      in _F0

'toJsonArray'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'toJsonArray'/1(_A0)
      in _F0

'kv'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'kv'/2(_A0, _A1)
      in _F1
      in _F0

'kv'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'kv'/2(_A0, _A1)
      in _F0

'encodeImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'encodeImpl'/1(_A0)
      in _F0

'decodeImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'decodeImpl'/1(_A0)
      in _F0

'isNullImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'isNullImpl'/1(_A0)
      in _F0

'isStringImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'isStringImpl'/1(_A0)
      in _F0

'isNumberImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'isNumberImpl'/1(_A0)
      in _F0

'isMapImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'isMapImpl'/1(_A0)
      in _F0

'getFieldImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        let <_F1> = fun (_A1) ->
        apply 'getFieldImpl'/2(_A0, _A1)
      in _F1
      in _F0

'getFieldImpl'/1 =
  fun (_A0) ->
    let <_F0> = fun (_A1) ->
        apply 'getFieldImpl'/2(_A0, _A1)
      in _F0

'jsonStringToStringImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'jsonStringToStringImpl'/1(_A0)
      in _F0

'jsonNumberToIntImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'jsonNumberToIntImpl'/1(_A0)
      in _F0

'objectImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'objectImpl'/1(_A0)
      in _F0

'toJsonStringImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'toJsonStringImpl'/1(_A0)
      in _F0

'toJsonIntImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'toJsonIntImpl'/1(_A0)
      in _F0

'toJsonBoolImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'toJsonBoolImpl'/1(_A0)
      in _F0

'toJsonArrayImpl'/0 =
  fun () ->
    let <_F0> = fun (_A0) ->
        apply 'toJsonArrayImpl'/1(_A0)
      in _F0

'module_info'/0 = fun () -> call 'erlang':'get_module_info'('MCP.Json')

'module_info'/1 = fun (_0) -> call 'erlang':'get_module_info'('MCP.Json', _0)
end
