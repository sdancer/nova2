# This file was auto-generated by the Nova compiler.
# Do not edit this file manually.

defmodule Nova.Compiler.Cst do
  # import Prelude

  # import Data.List

  # import Data.Maybe

  # import Data.Either

  # import Data.Tuple

  # @type source_pos :: %{line: int(), column: int()}

  # @type source_range :: %{start: source_pos(), end_: source_pos()}

  # Data type: SourceStyle
  def ascii(), do: :ascii
  def unicode(), do: :unicode

  # Data type: IntValue
  def small_int(arg0), do: {:small_int, arg0}
  def big_int(arg0), do: {:big_int, arg0}

  # derive instance Eq int_value()

  # Data type: Token
  def tok_left_paren(), do: :tok_left_paren
  def tok_right_paren(), do: :tok_right_paren
  def tok_left_brace(), do: :tok_left_brace
  def tok_right_brace(), do: :tok_right_brace
  def tok_left_square(), do: :tok_left_square
  def tok_right_square(), do: :tok_right_square
  def tok_left_arrow(), do: :tok_left_arrow
  def tok_right_arrow(), do: :tok_right_arrow
  def tok_right_fat_arrow(), do: :tok_right_fat_arrow
  def tok_double_colon(), do: :tok_double_colon
  def tok_forall(), do: :tok_forall
  def tok_equals(), do: :tok_equals
  def tok_pipe(), do: :tok_pipe
  def tok_tick(), do: :tok_tick
  def tok_dot(), do: :tok_dot
  def tok_comma(), do: :tok_comma
  def tok_underscore(), do: :tok_underscore
  def tok_backslash(), do: :tok_backslash
  def tok_at(), do: :tok_at
  def tok_lower_name(arg0, arg1), do: {:tok_lower_name, arg0, arg1}
  def tok_upper_name(arg0, arg1), do: {:tok_upper_name, arg0, arg1}
  def tok_operator(arg0, arg1), do: {:tok_operator, arg0, arg1}
  def tok_symbol_name(arg0, arg1), do: {:tok_symbol_name, arg0, arg1}
  def tok_hole(arg0), do: {:tok_hole, arg0}
  def tok_char(arg0, arg1), do: {:tok_char, arg0, arg1}
  def tok_string(arg0, arg1), do: {:tok_string, arg0, arg1}
  def tok_raw_string(arg0), do: {:tok_raw_string, arg0}
  def tok_int(arg0, arg1), do: {:tok_int, arg0, arg1}
  def tok_number(arg0, arg1), do: {:tok_number, arg0, arg1}
  def tok_layout_start(arg0), do: {:tok_layout_start, arg0}
  def tok_layout_sep(arg0), do: {:tok_layout_sep, arg0}
  def tok_layout_end(arg0), do: {:tok_layout_end, arg0}
  def tok_eof(), do: :tok_eof

  # derive instance Eq token()

  # @type source_token :: %{range: source_range(), leading_comments: list()(string()), trailing_comments: list()(string()), value: token()}

  # Newtype: Ident
  def ident(arg0), do: {:ident, arg0}

  # Newtype: Proper
  def proper(arg0), do: {:proper, arg0}

  # Newtype: Label
  def label(arg0), do: {:label, arg0}

  # Newtype: Operator
  def operator(arg0), do: {:operator, arg0}

  # Newtype: ModuleName
  def module_name(arg0), do: {:module_name, arg0}

  # @type name :: %{token: source_token(), name: a}

  # @type qualified_name :: %{token: source_token(), module: maybe()(module_name()), name: a}

  # @type wrapped :: %{open: source_token(), value: a, close: source_token()}

  # @type separated :: %{head: a, tail: list()((tuple()(source_token())(a)))}

  # @type labeled :: %{label: a, separator: source_token(), value: b}

  # @type delimited :: wrapped()((maybe()((separated()(a)))))

  # @type delimited_non_empty :: wrapped()((separated()(a)))

  # Data type: Type
  def type_var(arg0), do: {:type_var, arg0}
  def type_constructor(arg0), do: {:type_constructor, arg0}
  def type_wildcard(arg0), do: {:type_wildcard, arg0}
  def type_hole(arg0), do: {:type_hole, arg0}
  def type_string(arg0, arg1), do: {:type_string, arg0, arg1}
  def type_int(arg0, arg1), do: {:type_int, arg0, arg1}
  def type_row(arg0), do: {:type_row, arg0}
  def type_record(arg0), do: {:type_record, arg0}
  def type_forall(arg0, arg1, arg2, arg3), do: {:type_forall, arg0, arg1, arg2, arg3}
  def type_kinded(arg0, arg1, arg2), do: {:type_kinded, arg0, arg1, arg2}
  def type_app(arg0, arg1), do: {:type_app, arg0, arg1}
  def type_op(arg0, arg1), do: {:type_op, arg0, arg1}
  def type_arrow(arg0, arg1, arg2), do: {:type_arrow, arg0, arg1, arg2}
  def type_constrained(arg0, arg1, arg2), do: {:type_constrained, arg0, arg1, arg2}
  def type_parens(arg0), do: {:type_parens, arg0}
  def type_error(arg0), do: {:type_error, arg0}

  # Data type: TypeVarBinding
  def type_var_kinded(arg0), do: {:type_var_kinded, arg0}
  def type_var_name(arg0), do: {:type_var_name, arg0}

  # @type row :: %{labels: maybe()((separated()((labeled()((name()(label())))((type()(e))))))), tail: maybe()((tuple()(source_token())((type()(e)))))}

  # @type module :: %{header: module_header()(e), body: module_body()(e)}

  # @type module_header :: %{keyword: source_token(), name: name()(module_name()), exports: maybe()((delimited_non_empty()((export()(e))))), where: source_token(), imports: list()((import_decl()(e)))}

  # @type module_body :: %{decls: list()((declaration()(e))), trailing_comments: list()(string()), end_: source_pos()}

  # Data type: Export
  def export_value(arg0), do: {:export_value, arg0}
  def export_op(arg0), do: {:export_op, arg0}
  def export_type(arg0, arg1), do: {:export_type, arg0, arg1}
  def export_type_op(arg0, arg1), do: {:export_type_op, arg0, arg1}
  def export_class(arg0, arg1), do: {:export_class, arg0, arg1}
  def export_module(arg0, arg1), do: {:export_module, arg0, arg1}
  def export_error(arg0), do: {:export_error, arg0}

  # Data type: DataMembers
  def data_all(arg0), do: {:data_all, arg0}
  def data_enumerated(arg0), do: {:data_enumerated, arg0}

  # Data type: Declaration
  def decl_data(arg0, arg1), do: {:decl_data, arg0, arg1}
  def decl_type(arg0, arg1, arg2), do: {:decl_type, arg0, arg1, arg2}
  def decl_newtype(arg0, arg1, arg2, arg3), do: {:decl_newtype, arg0, arg1, arg2, arg3}
  def decl_class(arg0, arg1), do: {:decl_class, arg0, arg1}
  def decl_instance_chain(arg0), do: {:decl_instance_chain, arg0}
  def decl_derive(arg0, arg1, arg2), do: {:decl_derive, arg0, arg1, arg2}
  def decl_signature(arg0), do: {:decl_signature, arg0}
  def decl_value(arg0), do: {:decl_value, arg0}
  def decl_fixity(arg0), do: {:decl_fixity, arg0}
  def decl_foreign(arg0, arg1, arg2), do: {:decl_foreign, arg0, arg1, arg2}
  def decl_error(arg0), do: {:decl_error, arg0}

  # @type data_head :: %{keyword: source_token(), name: name()(proper()), vars: list()((type_var_binding()(e)))}

  # @type data_ctor :: %{name: name()(proper()), fields: list()((type()(e)))}

  # @type class_head :: %{keyword: source_token(), super_: maybe()((tuple()((list()((type()(e)))))(source_token()))), name: name()(proper()), vars: list()((type_var_binding()(e))), fundeps: maybe()((tuple()(source_token())((separated()(class_fundep())))))}

  # Data type: ClassFundep
  def fundep_determined(arg0, arg1), do: {:fundep_determined, arg0, arg1}
  def fundep_determines(arg0, arg1, arg2), do: {:fundep_determines, arg0, arg1, arg2}

  # @type instance :: %{head: instance_head()(e), body: maybe()((tuple()(source_token())((list()((instance_binding()(e)))))))}

  # Data type: InstanceBinding
  def instance_binding_signature(arg0), do: {:instance_binding_signature, arg0}
  def instance_binding_name(arg0), do: {:instance_binding_name, arg0}

  # @type instance_head :: %{keyword: source_token(), name: maybe()((tuple()((name()(ident())))(source_token()))), constraints: maybe()((tuple()((list()((type()(e)))))(source_token()))), class_name: qualified_name()(proper()), types: list()((type()(e)))}

  # @type import_decl :: %{keyword: source_token(), module: name()(module_name()), names: maybe()((tuple()((maybe()(source_token())))((delimited_non_empty()((import_()(e))))))), qualified: maybe()((tuple()(source_token())((name()(module_name())))))}

  # Data type: Import
  def import_value(arg0), do: {:import_value, arg0}
  def import_op(arg0), do: {:import_op, arg0}
  def import_type(arg0, arg1), do: {:import_type, arg0, arg1}
  def import_type_op(arg0, arg1), do: {:import_type_op, arg0, arg1}
  def import_class(arg0, arg1), do: {:import_class, arg0, arg1}
  def import_error(arg0), do: {:import_error, arg0}

  # Data type: Fixity
  def infix(), do: :infix
  def infixl(), do: :infixl
  def infixr(), do: :infixr

  # @type fixity_fields :: %{keyword: tuple()(source_token())(fixity()), prec: tuple()(source_token())(int()), operator: fixity_op()}

  # Data type: FixityOp
  def fixity_value(arg0, arg1, arg2), do: {:fixity_value, arg0, arg1, arg2}
  def fixity_type(arg0, arg1, arg2, arg3), do: {:fixity_type, arg0, arg1, arg2, arg3}

  # Data type: Foreign
  def foreign_value(arg0), do: {:foreign_value, arg0}
  def foreign_data(arg0, arg1), do: {:foreign_data, arg0, arg1}

  # Data type: Expr
  def expr_hole(arg0), do: {:expr_hole, arg0}
  def expr_section(arg0), do: {:expr_section, arg0}
  def expr_ident(arg0), do: {:expr_ident, arg0}
  def expr_constructor(arg0), do: {:expr_constructor, arg0}
  def expr_boolean(arg0, arg1), do: {:expr_boolean, arg0, arg1}
  def expr_char(arg0, arg1), do: {:expr_char, arg0, arg1}
  def expr_string(arg0, arg1), do: {:expr_string, arg0, arg1}
  def expr_int(arg0, arg1), do: {:expr_int, arg0, arg1}
  def expr_number(arg0, arg1), do: {:expr_number, arg0, arg1}
  def expr_array(arg0), do: {:expr_array, arg0}
  def expr_record(arg0), do: {:expr_record, arg0}
  def expr_parens(arg0), do: {:expr_parens, arg0}
  def expr_typed(arg0, arg1, arg2), do: {:expr_typed, arg0, arg1, arg2}
  def expr_infix(arg0, arg1), do: {:expr_infix, arg0, arg1}
  def expr_op(arg0, arg1), do: {:expr_op, arg0, arg1}
  def expr_op_name(arg0), do: {:expr_op_name, arg0}
  def expr_negate(arg0, arg1), do: {:expr_negate, arg0, arg1}
  def expr_record_accessor(arg0), do: {:expr_record_accessor, arg0}
  def expr_record_update(arg0, arg1), do: {:expr_record_update, arg0, arg1}
  def expr_app(arg0, arg1), do: {:expr_app, arg0, arg1}
  def expr_lambda(arg0), do: {:expr_lambda, arg0}
  def expr_if(arg0), do: {:expr_if, arg0}
  def expr_case(arg0), do: {:expr_case, arg0}
  def expr_let(arg0), do: {:expr_let, arg0}
  def expr_do(arg0), do: {:expr_do, arg0}
  def expr_ado(arg0), do: {:expr_ado, arg0}
  def expr_error(arg0), do: {:expr_error, arg0}

  # Data type: RecordLabeled
  def record_pun(arg0), do: {:record_pun, arg0}
  def record_field(arg0, arg1, arg2), do: {:record_field, arg0, arg1, arg2}

  # Data type: RecordUpdate
  def record_update_leaf(arg0, arg1, arg2), do: {:record_update_leaf, arg0, arg1, arg2}
  def record_update_branch(arg0, arg1), do: {:record_update_branch, arg0, arg1}

  # @type record_accessor :: %{expr: expr()(e), dot: source_token(), path: separated()((name()(label())))}

  # @type lambda :: %{symbol: source_token(), binders: list()((binder()(e))), arrow: source_token(), body: expr()(e)}

  # @type if_then_else :: %{keyword: source_token(), cond_: expr()(e), then_kw: source_token(), then_branch: expr()(e), else_kw: source_token(), else_branch: expr()(e)}

  # @type case_of :: %{keyword: source_token(), head: separated()((expr()(e))), of: source_token(), branches: list()((tuple()((separated()((binder()(e)))))((guarded()(e)))))}

  # @type let_in :: %{keyword: source_token(), bindings: list()((let_binding()(e))), in_: source_token(), body: expr()(e)}

  # @type where :: %{expr: expr()(e), bindings: maybe()((tuple()(source_token())((list()((let_binding()(e)))))))}

  # Data type: LetBinding
  def let_binding_signature(arg0), do: {:let_binding_signature, arg0}
  def let_binding_name(arg0), do: {:let_binding_name, arg0}
  def let_binding_pattern(arg0, arg1, arg2), do: {:let_binding_pattern, arg0, arg1, arg2}
  def let_binding_error(arg0), do: {:let_binding_error, arg0}

  # @type do_block :: %{keyword: source_token(), statements: list()((do_statement()(e)))}

  # Data type: DoStatement
  def do_let(arg0, arg1), do: {:do_let, arg0, arg1}
  def do_discard(arg0), do: {:do_discard, arg0}
  def do_bind(arg0, arg1, arg2), do: {:do_bind, arg0, arg1, arg2}
  def do_error(arg0), do: {:do_error, arg0}

  # @type ado_block :: %{keyword: source_token(), statements: list()((do_statement()(e))), in_: source_token(), result: expr()(e)}

  # @type value_binding_fields :: %{name: name()(ident()), binders: list()((binder()(e))), guarded: guarded()(e)}

  # Data type: Guarded
  def unconditional(arg0, arg1), do: {:unconditional, arg0, arg1}
  def guarded(arg0), do: {:guarded, arg0}

  # @type guarded_expr :: %{bar: source_token(), patterns: separated()((pattern_guard()(e))), separator: source_token(), where: where()(e)}

  # @type pattern_guard :: %{binder: maybe()((tuple()((binder()(e)))(source_token()))), expr: expr()(e)}

  # Data type: Binder
  def binder_wildcard(arg0), do: {:binder_wildcard, arg0}
  def binder_var(arg0), do: {:binder_var, arg0}
  def binder_named(arg0, arg1, arg2), do: {:binder_named, arg0, arg1, arg2}
  def binder_constructor(arg0, arg1), do: {:binder_constructor, arg0, arg1}
  def binder_boolean(arg0, arg1), do: {:binder_boolean, arg0, arg1}
  def binder_char(arg0, arg1), do: {:binder_char, arg0, arg1}
  def binder_string(arg0, arg1), do: {:binder_string, arg0, arg1}
  def binder_int(arg0, arg1, arg2), do: {:binder_int, arg0, arg1, arg2}
  def binder_number(arg0, arg1, arg2), do: {:binder_number, arg0, arg1, arg2}
  def binder_array(arg0), do: {:binder_array, arg0}
  def binder_record(arg0), do: {:binder_record, arg0}
  def binder_parens(arg0), do: {:binder_parens, arg0}
  def binder_typed(arg0, arg1, arg2), do: {:binder_typed, arg0, arg1, arg2}
  def binder_op(arg0, arg1), do: {:binder_op, arg0, arg1}
  def binder_error(arg0), do: {:binder_error, arg0}

  # @type recovered_error :: %{tokens: list()(source_token()), error: string()}

  # Data type: ParseResult
  def parse_succeeded(arg0), do: {:parse_succeeded, arg0}
  def parse_succeeded_with_errors(arg0, arg1), do: {:parse_succeeded_with_errors, arg0, arg1}
  def parse_failed(arg0), do: {:parse_failed, arg0}
end
