# This file was auto-generated by the Nova compiler.
# Do not edit this file manually.

defmodule Nova.Compiler.ImportProcessor do
  # import Prelude

  # import Data.Array

  # import Data.Either

  # import Data.List

  # import Data.List

  # import Data.Map

  # import Data.Maybe

  # import Data.Set

  # import Data.String

  # import Data.Tuple

  # import Nova.Compiler.Ast

  # import Nova.Compiler.Types

  # import Nova.Compiler.Types

  # @type resolved_imports :: map._map()(string())(string())



  def array_map(f, arr) do
    Prelude.map(f, arr)
  end



  def list_map(f, xs) do
    Prelude.map(f, xs)
  end



  def map_map_maybe(f, m) do
    
      pairs = Nova.Map.to_unfoldable(m)
      filtered = Nova.Array.map_maybe((fn ({:tuple, k, v}) -> case f.(v) do
        {:just, w} -> {:just, ({:tuple, k, w})}
        :nothing -> :nothing
      end end), pairs)
      Nova.Map.from_foldable(filtered)
  end



  def is_record_type(({:ty_record, _})) do
    true
  end

  def is_record_type(_) do
    false
  end



  def get_exports_expanded_type_aliases(exports) do
    exports.expanded_type_aliases
  end



  def get_exports_type_aliases(exports) do
    exports.type_aliases
  end



  def get_exports_values(exports) do
    exports.values
  end



  def get_exports_constructors(exports) do
    exports.constructors
  end



  def get_exports_types(exports) do
    exports.types
  end



  def process_imports(registry, env, decls) do
    
      process_decl = fn auto_arg0 -> fn auto_arg1 -> case {auto_arg0, auto_arg1} do
        {e, ({:decl_import, imp})} -> process_import_decl(registry, e, imp)
        {e, _} -> e
      end end end
      Nova.Array.foldl(process_decl, env, decls)
  end



  def process_import_decl(registry, env, imp) do
    case Nova.Compiler.Types.lookup_module(registry, imp.module_name) do
      :nothing -> env
      {:just, exports} -> 
          exports_expanded_type_aliases = get_exports_expanded_type_aliases(exports)
          exports_type_aliases = get_exports_type_aliases(exports)
          env_with_qualified = case imp.alias_ do
            {:just, alias_} -> Nova.Compiler.Types.merge_exports_to_env_with_prefix(env, exports, alias_)
            :nothing -> 
                last_part = case Nova.String.last_index_of((Nova.String.pattern(".")), imp.module_name) do
                  :nothing -> imp.module_name
                  {:just, idx} -> Nova.String.drop(((idx + 1)), imp.module_name)
                end
                Nova.Compiler.Types.merge_exports_to_env_with_prefix(env, exports, last_part)
          end
          if imp.hiding do
  merge_exports_with_type_aliases(env_with_qualified, exports)
else
  if Nova.List.null(imp.items) do
    case imp.alias_ do
      {:just, _} -> 
          module_aliases = if Nova.Map.is_empty(exports_expanded_type_aliases) do
            expand_module_aliases(exports_type_aliases)
          else
            exports_expanded_type_aliases
          end
          add_if_record_alias = fn e -> fn ({:tuple, name, ty}) -> if is_record_type(ty) do
            extend_type_alias(e, name, ty)
          else
            e
          end end end
          Nova.Array.foldl(add_if_record_alias, env_with_qualified, (Nova.Map.to_unfoldable(module_aliases)))
      :nothing -> merge_exports_with_type_aliases(env_with_qualified, exports)
    end
  else
    Nova.List.foldl((fn auto_p0 -> fn auto_p1 -> import_item(exports, auto_p0, auto_p1) end end), env_with_qualified, imp.items)
  end
end
    end
  end



  def merge_exports_with_type_aliases(env, exports) do
    
      exports_expanded_type_aliases = get_exports_expanded_type_aliases(exports)
      exports_type_aliases = get_exports_type_aliases(exports)
      env1 = Nova.Compiler.Types.merge_exports_to_env(env, exports)
      add_if_record_alias = fn e -> fn ({:tuple, name, ty}) -> if is_record_type(ty) do
        extend_type_alias(e, name, ty)
      else
        e
      end end end
      module_aliases = if Nova.Map.is_empty(exports_expanded_type_aliases) do
        expand_module_aliases(exports_type_aliases)
      else
        exports_expanded_type_aliases
      end
      env2 = Nova.Array.foldl(add_if_record_alias, env1, (Nova.Map.to_unfoldable(module_aliases)))
      env2
  end



  def expand_module_aliases(alias_infos) do
    
      initial = map_map_maybe((fn info -> if Nova.Array.null(info.params) do
        {:just, (type_expr_to_type(Nova.Map.empty, info.body))}
      else
        :nothing
      end end), alias_infos)
      pass2 = map_map_maybe((fn info -> if Nova.Array.null(info.params) do
        {:just, (type_expr_to_type_with_all_aliases(initial, alias_infos, Nova.Map.empty, info.body))}
      else
        :nothing
      end end), alias_infos)
      pass3 = map_map_maybe((fn info -> if Nova.Array.null(info.params) do
        {:just, (type_expr_to_type_with_all_aliases(pass2, alias_infos, Nova.Map.empty, info.body))}
      else
        :nothing
      end end), alias_infos)
      pass3
  end



  def import_item(exports, env, item) do
    
      exports_expanded_type_aliases = get_exports_expanded_type_aliases(exports)
      exports_type_aliases = get_exports_type_aliases(exports)
      exports_values = get_exports_values(exports)
      exports_constructors = get_exports_constructors(exports)
      exports_types = get_exports_types(exports)
      module_aliases = if Nova.Map.is_empty(exports_expanded_type_aliases) do
        expand_module_aliases(exports_type_aliases)
      else
        exports_expanded_type_aliases
      end
      add_all_record_aliases = fn e -> 
        add_if_record = fn e2 -> fn ({:tuple, name, ty}) -> if is_record_type(ty) do
          extend_type_alias(e2, name, ty)
        else
          e2
        end end end
        Nova.Array.foldl(add_if_record, e, (Nova.Map.to_unfoldable(module_aliases))) end
      case item do
  {:import_value, name} -> case Nova.Map.lookup(name, exports_values) do
      {:just, scheme} -> add_all_record_aliases.((extend_env(env, name, scheme)))
      :nothing -> case Nova.Map.lookup(name, exports_constructors) do
          {:just, scheme} -> add_all_record_aliases.((extend_env(env, name, scheme)))
          :nothing -> case Nova.Map.lookup(name, module_aliases) do
              {:just, ty} -> add_all_record_aliases.((extend_type_alias(env, name, ty)))
              :nothing -> add_all_record_aliases.(env)
            end
        end
    end
  {:import_type, type_name, spec} -> 
      env_prime = case Nova.Map.lookup(type_name, exports_type_aliases) do
        {:just, alias_info} -> 
            expanded_ty = case Nova.Map.lookup(type_name, module_aliases) do
              {:just, ty} -> ty
              :nothing -> type_expr_to_type(Nova.Map.empty, alias_info.body)
            end
            referenced_names = collect_type_expr_names(alias_info.body)
            add_if_record_alias = fn e -> fn name -> case Nova.Map.lookup(name, module_aliases) do
              {:just, alias_ty} ->
                cond do
                  is_record_type(alias_ty) -> extend_type_alias(e, name, alias_ty)
                  true -> e
                end
              _ -> e
            end end end
            e1 = extend_type_alias(env, type_name, expanded_ty)
            Nova.Array.foldl(add_if_record_alias, e1, (Nova.Set.to_unfoldable(referenced_names)))
        :nothing -> case Nova.Map.lookup(type_name, module_aliases) do
            {:just, ty} -> extend_type_alias(env, type_name, ty)
            :nothing -> env
          end
      end
      case Nova.Map.lookup(type_name, exports_types) do
  :nothing -> add_all_record_aliases.(env_prime)
  {:just, type_info} -> case spec do
      :import_all -> add_all_record_aliases.((merge_type_export(env_prime, exports, type_name, type_info.constructors)))
      {:import_some, ctor_names} -> add_all_record_aliases.((merge_type_export(env_prime, exports, type_name, (Nova.List.to_unfoldable(ctor_names)))))
      :import_none -> add_all_record_aliases.(env_prime)
    end
end
end
  end



  def resolve_imports(registry, decls) do
    
      process_decl = fn auto_arg0 -> fn auto_arg1 -> case {auto_arg0, auto_arg1} do
        {resolved, ({:decl_import, imp})} -> resolve_import_decl(registry, resolved, imp)
        {resolved, _} -> resolved
      end end end
      Nova.Array.foldl(process_decl, Nova.Map.empty, decls)
  end



  def resolve_import_decl(registry, resolved, imp) do
    case Nova.Compiler.Types.lookup_module(registry, imp.module_name) do
      :nothing -> resolved
      {:just, exports} -> if imp.hiding do
          
            all_names = get_all_exported_names(exports)
            items_as_array = Nova.List.to_unfoldable(imp.items)
            hidden_names = Nova.Set.from_foldable((array_map((&get_item_name/1), items_as_array)))
            imported_names = Nova.Set.difference(all_names, hidden_names)
            imported_array = Nova.Set.to_unfoldable(imported_names)
            Nova.Array.foldl((fn m -> fn name -> Nova.Map.insert(name, imp.module_name, m) end end), resolved, imported_array)
        else
          if Nova.List.null(imp.items) do
            
              all_names = get_all_exported_names(exports)
              all_names_array = Nova.Set.to_unfoldable(all_names)
              Nova.Array.foldl((fn m -> fn name -> Nova.Map.insert(name, imp.module_name, m) end end), resolved, all_names_array)
          else
            
              items_array = Nova.List.to_unfoldable(imp.items)
              Nova.Array.foldl((fn m -> fn item -> Nova.Map.insert((get_item_name(item)), imp.module_name, m) end end), resolved, items_array)
          end
        end
    end
  end



  def get_item_name(({:import_value, name})) do
    name
  end

  def get_item_name(({:import_type, name, _})) do
    name
  end



  def get_all_exported_names(exports) do
    
      value_names = Nova.Set.from_foldable((Nova.Map.keys(exports.values)))
      ctor_names = Nova.Set.from_foldable((Nova.Map.keys(exports.constructors)))
      type_names = Nova.Set.from_foldable((Nova.Map.keys(exports.types)))
      alias_names = Nova.Set.from_foldable((Nova.Map.keys(exports.type_aliases)))
      Nova.Set.unions([value_names, ctor_names, type_names, alias_names])
  end



  def extend_env(env, name, scheme) do
    %{env | bindings: Nova.Map.insert(name, scheme, env.bindings)}
  end



  def extend_type_alias(env, name, ty) do
    %{env | type_aliases: Nova.Map.insert(name, ty, env.type_aliases)}
  end



  def merge_type_export(env, exports, _type_name, ctor_names) do
    
      add_ctor = fn e -> fn ctor_name -> case Nova.Map.lookup(ctor_name, exports.constructors) do
        {:just, scheme} -> extend_env(e, ctor_name, scheme)
        :nothing -> e
      end end end
      Nova.Array.foldl(add_ctor, env, ctor_names)
  end



  def type_expr_to_type(aliases, expr) do
    case expr do
      {:ty_expr_var, name} -> case Nova.Map.lookup(name, aliases) do
          {:just, ty} -> ty
          :nothing -> {:ty_var, %{id: 0, name: name}}
        end
      {:ty_expr_con, name} -> {:ty_con, %{name: name, args: []}}
      {:ty_expr_arrow, from, to} -> Nova.Compiler.Types.t_arrow((type_expr_to_type(aliases, from)), (type_expr_to_type(aliases, to)))
      {:ty_expr_record, fields, maybe_row} -> 
          fields_as_array = Nova.List.to_unfoldable(fields)
          row_var = case maybe_row do
            {:just, row_name} -> {:just, %{id: 0, name: row_name}}
            :nothing -> :nothing
          end
          field_map = Nova.Map.from_foldable((array_map((fn ({:tuple, label, ty}) -> {:tuple, label, (type_expr_to_type(aliases, ty))} end), fields_as_array)))
          {:ty_record, %{fields: field_map, row: row_var}}
      {:ty_expr_for_all, _, inner} -> type_expr_to_type(aliases, inner)
      {:ty_expr_parens, inner} -> type_expr_to_type(aliases, inner)
      {:ty_expr_app, base, arg} -> case type_expr_to_type(aliases, base) do
          {:ty_con, tc} -> {:ty_con, %{name: tc.name, args: Nova.Runtime.append(tc.args, [type_expr_to_type(aliases, arg)])}}
          other -> other
        end
      {:ty_expr_constrained, _, inner} -> type_expr_to_type(aliases, inner)
      {:ty_expr_tuple, items} -> 
          items_as_array = Nova.List.to_unfoldable(items)
          arg_types = array_map((fn auto_p0 -> type_expr_to_type(aliases, auto_p0) end), items_as_array)
          {:ty_con, %{name: "Tuple", args: arg_types}}
    end
  end



  def type_expr_to_type_with_all_aliases(simple_aliases, full_aliases, param_aliases, expr) do
    case expr do
      {:ty_expr_var, name} -> case Nova.Map.lookup(name, param_aliases) do
          {:just, ty} -> ty
          :nothing -> case Nova.Map.lookup(name, simple_aliases) do
              {:just, ty} -> ty
              :nothing -> {:ty_var, %{id: 0, name: name}}
            end
        end
      {:ty_expr_con, name} -> case Nova.Map.lookup(name, full_aliases) do
          {:just, alias_info} ->
            cond do
              Nova.Array.null(alias_info.params) -> type_expr_to_type_with_all_aliases(simple_aliases, full_aliases, param_aliases, alias_info.body)
              true -> {:ty_con, %{name: name, args: []}}
            end
          _ -> {:ty_con, %{name: name, args: []}}
        end
      {:ty_expr_arrow, from, to} -> Nova.Compiler.Types.t_arrow((type_expr_to_type_with_all_aliases(simple_aliases, full_aliases, param_aliases, from)), (type_expr_to_type_with_all_aliases(simple_aliases, full_aliases, param_aliases, to)))
      {:ty_expr_record, fields, maybe_row} -> 
          fields_as_array = Nova.List.to_unfoldable(fields)
          row_var = case maybe_row do
            {:just, row_name} -> case Nova.Map.lookup(row_name, param_aliases) do
                {:just, ({:ty_var, v})} -> {:just, v}
                {:just, _} -> :nothing
                :nothing -> {:just, %{id: 0, name: row_name}}
              end
            :nothing -> :nothing
          end
          field_map = Nova.Map.from_foldable((array_map((fn ({:tuple, label, ty}) -> {:tuple, label, (type_expr_to_type_with_all_aliases(simple_aliases, full_aliases, param_aliases, ty))} end), fields_as_array)))
          {:ty_record, %{fields: field_map, row: row_var}}
      {:ty_expr_for_all, _, inner} -> type_expr_to_type_with_all_aliases(simple_aliases, full_aliases, param_aliases, inner)
      {:ty_expr_parens, inner} -> type_expr_to_type_with_all_aliases(simple_aliases, full_aliases, param_aliases, inner)
      {:ty_expr_app, _, _} -> 
          {:tuple, con_name, args} = collect_type_app(expr)
          arg_types = array_map((fn auto_p0 -> type_expr_to_type_with_all_aliases(simple_aliases, full_aliases, param_aliases, auto_p0) end), args)
          case Nova.Map.lookup(con_name, full_aliases) do
  {:just, alias_info} ->
    cond do
      (Nova.Array.length(arg_types) == Nova.Array.length(alias_info.params)) -> 
          param_map = Nova.Map.from_foldable((Nova.Array.zip(alias_info.params, arg_types)))
          type_expr_to_type_with_all_aliases(simple_aliases, full_aliases, param_map, alias_info.body)
      true -> {:ty_con, %{name: con_name, args: arg_types}}
    end
  _ -> {:ty_con, %{name: con_name, args: arg_types}}
end
      {:ty_expr_constrained, _, inner} -> type_expr_to_type_with_all_aliases(simple_aliases, full_aliases, param_aliases, inner)
      {:ty_expr_tuple, items} -> 
          items_as_array = Nova.List.to_unfoldable(items)
          arg_types = array_map((fn auto_p0 -> type_expr_to_type_with_all_aliases(simple_aliases, full_aliases, param_aliases, auto_p0) end), items_as_array)
          {:ty_con, %{name: "Tuple", args: arg_types}}
    end
  end



  def collect_type_app(({:ty_expr_con, name})) do
    {:tuple, name, []}
  end

  def collect_type_app(({:ty_expr_app, base, arg})) do
    
      {:tuple, name, args} = collect_type_app(base)
      {:tuple, name, (Nova.Runtime.append(args, [arg]))}
  end

  def collect_type_app(_) do
    {:tuple, "Unknown", []}
  end



  def collect_type_expr_names(expr) do
    case expr do
      {:ty_expr_var, _} -> Nova.Set.empty
      {:ty_expr_con, name} -> Nova.Set.singleton(name)
      {:ty_expr_arrow, from, to} -> Nova.Set.union((collect_type_expr_names(from)), (collect_type_expr_names(to)))
      {:ty_expr_record, fields, _} -> 
          fields_as_array = Nova.List.to_unfoldable(fields)
          fields_sets = array_map((fn ({:tuple, _, ty}) -> collect_type_expr_names(ty) end), fields_as_array)
          Nova.Set.unions(fields_sets)
      {:ty_expr_for_all, _, inner} -> collect_type_expr_names(inner)
      {:ty_expr_parens, inner} -> collect_type_expr_names(inner)
      {:ty_expr_app, base, arg} -> Nova.Set.union((collect_type_expr_names(base)), (collect_type_expr_names(arg)))
      {:ty_expr_constrained, _, inner} -> collect_type_expr_names(inner)
      {:ty_expr_tuple, items} -> 
          items_as_array = Nova.List.to_unfoldable(items)
          items_sets = array_map((&collect_type_expr_names/1), items_as_array)
          Nova.Set.unions(items_sets)
    end
  end
end
