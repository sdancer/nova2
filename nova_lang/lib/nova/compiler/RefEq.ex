# This file was auto-generated by the Nova compiler.
# Do not edit this file manually.

defmodule Nova.Compiler.RefEq do
  # import Prelude

  # import Data.List

  # import Data.Tuple

  # import Data.Maybe

  # import Data.Foldable

  # import Nova.Compiler.Ast



  def ref_eq_expr(({:expr_var, a}), ({:expr_var, b})) do
    (a == b)
  end

  def ref_eq_expr(({:expr_qualified, ns1, n1}), ({:expr_qualified, ns2, n2})) do
    ((ns1 == ns2) and (n1 == n2))
  end

  def ref_eq_expr(({:expr_lit, a}), ({:expr_lit, b})) do
    ref_eq_lit(a, b)
  end

  def ref_eq_expr(({:expr_app, f1, a1}), ({:expr_app, f2, a2})) do
    (ref_eq_expr(f1, f2) and ref_eq_expr(a1, a2))
  end

  def ref_eq_expr(({:expr_lambda, p1, b1}), ({:expr_lambda, p2, b2})) do
    (((Data.List.length(p1) == Data.List.length(p2)) and ref_eq_pattern_list(p1, p2)) and ref_eq_expr(b1, b2))
  end

  def ref_eq_expr(({:expr_let, binds1, body1}), ({:expr_let, binds2, body2})) do
    (((Data.List.length(binds1) == Data.List.length(binds2)) and ref_eq_let_bind_list(binds1, binds2)) and ref_eq_expr(body1, body2))
  end

  def ref_eq_expr(({:expr_if, c1, t1, e1}), ({:expr_if, c2, t2, e2})) do
    ((ref_eq_expr(c1, c2) and ref_eq_expr(t1, t2)) and ref_eq_expr(e1, e2))
  end

  def ref_eq_expr(({:expr_case, scrut1, clauses1}), ({:expr_case, scrut2, clauses2})) do
    ((ref_eq_expr(scrut1, scrut2) and (Data.List.length(clauses1) == Data.List.length(clauses2))) and ref_eq_case_clause_list(clauses1, clauses2))
  end

  def ref_eq_expr(({:expr_do, stmts1}), ({:expr_do, stmts2})) do
    ((Data.List.length(stmts1) == Data.List.length(stmts2)) and ref_eq_do_stmt_list(stmts1, stmts2))
  end

  def ref_eq_expr(({:expr_bin_op, op1, l1, r1}), ({:expr_bin_op, op2, l2, r2})) do
    (((op1 == op2) and ref_eq_expr(l1, l2)) and ref_eq_expr(r1, r2))
  end

  def ref_eq_expr(({:expr_unary_op, op1, e1}), ({:expr_unary_op, op2, e2})) do
    ((op1 == op2) and ref_eq_expr(e1, e2))
  end

  def ref_eq_expr(({:expr_list, es1}), ({:expr_list, es2})) do
    ((Data.List.length(es1) == Data.List.length(es2)) and ref_eq_expr_list(es1, es2))
  end

  def ref_eq_expr(({:expr_tuple, es1}), ({:expr_tuple, es2})) do
    ((Data.List.length(es1) == Data.List.length(es2)) and ref_eq_expr_list(es1, es2))
  end

  def ref_eq_expr(({:expr_record, fields1}), ({:expr_record, fields2})) do
    ((Data.List.length(fields1) == Data.List.length(fields2)) and ref_eq_record_fields(fields1, fields2))
  end

  def ref_eq_expr(({:expr_record_access, e1, f1}), ({:expr_record_access, e2, f2})) do
    ((f1 == f2) and ref_eq_expr(e1, e2))
  end

  def ref_eq_expr(({:expr_record_update, e1, upd1}), ({:expr_record_update, e2, upd2})) do
    ((ref_eq_expr(e1, e2) and (Data.List.length(upd1) == Data.List.length(upd2))) and ref_eq_record_fields(upd1, upd2))
  end

  def ref_eq_expr(({:expr_typed, e1, _}), ({:expr_typed, e2, _})) do
    ref_eq_expr(e1, e2)
  end

  def ref_eq_expr(({:expr_parens, e1}), ({:expr_parens, e2})) do
    ref_eq_expr(e1, e2)
  end

  def ref_eq_expr(({:expr_parens, e1}), e2) do
    ref_eq_expr(e1, e2)
  end

  def ref_eq_expr(e1, ({:expr_parens, e2})) do
    ref_eq_expr(e1, e2)
  end

  def ref_eq_expr(({:expr_section, s1}), ({:expr_section, s2})) do
    (s1 == s2)
  end

  def ref_eq_expr(_, _) do
    false
  end



  def ref_eq_lit(({:lit_int, a}), ({:lit_int, b})) do
    (a == b)
  end

  def ref_eq_lit(({:lit_number, a}), ({:lit_number, b})) do
    (a == b)
  end

  def ref_eq_lit(({:lit_string, a}), ({:lit_string, b})) do
    (a == b)
  end

  def ref_eq_lit(({:lit_char, a}), ({:lit_char, b})) do
    (a == b)
  end

  def ref_eq_lit(({:lit_bool, a}), ({:lit_bool, b})) do
    (a == b)
  end

  def ref_eq_lit(_, _) do
    false
  end



  def ref_eq_pattern(({:pat_var, a}), ({:pat_var, b})) do
    (a == b)
  end

  def ref_eq_pattern(:pat_wildcard, :pat_wildcard) do
    true
  end

  def ref_eq_pattern(({:pat_lit, a}), ({:pat_lit, b})) do
    ref_eq_lit(a, b)
  end

  def ref_eq_pattern(({:pat_con, n1, ps1}), ({:pat_con, n2, ps2})) do
    (((n1 == n2) and (Data.List.length(ps1) == Data.List.length(ps2))) and ref_eq_pattern_list(ps1, ps2))
  end

  def ref_eq_pattern(({:pat_list, ps1}), ({:pat_list, ps2})) do
    ((Data.List.length(ps1) == Data.List.length(ps2)) and ref_eq_pattern_list(ps1, ps2))
  end

  def ref_eq_pattern(({:pat_cons, h1, t1}), ({:pat_cons, h2, t2})) do
    (ref_eq_pattern(h1, h2) and ref_eq_pattern(t1, t2))
  end

  def ref_eq_pattern(({:pat_record, fs1}), ({:pat_record, fs2})) do
    ((Data.List.length(fs1) == Data.List.length(fs2)) and Data.Foldable.all((fn ({:tuple, ({:tuple, n1, p1}), ({:tuple, n2, p2})}) -> ((n1 == n2) and ref_eq_pattern(p1, p2)) end), (Data.List.zip(fs1, fs2))))
  end

  def ref_eq_pattern(({:pat_parens, p1}), ({:pat_parens, p2})) do
    ref_eq_pattern(p1, p2)
  end

  def ref_eq_pattern(({:pat_parens, p1}), p2) do
    ref_eq_pattern(p1, p2)
  end

  def ref_eq_pattern(p1, ({:pat_parens, p2})) do
    ref_eq_pattern(p1, p2)
  end

  def ref_eq_pattern(({:pat_as, n1, p1}), ({:pat_as, n2, p2})) do
    ((n1 == n2) and ref_eq_pattern(p1, p2))
  end

  def ref_eq_pattern(_, _) do
    false
  end



  def ref_eq_pattern_list([], []) do
    true
  end

  def ref_eq_pattern_list(([p1 | ps1]), ([p2 | ps2])) do
    (ref_eq_pattern(p1, p2) and ref_eq_pattern_list(ps1, ps2))
  end

  def ref_eq_pattern_list(_, _) do
    false
  end



  def ref_eq_expr_list([], []) do
    true
  end

  def ref_eq_expr_list(([e1 | es1]), ([e2 | es2])) do
    (ref_eq_expr(e1, e2) and ref_eq_expr_list(es1, es2))
  end

  def ref_eq_expr_list(_, _) do
    false
  end



  def ref_eq_let_bind_list([], []) do
    true
  end

  def ref_eq_let_bind_list(([b1 | bs1]), ([b2 | bs2])) do
    ((ref_eq_pattern(b1.pattern, b2.pattern) and ref_eq_expr(b1.value, b2.value)) and ref_eq_let_bind_list(bs1, bs2))
  end

  def ref_eq_let_bind_list(_, _) do
    false
  end



  def ref_eq_case_clause_list([], []) do
    true
  end

  def ref_eq_case_clause_list(([c1 | cs1]), ([c2 | cs2])) do
    (((ref_eq_pattern(c1.pattern, c2.pattern) and ref_eq_maybe_expr(c1.guard, c2.guard)) and ref_eq_expr(c1.body, c2.body)) and ref_eq_case_clause_list(cs1, cs2))
  end

  def ref_eq_case_clause_list(_, _) do
    false
  end



  def ref_eq_maybe_expr(:nothing, :nothing) do
    true
  end

  def ref_eq_maybe_expr(({:just, e1}), ({:just, e2})) do
    ref_eq_expr(e1, e2)
  end

  def ref_eq_maybe_expr(_, _) do
    false
  end



  def ref_eq_do_stmt_list([], []) do
    true
  end

  def ref_eq_do_stmt_list(([s1 | ss1]), ([s2 | ss2])) do
    (ref_eq_do_stmt(s1, s2) and ref_eq_do_stmt_list(ss1, ss2))
  end

  def ref_eq_do_stmt_list(_, _) do
    false
  end



  def ref_eq_do_stmt(({:do_let, binds1}), ({:do_let, binds2})) do
    ref_eq_let_bind_list(binds1, binds2)
  end

  def ref_eq_do_stmt(({:do_bind, p1, e1}), ({:do_bind, p2, e2})) do
    (ref_eq_pattern(p1, p2) and ref_eq_expr(e1, e2))
  end

  def ref_eq_do_stmt(({:do_expr, e1}), ({:do_expr, e2})) do
    ref_eq_expr(e1, e2)
  end

  def ref_eq_do_stmt(_, _) do
    false
  end



  def ref_eq_record_fields([], []) do
    true
  end

  def ref_eq_record_fields(([({:tuple, n1, e1}) | fs1]), ([({:tuple, n2, e2}) | fs2])) do
    (((n1 == n2) and ref_eq_expr(e1, e2)) and ref_eq_record_fields(fs1, fs2))
  end

  def ref_eq_record_fields(_, _) do
    false
  end
end
