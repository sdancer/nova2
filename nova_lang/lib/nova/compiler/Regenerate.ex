# This file was auto-generated by the Nova compiler.
# Do not edit this file manually.

defmodule Nova.Compiler.Regenerate do
  # import Prelude

  # import Data.Array

  # import Data.Either

  # import Data.Foldable

  # import Data.Map

  # import Data.Map

  # import Data.Maybe

  # import Data.Set

  # import Data.Set

  # import Data.String

  # import Data.Tuple

  # import Nova.Compiler.Ast

  # import Nova.Compiler.CstPipeline

  # import Nova.Compiler.CodeGen

  # import Nova.Compiler.TypeChecker

  # import Nova.Compiler.Types

  # @type file_system :: %{read_file: (string() -> maybe()(string())), write_file: (string() -> (string() -> unit())), file_exists: (string() -> boolean()), list_files: (string() -> (string() -> array()(string())))}

  # @type regenerate_config :: %{src_base: string(), lib_base: string(), output_dir: string(), target_dir: string()}



  def default_config() do
    %{src_base: "./src/Nova/Compiler/", lib_base: "./lib/", output_dir: "./output/", target_dir: "./nova_lang/lib/nova/compiler/"}
  end

  # @type module_result :: %{mod_: module(), env: types._env(), exports: types._module_exports()}

  # Data type: LogEntry
  def log_info(arg0), do: {:log_info, arg0}
  def log_warning(arg0), do: {:log_warning, arg0}
  def log_error(arg0), do: {:log_error, arg0}

  # @type regenerate_result :: %{success: boolean(), modules_compiled: int(), logs: array()(log_entry())}



  def extract_imports(source) do
    
      lines = Nova.String.split((Nova.String.pattern("\n")), source)
      extract_import = fn line -> case Nova.String.index_of((Nova.String.pattern("import ")), line) do
        :nothing -> :nothing
        {:just, idx} -> 
            rest = Nova.String.drop(((idx + 7)), line)
            parts = Nova.String.split((Nova.String.pattern(" ")), rest)
            case Nova.Array.head(parts) do
  :nothing -> :nothing
  {:just, mod_name} -> 
      clean_name = case Nova.String.index_of((Nova.String.pattern("(")), mod_name) do
        :nothing -> mod_name
        {:just, paren_idx} -> Nova.String.take(paren_idx, mod_name)
      end
      if Nova.String.null(clean_name) do
  :nothing
else
  {:just, clean_name}
end
end
      end end
      Nova.Array.map_maybe(extract_import, lines)
  end



  def module_to_path(fs, cfg, mod_name) do
    if ((Nova.String.index_of((Nova.String.pattern("Data.")), mod_name) == {:just, 0}) or (mod_name == "Prelude")) do
      
        path = Nova.Runtime.append(Nova.Runtime.append(cfg.lib_base, Nova.String.replace_all((Nova.String.pattern(".")), (Nova.String.replacement("/")), mod_name)), ".purs")
        if (fs.file_exists).(path) do
  {:just, path}
else
  :nothing
end
    else
      if (Nova.String.index_of((Nova.String.pattern("Nova.Compiler.")), mod_name) == {:just, 0}) do
        
          short_name = Nova.String.drop(14, mod_name)
          path = Nova.Runtime.append(Nova.Runtime.append(cfg.src_base, Nova.String.replace_all((Nova.String.pattern(".")), (Nova.String.replacement("/")), short_name)), ".purs")
          if (fs.file_exists).(path) do
  {:just, path}
else
  :nothing
end
      else
        :nothing
      end
    end
  end



  def discover_dependencies(fs, cfg, path, _is_lib_module) do
    case (fs.read_file).(path) do
      :nothing -> []
      {:just, source} -> 
          imports = extract_imports(source)
          to_dep = fn mod_name -> module_to_path(fs, cfg, mod_name) end
          Nova.Array.filter((fn p -> (p != path) end), (Nova.Array.map_maybe(to_dep, imports)))
    end
  end



  def build_dependency_graph(fs, cfg, paths, is_lib_modules) do
    Nova.Map.from_foldable((Prelude.map((fn path -> {:tuple, path, (discover_dependencies(fs, cfg, path, is_lib_modules))} end), paths)))
  end



  def topological_sort(graph) do
    
      visit = Nova.Runtime.fix4(fn visit -> fn path -> fn visited -> fn visiting -> fn acc -> if Nova.Set.member(path, visited) do
        %{visited: visited, visiting: visiting, acc: acc}
      else
        if Nova.Set.member(path, visiting) do
          %{visited: visited, visiting: visiting, acc: acc}
        else
          
            visiting_prime = Nova.Set.insert(path, visiting)
            deps = case Nova.Map.lookup(path, graph) do
              {:just, d} -> d
              :nothing -> []
            end
            valid_deps = Nova.Array.filter((fn d -> Nova.Map.member(d, graph) end), deps)
            result = Data.Foldable.foldl((fn r -> fn d -> visit.(d).(r.visited).(r.visiting).(r.acc) end end), %{visited: visited, visiting: visiting_prime, acc: acc}, valid_deps)
            visited_prime = Nova.Set.insert(path, result.visited)
            visiting_prime_prime = Nova.Set.delete(path, result.visiting)
            %{visited: visited_prime, visiting: visiting_prime_prime, acc: Nova.Array.snoc(result.acc, path)}
        end
      end  end end end end end)
      go = Nova.Runtime.fix4(fn go -> fn remaining -> fn visited -> fn visiting -> fn acc -> case Nova.Array.uncons(remaining) do
        :nothing -> acc
        {:just, %{head: path, tail: rest}} -> if Nova.Set.member(path, visited) do
            go.(rest).(visited).(visiting).(acc)
          else
            
              result = visit.(path).(visited).(visiting).(acc)
              go.(rest).(result.visited).(result.visiting).(result.acc)
          end
      end  end end end end end)
      go.((Nova.Array.from_foldable((Nova.Map.keys(graph))))).(Nova.Set.empty).(Nova.Set.empty).([])
  end



  def parse_and_check_module(registry, source) do
    case Nova.Compiler.CstPipeline.parse_module_cst(source) do
      {:left, err} -> {:left, (Nova.Runtime.append("Parse error: ", err))}
      {:right, mod_} -> case Nova.Compiler.TypeChecker.check_module_with_registry(registry, Nova.Compiler.Types.empty_env(), (Nova.Array.from_foldable(mod_.declarations))) do
          {:left, err} -> {:left, (Nova.Runtime.append("Type error: ", Prelude.show(err)))}
          {:right, env} -> 
              mod_decls_array = Nova.Array.from_foldable(mod_.declarations)
              exports = Nova.Compiler.TypeChecker.extract_exports(mod_decls_array)
              exports_with_values = Nova.Compiler.TypeChecker.add_values_to_exports(exports, env, mod_decls_array)
              {:right, %{mod_: mod_, env: env, exports: exports_with_values}}
        end
    end
  end



  def compile_module(registry, source) do
    case parse_and_check_module(registry, source) do
      {:left, err} -> {:left, err}
      {:right, result} -> 
          maybe_env = {:just, result.env}
          code = Nova.Compiler.CodeGen.gen_module_with_registry(registry, maybe_env, result.mod_)
          {:right, code}
    end
  end



  def get_module_name(cfg, path) do
    if (Nova.String.index_of((Nova.String.pattern(cfg.lib_base)), path) == {:just, 0}) do
      
        relative = Nova.String.drop((Nova.String.length(cfg.lib_base)), path)
        without_ext = Nova.String.take(((Nova.String.length(relative) - 5)), relative)
        Nova.String.replace_all((Nova.String.pattern("/")), (Nova.String.replacement(".")), without_ext)
    else
      
        match = get_file_base_name(path)
        Nova.Runtime.append("Nova.Compiler.", match)
    end
  end



  def get_file_base_name(path) do
    
      parts = Nova.String.split((Nova.String.pattern("/")), path)
      case Nova.Array.last(parts) do
  :nothing -> path
  {:just, filename} -> Nova.String.take(((Nova.String.length(filename) - 5)), filename)
end
  end



  def get_short_name(auto_arg0) do
    get_file_base_name(auto_arg0)
  end



  def compile_library_modules(fs, cfg, sorted_paths) do
    
      compile_lib_module = fn fs_prime -> fn cfg_prime -> fn ({:tuple, registry, logs}) -> fn path -> case (fs_prime.read_file).(path) do
        :nothing -> {:tuple, registry, (Nova.Array.snoc(logs, (log_error((Nova.Runtime.append("Cannot read: ", path))))))}
        {:just, source} -> 
            mod_name = get_module_name(cfg_prime, path)
            case parse_and_check_module(registry, source) do
  {:left, err} -> {:tuple, registry, (Nova.Array.snoc(logs, (log_error((Nova.Runtime.append(Nova.Runtime.append(mod_name, ": "), err))))))}
  {:right, result} -> 
      registry_prime = Nova.Compiler.Types.register_module(registry, mod_name, result.exports)
      {:tuple, registry_prime, (Nova.Array.snoc(logs, (log_info((Nova.Runtime.append("Compiled library: ", mod_name))))))}
end
      end end end end end
      
  initial = {:tuple, (Nova.Compiler.Types.register_module(Nova.Compiler.Types.empty_registry(), "Prelude", Nova.Compiler.Types.prelude_exports())), []}
  Data.Foldable.foldl((compile_lib_module.(fs).(cfg)), initial, sorted_paths)
  end



  def compile_compiler_modules(fs, cfg, lib_registry, sorted_paths) do
    
      compile_comp_module = fn fs_prime -> fn cfg_prime -> fn acc -> fn path -> case (fs_prime.read_file).(path) do
        :nothing -> %{acc | logs: Nova.Array.snoc(acc.logs, (log_error((Nova.Runtime.append("Cannot read: ", path)))))}
        {:just, source} -> 
            short_name = get_short_name(path)
            full_mod_name = get_module_name(cfg_prime, path)
            case parse_and_check_module(acc.registry, source) do
  {:left, err} -> %{acc | logs: Nova.Array.snoc(acc.logs, (log_error((Nova.Runtime.append(Nova.Runtime.append(short_name, ": "), err)))))}
  {:right, result} -> 
      maybe_env = {:just, result.env}
      registry_prime = Nova.Compiler.Types.register_module(acc.registry, full_mod_name, result.exports)
      code = Nova.Compiler.CodeGen.gen_module_with_registry(acc.registry, maybe_env, result.mod_)
      written1 = (fs_prime.write_file).((Nova.Runtime.append(Nova.Runtime.append(cfg_prime.output_dir, short_name), ".ex"))).(code)
      written2 = (fs_prime.write_file).((Nova.Runtime.append(Nova.Runtime.append(cfg_prime.target_dir, short_name), ".ex"))).(code)
      line_count = Nova.Array.length((Nova.String.split((Nova.String.pattern("\n")), code)))
      log_msg = Nova.Runtime.append(Nova.Runtime.append(Nova.Runtime.append(Nova.Runtime.append("Compiled ", short_name), " ("), Prelude.show(line_count)), " lines)")
      %{registry: registry_prime, count: (acc.count + 1), logs: Nova.Array.snoc(acc.logs, (log_info(log_msg)))}
end
      end end end end end
      
  initial = %{registry: lib_registry, count: 0, logs: []}
  result = Data.Foldable.foldl((compile_comp_module.(fs).(cfg)), initial, sorted_paths)
  {:tuple, result.count, result.logs}
  end



  def regenerate(fs, cfg) do
    
      lib_files = (fs.list_files).((Nova.Runtime.append(cfg.lib_base, "Data"))).(".purs")
      compiler_files = (fs.list_files).(cfg.src_base).(".purs")
      lib_deps = build_dependency_graph(fs, cfg, lib_files, true)
      compiler_deps = build_dependency_graph(fs, cfg, compiler_files, false)
      sorted_lib_modules = topological_sort(lib_deps)
      sorted_compiler_modules = topological_sort(compiler_deps)
      {:tuple, lib_registry, lib_logs} = compile_library_modules(fs, cfg, sorted_lib_modules)
      {:tuple, compiler_count, compiler_logs} = compile_compiler_modules(fs, cfg, lib_registry, sorted_compiler_modules)
      %{success: true, modules_compiled: compiler_count, logs: Nova.Runtime.append(lib_logs, compiler_logs)}
  end



  def show_log_entry(({:log_info, msg})) do
    Nova.Runtime.append("[INFO] ", msg)
  end

  def show_log_entry(({:log_warning, msg})) do
    Nova.Runtime.append("[WARN] ", msg)
  end

  def show_log_entry(({:log_error, msg})) do
    Nova.Runtime.append("[ERROR] ", msg)
  end



  def show_logs() do
    fn auto_c -> (Nova.String.join_with("\n")).((fn auto_p0 -> Prelude.map((&show_log_entry/1), auto_p0) end).(auto_c)) end
  end
end
