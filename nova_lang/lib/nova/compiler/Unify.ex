# This file was auto-generated by the Nova compiler.
# Do not edit this file manually.

defmodule Nova.Compiler.Unify do
  # import Prelude

  # import Data.Either

  # import Data.Map

  # import Data.Set

  # import Data.Array

  # import Data.Array

  # import Data.Foldable

  # import Data.Tuple

  # import Data.Maybe

  # import Data.String

  # import Nova.Compiler.Types

  # Data type: UnifyError
  def occurs_check(arg0, arg1), do: {:occurs_check, arg0, arg1}
  def type_mismatch(arg0, arg1), do: {:type_mismatch, arg0, arg1}
  def arity_mismatch(arg0, arg1, arg2), do: {:arity_mismatch, arg0, arg1, arg2}
  def record_field_mismatch(arg0), do: {:record_field_mismatch, arg0}

  # instance Show unify_error()
  def show(({:occurs_check, v, t})) do
    Nova.Runtime.append(Nova.Runtime.append("Occurs check: ", v.name), " in type")
  end
  def show(({:type_mismatch, t1, t2})) do
    Nova.Runtime.append(Nova.Runtime.append(Nova.Runtime.append("Type mismatch: ", show_type(t1)), " vs "), show_type(t2))
  end
  def show(({:arity_mismatch, name, n1, n2})) do
    Nova.Runtime.append(Nova.Runtime.append(Nova.Runtime.append(Nova.Runtime.append(Nova.Runtime.append("Arity mismatch for ", name), ": "), Prelude.show(n1)), " vs "), Prelude.show(n2))
  end
  def show(({:record_field_mismatch, f})) do
    Nova.Runtime.append("Record field mismatch: ", f)
  end



  def show_type(({:ty_var, v})) do
    Nova.Runtime.append(Nova.Runtime.append(Nova.Runtime.append(v.name, "["), Prelude.show(v.id)), "]")
  end

  def show_type(({:ty_con, tc})) do
    if (Nova.Array.length(tc.args) == 0) do
      tc.name
    else
      Nova.Runtime.append(Nova.Runtime.append(tc.name, " "), Nova.String.join_with(" ", (Prelude.map((&show_type_parens/1), tc.args))))
    end
  end

  def show_type(({:ty_record, r})) do
    
      field_entries = Nova.Array.from_foldable((Nova.Map.to_unfoldable(r.fields)))
      show_field = fn ({:tuple, name, ty}) -> Nova.Runtime.append(Nova.Runtime.append(name, " :: "), show_type(ty)) end
      field_strs = Prelude.map(show_field, (Nova.Array.take(8, field_entries)))
      suffix = if (Nova.Array.length(field_entries) > 8) do
        ", ..."
      else
        ""
      end
      Nova.Runtime.append(Nova.Runtime.append(Nova.Runtime.append("{ ", Nova.String.join_with(", ", field_strs)), suffix), " }")
  end

  def show_type(({:ty_app, f, arg})) do
    Nova.Runtime.append(Nova.Runtime.append(Nova.Runtime.append(Nova.Runtime.append("(", show_type(f)), " "), show_type(arg)), ")")
  end



  def show_type_parens(({:ty_var, _}) = t) do
    show_type(t)
  end

  def show_type_parens(({:ty_con, tc}) = t) do
    cond do
      ((Nova.Array.length(tc.args) == 0)) ->
        show_type(t)
    end
  end

  def show_type_parens(({:ty_record, _}) = t) do
    show_type(t)
  end

  def show_type_parens(t) do
    Nova.Runtime.append(Nova.Runtime.append("(", show_type(t)), ")")
  end



  def occurs(v, t) do
    Nova.Set.member(v.id, (Nova.Compiler.Types.free_type_vars(t)))
  end



  def bind_var(v, t) do
    
      is_same_var = fn tv -> fn ty -> case ty do
        {:ty_var, tv2} -> (tv.id == tv2.id)
        _ -> false
      end end end
      if is_same_var.(v).(t) do
  {:right, Nova.Compiler.Types.empty_subst()}
else
  if occurs(v, t) do
    {:left, ({:occurs_check, v, t})}
  else
    {:right, (Nova.Compiler.Types.single_subst(v, t))}
  end
end
  end



  def strip_module_prefix(name) do
    case Nova.String.last_index_of((Nova.String.pattern(".")), name) do
      {:just, idx} -> Nova.String.drop(((idx + 1)), name)
      :nothing -> name
    end
  end



  def are_equivalent_types(n1, n2) do
    cond do
      ((n1 == n2)) ->
        true
      ((strip_module_prefix(n1) == strip_module_prefix(n2))) ->
        true
      (((n1 == "List") and (n2 == "Array"))) ->
        true
      (((n1 == "Array") and (n2 == "List"))) ->
        true
      (((n1 == "Number") and (n2 == "Int"))) ->
        true
      (((n1 == "Int") and (n2 == "Number"))) ->
        true
      (true) ->
        false
    end
  end



  def is_record_type_alias_in_map(alias_map, name) do
    
      index_of = fn p -> fn s -> Nova.String.last_index_of(p, s) end end
      case Nova.Map.lookup(name, alias_map) do
  {:just, ({:ty_record, _})} -> true
  {:just, _} -> false
  :nothing -> 
      unqualified_name = case index_of.((Nova.String.pattern("."))).(name) do
        {:just, idx} -> Nova.String.drop(((idx + 1)), name)
        :nothing -> name
      end
      if (unqualified_name != name) do
  case Nova.Map.lookup(unqualified_name, alias_map) do
    {:just, ({:ty_record, _})} -> true
    _ -> false
  end
else
  false
end
end
  end

  # @type type_alias_map :: map._map()(string())(type())



  def lookup_record_alias(alias_map, name) do
    
      index_of = fn p -> fn s -> Nova.String.last_index_of(p, s) end end
      case Nova.Map.lookup(name, alias_map) do
  {:just, ({:ty_record, r})} -> {:just, r}
  {:just, _} -> :nothing
  :nothing -> 
      unqualified_name = case index_of.((Nova.String.pattern("."))).(name) do
        {:just, idx} -> Nova.String.drop(((idx + 1)), name)
        :nothing -> name
      end
      if (unqualified_name != name) do
  case Nova.Map.lookup(unqualified_name, alias_map) do
    {:just, ({:ty_record, r})} -> {:just, r}
    _ -> :nothing
  end
else
  :nothing
end
end
  end



  def unify_with_aliases(aliases, ({:ty_var, v}), t) do
    bind_var(v, t)
  end

  def unify_with_aliases(aliases, t, ({:ty_var, v})) do
    bind_var(v, t)
  end

  def unify_with_aliases(aliases, ({:ty_con, c1}), ({:ty_con, c2})) do
    cond do
      (not((are_equivalent_types(c1.name, c2.name)))) ->
        {:left, ({:type_mismatch, ({:ty_con, c1}), ({:ty_con, c2})})}
      ((Data.Array.length(c1.args) != Data.Array.length(c2.args))) ->
        {:left, ({:arity_mismatch, c1.name, (Data.Array.length(c1.args)), (Data.Array.length(c2.args))})}
      (true) ->
        unify_many_with_aliases(aliases, c1.args, c2.args)
    end
  end

  def unify_with_aliases(aliases, ({:ty_con, c}), ({:ty_record, r})) do
    cond do
      ((Data.Array.length(c.args) == 0)) ->
        case lookup_record_alias(aliases, c.name) do
  {:just, alias_record} -> unify_records_with_aliases(aliases, alias_record, r)
  :nothing -> {:left, ({:type_mismatch, ({:ty_con, c}), ({:ty_record, r})})}
end
      (true) ->
        {:left, ({:type_mismatch, ({:ty_con, c}), ({:ty_record, r})})}
    end
  end

  def unify_with_aliases(aliases, ({:ty_record, r}), ({:ty_con, c})) do
    cond do
      ((Data.Array.length(c.args) == 0)) ->
        case lookup_record_alias(aliases, c.name) do
  {:just, alias_record} -> unify_records_with_aliases(aliases, alias_record, r)
  :nothing -> {:left, ({:type_mismatch, ({:ty_record, r}), ({:ty_con, c})})}
end
      (true) ->
        {:left, ({:type_mismatch, ({:ty_record, r}), ({:ty_con, c})})}
    end
  end

  def unify_with_aliases(aliases, ({:ty_record, r1}), ({:ty_record, r2})) do
    unify_records_with_aliases(aliases, r1, r2)
  end

  def unify_with_aliases(aliases, ({:ty_app, f1, a1}), ({:ty_app, f2, a2})) do
      Nova.Runtime.bind(unify_with_aliases(aliases, f1, f2), fn s1 ->
    Nova.Runtime.bind(unify_with_aliases(aliases, (Nova.Compiler.Types.apply_subst(s1, a1)), (Nova.Compiler.Types.apply_subst(s1, a2))), fn s2 ->
      Prelude.pure((Nova.Compiler.Types.compose_subst(s2, s1)))
    end)
  end)
  end

  def unify_with_aliases(aliases, ({:ty_app, f, a}), ({:ty_con, c})) do
    cond do
      ((Data.Array.length(c.args) > 0)) ->
        
  head_ty_con = {:ty_con, %{name: c.name, args: Nova.Array.take(((Data.Array.length(c.args) - 1)), c.args)}}
  last_arg = case Nova.Array.last(c.args) do
    {:just, arg} -> arg
    :nothing -> {:ty_con, %{name: "Unit", args: []}}
  end
  Nova.Runtime.bind(unify_with_aliases(aliases, f, head_ty_con), fn s1 ->
  Nova.Runtime.bind(unify_with_aliases(aliases, (Nova.Compiler.Types.apply_subst(s1, a)), (Nova.Compiler.Types.apply_subst(s1, last_arg))), fn s2 ->
    Prelude.pure((Nova.Compiler.Types.compose_subst(s2, s1)))
  end)
end)
      (true) ->
        {:left, ({:type_mismatch, (Nova.Compiler.Types.mk_ty_app(f, a)), ({:ty_con, c})})}
    end
  end

  def unify_with_aliases(aliases, ({:ty_con, c}), ({:ty_app, f, a})) do
    cond do
      ((Data.Array.length(c.args) > 0)) ->
        
  head_ty_con = {:ty_con, %{name: c.name, args: Nova.Array.take(((Data.Array.length(c.args) - 1)), c.args)}}
  last_arg = case Nova.Array.last(c.args) do
    {:just, arg} -> arg
    :nothing -> {:ty_con, %{name: "Unit", args: []}}
  end
  Nova.Runtime.bind(unify_with_aliases(aliases, f, head_ty_con), fn s1 ->
  Nova.Runtime.bind(unify_with_aliases(aliases, (Nova.Compiler.Types.apply_subst(s1, a)), (Nova.Compiler.Types.apply_subst(s1, last_arg))), fn s2 ->
    Prelude.pure((Nova.Compiler.Types.compose_subst(s2, s1)))
  end)
end)
      (true) ->
        {:left, ({:type_mismatch, ({:ty_con, c}), (Nova.Compiler.Types.mk_ty_app(f, a))})}
    end
  end

  def unify_with_aliases(aliases, ({:ty_app, f, a}), ({:ty_var, v})) do
    bind_var(v, (Nova.Compiler.Types.mk_ty_app(f, a)))
  end

  def unify_with_aliases(aliases, ({:ty_var, v}), ({:ty_app, f, a})) do
    bind_var(v, (Nova.Compiler.Types.mk_ty_app(f, a)))
  end

  def unify_with_aliases(aliases, t1, t2) do
    {:left, ({:type_mismatch, t1, t2})}
  end



  def unify() do
    fn auto_p0 -> fn auto_p1 -> unify_with_aliases(Nova.Map.empty, auto_p0, auto_p1) end end
  end



  def unify_step_with_aliases(aliases, sub, ({:tuple, t1, t2})) do
      Nova.Runtime.bind(unify_with_aliases(aliases, (Nova.Compiler.Types.apply_subst(sub, t1)), (Nova.Compiler.Types.apply_subst(sub, t2))), fn s ->
    Prelude.pure((Nova.Compiler.Types.compose_subst(s, sub)))
  end)
  end



  def unify_many_with_aliases(aliases, ts1, ts2) do
    Data.Foldable.fold_m((fn auto_p0 -> fn auto_p1 -> unify_step_with_aliases(aliases, auto_p0, auto_p1) end end), Nova.Compiler.Types.empty_subst(), (Data.Array.zip(ts1, ts2)))
  end



  def unify_field_with_aliases(aliases, fields1, fields2, sub, k) do
    case {:tuple, (Nova.Map.lookup(k, fields1)), (Nova.Map.lookup(k, fields2))} do
      {:tuple, ({:just, t1}), ({:just, t2})} -> case unify_with_aliases(aliases, (Nova.Compiler.Types.apply_subst(sub, t1)), (Nova.Compiler.Types.apply_subst(sub, t2))) do
          {:left, err} -> {:left, err}
          {:right, s} -> {:right, (Nova.Compiler.Types.compose_subst(s, sub))}
        end
      _ -> {:right, sub}
    end
  end



  def unify_records_with_aliases(aliases, r1, r2) do
    
      keys1 = Nova.Map.keys(r1.fields)
      Data.Foldable.fold_m((fn auto_p0 -> fn auto_p1 -> unify_field_with_aliases(aliases, r1.fields, r2.fields, auto_p0, auto_p1) end end), Nova.Compiler.Types.empty_subst(), keys1)
  end



  def unify_step() do
    fn auto_p0 -> fn auto_p1 -> unify_step_with_aliases(Nova.Map.empty, auto_p0, auto_p1) end end
  end



  def unify_many() do
    fn auto_p0 -> fn auto_p1 -> unify_many_with_aliases(Nova.Map.empty, auto_p0, auto_p1) end end
  end



  def unify_field() do
    fn auto_p0 -> fn auto_p1 -> fn auto_p2 -> fn auto_p3 -> unify_field_with_aliases(Nova.Map.empty, auto_p0, auto_p1, auto_p2, auto_p3) end end end end
  end



  def unify_records() do
    fn auto_p0 -> fn auto_p1 -> unify_records_with_aliases(Nova.Map.empty, auto_p0, auto_p1) end end
  end
end
