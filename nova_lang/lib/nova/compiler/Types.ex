# This file was auto-generated by the Nova compiler.
# Do not edit this file manually.

defmodule Nova.Compiler.Types do
  # import Prelude

  # import Data.Map

  # import Data.Map

  # import Data.Set

  # import Data.Set

  # import Data.Maybe

  # import Data.Tuple

  # import Data.Foldable

  # import Data.Array

  # import Data.String

  # import Nova.Compiler.Ast

  # @type tvar :: %{id: int(), name: string()}



  def mk_tvar(id, name) do
    %{id: id, name: name}
  end

  # @type tcon :: %{name: string(), args: array()(type())}



  def normalize_type_name(name) do
    case Nova.String.last_index_of((Nova.String.pattern(".")), name) do
      :nothing -> name
      {:just, idx} -> Nova.String.drop(((idx + 1)), name)
    end
  end



  def mk_tcon(name, args) do
    %{name: normalize_type_name(name), args: args}
  end



  def mk_tcon0(name) do
    %{name: normalize_type_name(name), args: []}
  end

  # @type record :: %{fields: map()(string())(type()), row: maybe()(tvar())}

  # Data type: Type
  def ty_var(arg0), do: {:ty_var, arg0}
  def ty_con(arg0), do: {:ty_con, arg0}
  def ty_record(arg0), do: {:ty_record, arg0}
  def ty_app(arg0, arg1), do: {:ty_app, arg0, arg1}

  # derive instance Eq type()



  def t_int() do
    {:ty_con, (mk_tcon0("Int"))}
  end



  def t_string() do
    {:ty_con, (mk_tcon0("String"))}
  end



  def t_char() do
    {:ty_con, (mk_tcon0("Char"))}
  end



  def t_bool() do
    {:ty_con, (mk_tcon0("Bool"))}
  end



  def t_list(el) do
    {:ty_con, (mk_tcon("List", [el]))}
  end



  def t_array(el) do
    {:ty_con, (mk_tcon("Array", [el]))}
  end



  def t_arrow(a, b) do
    {:ty_con, (mk_tcon("Fun", [a, b]))}
  end



  def t_maybe(t) do
    {:ty_con, (mk_tcon("Maybe", [t]))}
  end



  def t_either(l, r) do
    {:ty_con, (mk_tcon("Either", [l, r]))}
  end



  def t_map(k, v) do
    {:ty_con, (mk_tcon("Map", [k, v]))}
  end



  def t_set(t) do
    {:ty_con, (mk_tcon("Set", [t]))}
  end



  def t_unit() do
    {:ty_con, (mk_tcon0("Unit"))}
  end



  def t_ordering() do
    {:ty_con, (mk_tcon0("Ordering"))}
  end



  def t_number() do
    {:ty_con, (mk_tcon0("Number"))}
  end



  def t_token_type() do
    {:ty_con, (mk_tcon0("TokenType"))}
  end



  def t_tuple(ts) do
    
      n = Nova.Array.length(ts)
      name = if (n == 2) do
        "Tuple"
      else
        Nova.Runtime.append("Tuple", Prelude.show(n))
      end
      {:ty_con, %{name: name, args: ts}}
  end

  # @type subst :: map()(int())(type())



  def empty_subst() do
    Nova.Map.empty
  end



  def lookup_subst(sub, v) do
    case Nova.Map.lookup(v.id, sub) do
      {:just, t} -> t
      :nothing -> {:ty_var, v}
    end
  end



  def single_subst(v, t) do
    Nova.Map.singleton(v.id, t)
  end



  def apply_subst(sub, ({:ty_var, v})) do
    lookup_subst(sub, v)
  end

  def apply_subst(sub, ({:ty_con, c})) do
    {:ty_con, (%{c | args: Prelude.map((fn auto_p0 -> apply_subst(sub, auto_p0) end), c.args)})}
  end

  def apply_subst(sub, ({:ty_record, r})) do
    {:ty_record, (%{r | fields: Prelude.map((fn auto_p0 -> apply_subst(sub, auto_p0) end), r.fields)})}
  end

  def apply_subst(sub, ({:ty_app, f, arg})) do
    {:ty_app, (apply_subst(sub, f)), (apply_subst(sub, arg))}
  end



  def compose_subst(s1, s2) do
    Nova.Map.union(s1, (Prelude.map((fn auto_p0 -> apply_subst(s1, auto_p0) end), s2)))
  end

  # @type scheme :: %{vars: array()(tvar()), ty: type()}



  def mk_scheme(vars, ty) do
    %{vars: vars, ty: ty}
  end



  def free_type_vars(({:ty_var, v})) do
    Nova.Set.singleton(v.id)
  end

  def free_type_vars(({:ty_con, c})) do
    Data.Foldable.foldl((fn acc -> fn t -> Nova.Set.union(acc, (free_type_vars(t))) end end), Nova.Set.empty, c.args)
  end

  def free_type_vars(({:ty_record, r})) do
    Data.Foldable.foldl((fn acc -> fn t -> Nova.Set.union(acc, (free_type_vars(t))) end end), Nova.Set.empty, (Nova.Map.values(r.fields)))
  end

  def free_type_vars(({:ty_app, f, arg})) do
    Nova.Set.union((free_type_vars(f)), (free_type_vars(arg)))
  end



  def free_type_vars_scheme(s) do
    
      bound_ids = Nova.Set.from_foldable((Prelude.map(& &1.id, s.vars)))
      Nova.Set.difference((free_type_vars(s.ty)), bound_ids)
  end

  # @type env :: %{bindings: map()(string())(scheme()), counter: int(), registry_layer: maybe()(int()), namespace: maybe()(string()), type_aliases: map()(string())(type())}

  # @type typed_module :: %{mod_: module(), env: env()}



  def mk_typed_module(mod_, env) do
    %{mod_: mod_, env: env}
  end



  def typed_module_to_module(tm) do
    tm.mod_
  end



  def typed_module_env(tm) do
    tm.env
  end



  def empty_env() do
    %{bindings: builtin_prelude(), counter: 0, registry_layer: :nothing, namespace: :nothing, type_aliases: Nova.Map.empty}
  end



  def extend_env(env, name, scheme) do
    %{env | bindings: Nova.Map.insert(name, scheme, env.bindings)}
  end



  def extend_type_alias(env, name, ty) do
    %{env | type_aliases: Nova.Map.insert(name, ty, env.type_aliases)}
  end



  def lookup_type_alias(env, name) do
    Nova.Map.lookup(name, env.type_aliases)
  end



  def lookup_env(env, name) do
    Nova.Map.lookup(name, env.bindings)
  end



  def apply_subst_to_env(sub, env) do
    
      apply_to_scheme = fn s -> %{s | ty: apply_subst(sub, s.ty)} end
      %{env | bindings: Prelude.map(apply_to_scheme, env.bindings)}
  end



  def fresh_var(env, hint) do
    
      v = mk_tvar(env.counter, (Nova.Runtime.append(hint, Prelude.show(env.counter))))
      env_prime = %{env | counter: (env.counter + 1)}
      {:tuple, v, env_prime}
  end



  def free_type_vars_env(env) do
    Data.Foldable.foldl((fn acc -> fn s -> Nova.Set.union(acc, (free_type_vars_scheme(s))) end end), Nova.Set.empty, (Nova.Map.values(env.bindings)))
  end



  def builtin_prelude() do
    
      a = mk_tvar((-1), "a")
      b = mk_tvar((-2), "b")
      c = mk_tvar((-3), "c")
      d = mk_tvar((-6), "d")
      e = mk_tvar((-7), "e")
      Nova.Map.from_foldable([{:tuple, "Int", (mk_scheme([], t_int()))}, {:tuple, "String", (mk_scheme([], t_string()))}, {:tuple, "Char", (mk_scheme([], t_char()))}, {:tuple, "Bool", (mk_scheme([], t_bool()))}, {:tuple, "Boolean", (mk_scheme([], t_bool()))}, {:tuple, "True", (mk_scheme([], t_bool()))}, {:tuple, "False", (mk_scheme([], t_bool()))}, {:tuple, "true", (mk_scheme([], t_bool()))}, {:tuple, "false", (mk_scheme([], t_bool()))}, {:tuple, "Array", (mk_scheme([a], (t_array(({:ty_var, a})))))}, {:tuple, "List", (mk_scheme([a], (t_list(({:ty_var, a})))))}, {:tuple, "Cons", (mk_scheme([a], (t_arrow(({:ty_var, a}), (t_arrow((t_list(({:ty_var, a}))), (t_list(({:ty_var, a})))))))))}, {:tuple, "Nil", (mk_scheme([a], (t_list(({:ty_var, a})))))}, {:tuple, "Maybe", (mk_scheme([a], ({:ty_con, (mk_tcon("Maybe", [{:ty_var, a}]))})))}, {:tuple, "Either", (mk_scheme([a, b], ({:ty_con, (mk_tcon("Either", [{:ty_var, a}, {:ty_var, b}]))})))}, {:tuple, "+", (mk_scheme([], (t_arrow(t_int(), (t_arrow(t_int(), t_int()))))))}, {:tuple, "-", (mk_scheme([], (t_arrow(t_int(), (t_arrow(t_int(), t_int()))))))}, {:tuple, "*", (mk_scheme([], (t_arrow(t_int(), (t_arrow(t_int(), t_int()))))))}, {:tuple, "/", (mk_scheme([], (t_arrow(t_int(), (t_arrow(t_int(), t_int()))))))}, {:tuple, "mod", (mk_scheme([], (t_arrow(t_int(), (t_arrow(t_int(), t_int()))))))}, {:tuple, "negate", (mk_scheme([a], (t_arrow(({:ty_var, a}), ({:ty_var, a})))))}, {:tuple, "top", (mk_scheme([], t_int()))}, {:tuple, "bottom", (mk_scheme([], t_int()))}, {:tuple, "<", (mk_scheme([a], (t_arrow(({:ty_var, a}), (t_arrow(({:ty_var, a}), t_bool()))))))}, {:tuple, ">", (mk_scheme([a], (t_arrow(({:ty_var, a}), (t_arrow(({:ty_var, a}), t_bool()))))))}, {:tuple, "<=", (mk_scheme([a], (t_arrow(({:ty_var, a}), (t_arrow(({:ty_var, a}), t_bool()))))))}, {:tuple, ">=", (mk_scheme([a], (t_arrow(({:ty_var, a}), (t_arrow(({:ty_var, a}), t_bool()))))))}, {:tuple, "==", (mk_scheme([a], (t_arrow(({:ty_var, a}), (t_arrow(({:ty_var, a}), t_bool()))))))}, {:tuple, "/=", (mk_scheme([a], (t_arrow(({:ty_var, a}), (t_arrow(({:ty_var, a}), t_bool()))))))}, {:tuple, "&&", (mk_scheme([], (t_arrow(t_bool(), (t_arrow(t_bool(), t_bool()))))))}, {:tuple, "||", (mk_scheme([], (t_arrow(t_bool(), (t_arrow(t_bool(), t_bool()))))))}, {:tuple, "not", (mk_scheme([], (t_arrow(t_bool(), t_bool()))))}, {:tuple, "otherwise", (mk_scheme([], t_bool()))}, {:tuple, "<>", (mk_scheme([a], (t_arrow(({:ty_var, a}), (t_arrow(({:ty_var, a}), ({:ty_var, a})))))))}, {:tuple, ":", (mk_scheme([a], (t_arrow(({:ty_var, a}), (t_arrow((t_array(({:ty_var, a}))), (t_array(({:ty_var, a})))))))))}, {:tuple, "++", (mk_scheme([a], (t_arrow((t_array(({:ty_var, a}))), (t_arrow((t_array(({:ty_var, a}))), (t_array(({:ty_var, a})))))))))}, {:tuple, "$", (mk_scheme([a, b], (t_arrow((t_arrow(({:ty_var, a}), ({:ty_var, b}))), (t_arrow(({:ty_var, a}), ({:ty_var, b})))))))}, {:tuple, ".", (mk_scheme([a, b, c], (t_arrow((t_arrow(({:ty_var, b}), ({:ty_var, c}))), (t_arrow((t_arrow(({:ty_var, a}), ({:ty_var, b}))), (t_arrow(({:ty_var, a}), ({:ty_var, c})))))))))}, {:tuple, "<<<", (mk_scheme([a, b, c], (t_arrow((t_arrow(({:ty_var, b}), ({:ty_var, c}))), (t_arrow((t_arrow(({:ty_var, a}), ({:ty_var, b}))), (t_arrow(({:ty_var, a}), ({:ty_var, c})))))))))}, {:tuple, ">>>", (mk_scheme([a, b, c], (t_arrow((t_arrow(({:ty_var, a}), ({:ty_var, b}))), (t_arrow((t_arrow(({:ty_var, b}), ({:ty_var, c}))), (t_arrow(({:ty_var, a}), ({:ty_var, c})))))))))}, {:tuple, "identity", (mk_scheme([a], (t_arrow(({:ty_var, a}), ({:ty_var, a})))))}, {:tuple, "const", (mk_scheme([a, b], (t_arrow(({:ty_var, a}), (t_arrow(({:ty_var, b}), ({:ty_var, a})))))))}, {:tuple, "#", (mk_scheme([a, b], (t_arrow(({:ty_var, a}), (t_arrow((t_arrow(({:ty_var, a}), ({:ty_var, b}))), ({:ty_var, b})))))))}, {:tuple, "Just", (mk_scheme([a], (t_arrow(({:ty_var, a}), (t_maybe(({:ty_var, a})))))))}, {:tuple, "Nothing", (mk_scheme([a], (t_maybe(({:ty_var, a})))))}, {:tuple, "maybe", (mk_scheme([a, b], (t_arrow(({:ty_var, b}), (t_arrow((t_arrow(({:ty_var, a}), ({:ty_var, b}))), (t_arrow((t_maybe(({:ty_var, a}))), ({:ty_var, b})))))))))}, {:tuple, "fromMaybe", (mk_scheme([a], (t_arrow(({:ty_var, a}), (t_arrow((t_maybe(({:ty_var, a}))), ({:ty_var, a})))))))}, {:tuple, "isJust", (mk_scheme([a], (t_arrow((t_maybe(({:ty_var, a}))), t_bool()))))}, {:tuple, "isNothing", (mk_scheme([a], (t_arrow((t_maybe(({:ty_var, a}))), t_bool()))))}, {:tuple, "Left", (mk_scheme([a, b], (t_arrow(({:ty_var, a}), (t_either(({:ty_var, a}), ({:ty_var, b})))))))}, {:tuple, "Right", (mk_scheme([a, b], (t_arrow(({:ty_var, b}), (t_either(({:ty_var, a}), ({:ty_var, b})))))))}, {:tuple, "either", (mk_scheme([a, b, c], (t_arrow((t_arrow(({:ty_var, a}), ({:ty_var, c}))), (t_arrow((t_arrow(({:ty_var, b}), ({:ty_var, c}))), (t_arrow((t_either(({:ty_var, a}), ({:ty_var, b}))), ({:ty_var, c})))))))))}, {:tuple, "pure", (mk_scheme([a, b], (t_arrow(({:ty_var, a}), ({:ty_var, b})))))}, {:tuple, "Tuple", (mk_scheme([a, b], (t_arrow(({:ty_var, a}), (t_arrow(({:ty_var, b}), (t_tuple([{:ty_var, a}, {:ty_var, b}]))))))))}, {:tuple, "Tuple2", (mk_scheme([a, b], (t_arrow(({:ty_var, a}), (t_arrow(({:ty_var, b}), (t_tuple([{:ty_var, a}, {:ty_var, b}]))))))))}, {:tuple, "Tuple3", (mk_scheme([a, b, c], (t_arrow(({:ty_var, a}), (t_arrow(({:ty_var, b}), (t_arrow(({:ty_var, c}), (t_tuple([{:ty_var, a}, {:ty_var, b}, {:ty_var, c}]))))))))))}, {:tuple, "Tuple4", (mk_scheme([a, b, c, d], (t_arrow(({:ty_var, a}), (t_arrow(({:ty_var, b}), (t_arrow(({:ty_var, c}), (t_arrow(({:ty_var, d}), (t_tuple([{:ty_var, a}, {:ty_var, b}, {:ty_var, c}, {:ty_var, d}]))))))))))))}, {:tuple, "Tuple5", (mk_scheme([a, b, c, d, e], (t_arrow(({:ty_var, a}), (t_arrow(({:ty_var, b}), (t_arrow(({:ty_var, c}), (t_arrow(({:ty_var, d}), (t_arrow(({:ty_var, e}), (t_tuple([{:ty_var, a}, {:ty_var, b}, {:ty_var, c}, {:ty_var, d}, {:ty_var, e}]))))))))))))))}, {:tuple, "fst", (mk_scheme([a, b], (t_arrow((t_tuple([{:ty_var, a}, {:ty_var, b}])), ({:ty_var, a})))))}, {:tuple, "snd", (mk_scheme([a, b], (t_arrow((t_tuple([{:ty_var, a}, {:ty_var, b}])), ({:ty_var, b})))))}, {:tuple, "show", (mk_scheme([a], (t_arrow(({:ty_var, a}), t_string()))))}, {:tuple, "log", (mk_scheme([], (t_arrow(t_string(), t_unit()))))}, {:tuple, "__guarded__", (mk_scheme([a], ({:ty_var, a})))}, {:tuple, "_", (mk_scheme([a], ({:ty_var, a})))}])
  end



  def t_subst() do
    t_map(t_int(), t_type())
  end



  def t_env() do
    {:ty_record, %{fields: Nova.Map.from_foldable([{:tuple, "bindings", (t_map(t_string(), t_scheme()))}, {:tuple, "counter", t_int()}, {:tuple, "registryLayer", (t_maybe(t_int()))}, {:tuple, "namespace", (t_maybe(t_string()))}]), row: :nothing}}
  end



  def t_scheme() do
    {:ty_record, %{fields: Nova.Map.from_foldable([{:tuple, "vars", (t_array(t_tvar()))}, {:tuple, "ty", t_type()}]), row: :nothing}}
  end



  def t_type() do
    {:ty_con, (mk_tcon0("Type"))}
  end



  def t_tvar() do
    {:ty_record, %{fields: Nova.Map.from_foldable([{:tuple, "id", t_int()}, {:tuple, "name", t_string()}]), row: :nothing}}
  end



  def t_tcon() do
    t_tcon_record()
  end



  def t_tcon_record() do
    {:ty_record, %{fields: Nova.Map.from_foldable([{:tuple, "name", t_string()}, {:tuple, "args", (t_array(t_type()))}]), row: :nothing}}
  end



  def t_record() do
    {:ty_record, %{fields: Nova.Map.from_foldable([{:tuple, "fields", (t_map(t_string(), t_type()))}, {:tuple, "row", (t_maybe(t_tvar()))}]), row: :nothing}}
  end



  def t_type_info() do
    {:ty_record, %{fields: Nova.Map.from_foldable([{:tuple, "arity", t_int()}, {:tuple, "constructors", (t_array(t_string()))}]), row: :nothing}}
  end



  def t_type_alias_info() do
    {:ty_record, %{fields: Nova.Map.from_foldable([{:tuple, "params", (t_array(t_string()))}, {:tuple, "body", t_type_expr()}]), row: :nothing}}
  end



  def t_module_exports() do
    {:ty_record, %{fields: Nova.Map.from_foldable([{:tuple, "types", (t_map(t_string(), t_type_info()))}, {:tuple, "constructors", (t_map(t_string(), t_scheme()))}, {:tuple, "values", (t_map(t_string(), t_scheme()))}, {:tuple, "typeAliases", (t_map(t_string(), t_type_alias_info()))}]), row: :nothing}}
  end



  def t_module_registry() do
    t_map(t_string(), t_module_exports())
  end



  def t_module() do
    {:ty_con, (mk_tcon0("Module"))}
  end



  def t_typed_module() do
    {:ty_record, %{fields: Nova.Map.from_foldable([{:tuple, "mod", t_module()}, {:tuple, "env", t_env()}]), row: :nothing}}
  end



  def t_pattern() do
    {:ty_con, (mk_tcon0("Pattern"))}
  end



  def t_expr() do
    {:ty_con, (mk_tcon0("Expr"))}
  end



  def t_literal() do
    {:ty_con, (mk_tcon0("Literal"))}
  end



  def t_type_expr() do
    {:ty_con, (mk_tcon0("TypeExpr"))}
  end



  def t_let_bind() do
    {:ty_record, %{fields: Nova.Map.from_foldable([{:tuple, "pattern", t_pattern()}, {:tuple, "value", t_expr()}, {:tuple, "typeAnn", (t_maybe(t_type_expr()))}]), row: :nothing}}
  end



  def t_case_clause() do
    {:ty_record, %{fields: Nova.Map.from_foldable([{:tuple, "pattern", t_pattern()}, {:tuple, "guard", (t_maybe(t_expr()))}, {:tuple, "body", t_expr()}]), row: :nothing}}
  end



  def t_declaration() do
    {:ty_con, (mk_tcon0("Declaration"))}
  end



  def t_function_decl() do
    {:ty_record, %{fields: Nova.Map.from_foldable([{:tuple, "name", t_string()}, {:tuple, "parameters", (t_list(t_pattern()))}, {:tuple, "body", t_expr()}, {:tuple, "guards", (t_list(t_guarded_expr_rec()))}, {:tuple, "typeSignature", (t_maybe(t_type_sig_rec()))}]), row: :nothing}}
  end



  def t_guarded_expr_rec() do
    {:ty_record, %{fields: Nova.Map.from_foldable([{:tuple, "guards", (t_list(t_guard_clause()))}, {:tuple, "body", t_expr()}]), row: :nothing}}
  end



  def t_type_sig_rec() do
    {:ty_record, %{fields: Nova.Map.from_foldable([{:tuple, "name", t_string()}, {:tuple, "typeVars", (t_array(t_string()))}, {:tuple, "constraints", (t_array(t_constraint()))}, {:tuple, "ty", t_type_expr()}]), row: :nothing}}
  end



  def t_type_sig() do
    t_type_sig_rec()
  end



  def t_data_type() do
    {:ty_record, %{fields: Nova.Map.from_foldable([{:tuple, "name", t_string()}, {:tuple, "typeVars", (t_list(t_string()))}, {:tuple, "constructors", (t_list(t_data_constructor()))}]), row: :nothing}}
  end



  def t_data_constructor() do
    {:ty_record, %{fields: Nova.Map.from_foldable([{:tuple, "name", t_string()}, {:tuple, "fields", (t_list(t_data_field()))}, {:tuple, "isRecord", t_bool()}]), row: :nothing}}
  end



  def t_data_field() do
    {:ty_record, %{fields: Nova.Map.from_foldable([{:tuple, "label", t_string()}, {:tuple, "ty", t_type_expr()}]), row: :nothing}}
  end



  def t_type_alias() do
    {:ty_record, %{fields: Nova.Map.from_foldable([{:tuple, "name", t_string()}, {:tuple, "typeVars", (t_array(t_string()))}, {:tuple, "ty", t_type_expr()}]), row: :nothing}}
  end



  def t_module_decl() do
    {:ty_record, %{fields: Nova.Map.from_foldable([{:tuple, "name", t_string()}, {:tuple, "declarations", (t_list(t_declaration()))}]), row: :nothing}}
  end



  def t_import_decl() do
    {:ty_record, %{fields: Nova.Map.from_foldable([{:tuple, "moduleName", t_string()}, {:tuple, "alias", (t_maybe(t_string()))}, {:tuple, "items", (t_array(t_import_item()))}, {:tuple, "hiding", t_bool()}]), row: :nothing}}
  end



  def t_do_statement() do
    {:ty_con, (mk_tcon0("DoStatement"))}
  end



  def t_guarded_expr() do
    t_guarded_expr_rec()
  end



  def t_guard_clause() do
    {:ty_con, (mk_tcon0("GuardClause"))}
  end



  def t_type_class() do
    {:ty_record, %{fields: Nova.Map.from_foldable([{:tuple, "name", t_string()}, {:tuple, "typeVars", (t_array(t_string()))}, {:tuple, "methods", (t_array(t_type_sig()))}, {:tuple, "kind", (t_maybe(t_string()))}]), row: :nothing}}
  end



  def t_type_class_instance() do
    {:ty_record, %{fields: Nova.Map.from_foldable([{:tuple, "className", t_string()}, {:tuple, "ty", t_type_expr()}, {:tuple, "methods", (t_array(t_function_decl()))}, {:tuple, "derived", t_bool()}]), row: :nothing}}
  end



  def t_infix_decl() do
    {:ty_record, %{fields: Nova.Map.from_foldable([{:tuple, "associativity", t_string()}, {:tuple, "precedence", t_int()}, {:tuple, "operator", t_string()}]), row: :nothing}}
  end



  def t_constraint() do
    {:ty_record, %{fields: Nova.Map.from_foldable([{:tuple, "className", t_string()}, {:tuple, "types", (t_array(t_type_expr()))}]), row: :nothing}}
  end



  def t_import_item() do
    {:ty_con, (mk_tcon0("ImportItem"))}
  end



  def t_import_spec() do
    {:ty_con, (mk_tcon0("ImportSpec"))}
  end



  def t_associativity() do
    {:ty_con, (mk_tcon0("Associativity"))}
  end



  def t_foreign_import() do
    {:ty_record, %{fields: Nova.Map.from_foldable([{:tuple, "moduleName", t_string()}, {:tuple, "functionName", t_string()}, {:tuple, "ty", t_type_expr()}]), row: :nothing}}
  end



  def t_newtype_decl() do
    {:ty_record, %{fields: Nova.Map.from_foldable([{:tuple, "name", t_string()}, {:tuple, "typeVars", (t_array(t_string()))}, {:tuple, "constructor", t_string()}, {:tuple, "wrappedType", t_type_expr()}]), row: :nothing}}
  end



  def t_type_decl() do
    {:ty_record, %{fields: Nova.Map.from_foldable([{:tuple, "name", t_string()}, {:tuple, "ty", t_type_expr()}]), row: :nothing}}
  end



  def t_unify_error() do
    {:ty_con, (mk_tcon0("UnifyError"))}
  end



  def t_tcerror() do
    {:ty_con, (mk_tcon0("TCError"))}
  end



  def t_pat_result() do
    {:ty_record, %{fields: Nova.Map.from_foldable([{:tuple, "env", t_env()}, {:tuple, "sub", t_subst()}]), row: :nothing}}
  end



  def t_instantiate_result() do
    {:ty_record, %{fields: Nova.Map.from_foldable([{:tuple, "ty", t_type()}, {:tuple, "env", t_env()}]), row: :nothing}}
  end



  def t_infer_result() do
    {:ty_record, %{fields: Nova.Map.from_foldable([{:tuple, "ty", t_type()}, {:tuple, "env", t_env()}, {:tuple, "sub", t_subst()}]), row: :nothing}}
  end

  # @type type_alias_info :: %{params: array()(string()), body: type_expr()}



  def get_alias_info_params(info) do
    info.params
  end



  def get_alias_info_body(info) do
    info.body
  end

  # @type module_exports :: %{types: map()(string())(type_info()), constructors: map()(string())(scheme()), values: map()(string())(scheme()), type_aliases: map()(string())(type_alias_info()), expanded_type_aliases: map()(string())(type())}

  # @type type_info :: %{arity: int(), constructors: array()(string())}



  def empty_exports() do
    %{types: Nova.Map.empty, constructors: Nova.Map.empty, values: Nova.Map.empty, type_aliases: Nova.Map.empty, expanded_type_aliases: Nova.Map.empty}
  end



  def prelude_exports() do
    
      a = mk_tvar((-1), "a")
      b = mk_tvar((-2), "b")
      c = mk_tvar((-3), "c")
      d = mk_tvar((-6), "d")
      %{types: Nova.Map.from_foldable([{:tuple, "Boolean", %{arity: 0, constructors: []}}, {:tuple, "Int", %{arity: 0, constructors: []}}, {:tuple, "String", %{arity: 0, constructors: []}}, {:tuple, "Char", %{arity: 0, constructors: []}}, {:tuple, "Number", %{arity: 0, constructors: []}}, {:tuple, "Array", %{arity: 1, constructors: []}}, {:tuple, "Unit", %{arity: 0, constructors: ["Unit"]}}, {:tuple, "Ordering", %{arity: 0, constructors: ["LT", "EQ", "GT"]}}]), constructors: Nova.Map.from_foldable([{:tuple, "Unit", (mk_scheme([], t_unit()))}, {:tuple, "LT", (mk_scheme([], t_ordering()))}, {:tuple, "EQ", (mk_scheme([], t_ordering()))}, {:tuple, "GT", (mk_scheme([], t_ordering()))}]), values: Nova.Map.from_foldable([{:tuple, "map", (mk_scheme([a, b, c, d], (t_arrow((t_arrow(({:ty_var, a}), ({:ty_var, b}))), (t_arrow(({:ty_var, c}), ({:ty_var, d})))))))}, {:tuple, "<$>", (mk_scheme([a, b, c, d], (t_arrow((t_arrow(({:ty_var, a}), ({:ty_var, b}))), (t_arrow(({:ty_var, c}), ({:ty_var, d})))))))}, {:tuple, "pure", (mk_scheme([a, b], (t_arrow(({:ty_var, a}), ({:ty_var, b})))))}, {:tuple, "apply", (mk_scheme([a, b, c, d], (t_arrow(({:ty_var, a}), (t_arrow(({:ty_var, b}), ({:ty_var, c})))))))}, {:tuple, "applySecond", (mk_scheme([a, b], (t_arrow(({:ty_var, a}), (t_arrow(({:ty_var, b}), ({:ty_var, b})))))))}, {:tuple, "*>", (mk_scheme([a, b], (t_arrow(({:ty_var, a}), (t_arrow(({:ty_var, b}), ({:ty_var, b})))))))}, {:tuple, "applyFirst", (mk_scheme([a, b], (t_arrow(({:ty_var, a}), (t_arrow(({:ty_var, b}), ({:ty_var, a})))))))}, {:tuple, "<*", (mk_scheme([a, b], (t_arrow(({:ty_var, a}), (t_arrow(({:ty_var, b}), ({:ty_var, a})))))))}, {:tuple, "alt", (mk_scheme([a], (t_arrow(({:ty_var, a}), (t_arrow(({:ty_var, a}), ({:ty_var, a})))))))}, {:tuple, "bind", (mk_scheme([a, b, c], (t_arrow(({:ty_var, a}), (t_arrow((t_arrow(({:ty_var, b}), ({:ty_var, c}))), ({:ty_var, c})))))))}, {:tuple, "identity", (mk_scheme([a], (t_arrow(({:ty_var, a}), ({:ty_var, a})))))}, {:tuple, "const", (mk_scheme([a, b], (t_arrow(({:ty_var, a}), (t_arrow(({:ty_var, b}), ({:ty_var, a})))))))}, {:tuple, "flip", (mk_scheme([a, b, c], (t_arrow((t_arrow(({:ty_var, a}), (t_arrow(({:ty_var, b}), ({:ty_var, c}))))), (t_arrow(({:ty_var, b}), (t_arrow(({:ty_var, a}), ({:ty_var, c})))))))))}, {:tuple, "compose", (mk_scheme([a, b, c], (t_arrow((t_arrow(({:ty_var, b}), ({:ty_var, c}))), (t_arrow((t_arrow(({:ty_var, a}), ({:ty_var, b}))), (t_arrow(({:ty_var, a}), ({:ty_var, c})))))))))}, {:tuple, "$", (mk_scheme([a, b], (t_arrow((t_arrow(({:ty_var, a}), ({:ty_var, b}))), (t_arrow(({:ty_var, a}), ({:ty_var, b})))))))}, {:tuple, "#", (mk_scheme([a, b], (t_arrow(({:ty_var, a}), (t_arrow((t_arrow(({:ty_var, a}), ({:ty_var, b}))), ({:ty_var, b})))))))}, {:tuple, "show", (mk_scheme([a], (t_arrow(({:ty_var, a}), t_string()))))}, {:tuple, "eq", (mk_scheme([a], (t_arrow(({:ty_var, a}), (t_arrow(({:ty_var, a}), t_bool()))))))}, {:tuple, "==", (mk_scheme([a], (t_arrow(({:ty_var, a}), (t_arrow(({:ty_var, a}), t_bool()))))))}, {:tuple, "/=", (mk_scheme([a], (t_arrow(({:ty_var, a}), (t_arrow(({:ty_var, a}), t_bool()))))))}, {:tuple, "compare", (mk_scheme([a], (t_arrow(({:ty_var, a}), (t_arrow(({:ty_var, a}), t_ordering()))))))}, {:tuple, "<", (mk_scheme([a], (t_arrow(({:ty_var, a}), (t_arrow(({:ty_var, a}), t_bool()))))))}, {:tuple, ">", (mk_scheme([a], (t_arrow(({:ty_var, a}), (t_arrow(({:ty_var, a}), t_bool()))))))}, {:tuple, "<=", (mk_scheme([a], (t_arrow(({:ty_var, a}), (t_arrow(({:ty_var, a}), t_bool()))))))}, {:tuple, ">=", (mk_scheme([a], (t_arrow(({:ty_var, a}), (t_arrow(({:ty_var, a}), t_bool()))))))}, {:tuple, "append", (mk_scheme([a], (t_arrow(({:ty_var, a}), (t_arrow(({:ty_var, a}), ({:ty_var, a})))))))}, {:tuple, "<>", (mk_scheme([a], (t_arrow(({:ty_var, a}), (t_arrow(({:ty_var, a}), ({:ty_var, a})))))))}, {:tuple, "mempty", (mk_scheme([a], ({:ty_var, a})))}, {:tuple, "add", (mk_scheme([], (t_arrow(t_int(), (t_arrow(t_int(), t_int()))))))}, {:tuple, "+", (mk_scheme([], (t_arrow(t_int(), (t_arrow(t_int(), t_int()))))))}, {:tuple, "mul", (mk_scheme([], (t_arrow(t_int(), (t_arrow(t_int(), t_int()))))))}, {:tuple, "*", (mk_scheme([], (t_arrow(t_int(), (t_arrow(t_int(), t_int()))))))}, {:tuple, "sub", (mk_scheme([], (t_arrow(t_int(), (t_arrow(t_int(), t_int()))))))}, {:tuple, "-", (mk_scheme([], (t_arrow(t_int(), (t_arrow(t_int(), t_int()))))))}, {:tuple, "negate", (mk_scheme([a], (t_arrow(({:ty_var, a}), ({:ty_var, a})))))}, {:tuple, "div", (mk_scheme([], (t_arrow(t_int(), (t_arrow(t_int(), t_int()))))))}, {:tuple, "/", (mk_scheme([], (t_arrow(t_int(), (t_arrow(t_int(), t_int()))))))}, {:tuple, "mod", (mk_scheme([], (t_arrow(t_int(), (t_arrow(t_int(), t_int()))))))}, {:tuple, "not", (mk_scheme([], (t_arrow(t_bool(), t_bool()))))}, {:tuple, "conj", (mk_scheme([], (t_arrow(t_bool(), (t_arrow(t_bool(), t_bool()))))))}, {:tuple, "&&", (mk_scheme([], (t_arrow(t_bool(), (t_arrow(t_bool(), t_bool()))))))}, {:tuple, "disj", (mk_scheme([], (t_arrow(t_bool(), (t_arrow(t_bool(), t_bool()))))))}, {:tuple, "||", (mk_scheme([], (t_arrow(t_bool(), (t_arrow(t_bool(), t_bool()))))))}, {:tuple, "top", (mk_scheme([], t_int()))}, {:tuple, "bottom", (mk_scheme([], t_int()))}, {:tuple, "foldl", (mk_scheme([a, b], (t_arrow((t_arrow(({:ty_var, b}), (t_arrow(({:ty_var, a}), ({:ty_var, b}))))), (t_arrow(({:ty_var, b}), (t_arrow((t_list(({:ty_var, a}))), ({:ty_var, b})))))))))}, {:tuple, "foldr", (mk_scheme([a, b, c], (t_arrow((t_arrow(({:ty_var, a}), (t_arrow(({:ty_var, b}), ({:ty_var, b}))))), (t_arrow(({:ty_var, b}), (t_arrow(({:ty_var, c}), ({:ty_var, b})))))))))}, {:tuple, "fst", (mk_scheme([a, b], (t_arrow((t_tuple([{:ty_var, a}, {:ty_var, b}])), ({:ty_var, a})))))}, {:tuple, "snd", (mk_scheme([a, b], (t_arrow((t_tuple([{:ty_var, a}, {:ty_var, b}])), ({:ty_var, b})))))}, {:tuple, "fromMaybe", (mk_scheme([a], (t_arrow(({:ty_var, a}), (t_arrow((t_maybe(({:ty_var, a}))), ({:ty_var, a})))))))}, {:tuple, "maybe", (mk_scheme([a, b], (t_arrow(({:ty_var, b}), (t_arrow((t_arrow(({:ty_var, a}), ({:ty_var, b}))), (t_arrow((t_maybe(({:ty_var, a}))), ({:ty_var, b})))))))))}, {:tuple, "isJust", (mk_scheme([a], (t_arrow((t_maybe(({:ty_var, a}))), t_bool()))))}, {:tuple, "isNothing", (mk_scheme([a], (t_arrow((t_maybe(({:ty_var, a}))), t_bool()))))}, {:tuple, "length", (mk_scheme([a], (t_arrow(({:ty_var, a}), t_int()))))}, {:tuple, "head", (mk_scheme([a], (t_arrow((t_array(({:ty_var, a}))), (t_maybe(({:ty_var, a})))))))}, {:tuple, "tail", (mk_scheme([a], (t_arrow((t_array(({:ty_var, a}))), (t_maybe((t_array(({:ty_var, a})))))))))}, {:tuple, "null", (mk_scheme([a], (t_arrow(({:ty_var, a}), t_bool()))))}, {:tuple, "reverse", (mk_scheme([a], (t_arrow((t_array(({:ty_var, a}))), (t_array(({:ty_var, a})))))))}, {:tuple, "concat", (mk_scheme([a], (t_arrow((t_array((t_array(({:ty_var, a}))))), (t_array(({:ty_var, a})))))))}, {:tuple, "filter", (mk_scheme([a], (t_arrow((t_arrow(({:ty_var, a}), t_bool())), (t_arrow((t_array(({:ty_var, a}))), (t_array(({:ty_var, a})))))))))}, {:tuple, "take", (mk_scheme([a], (t_arrow(t_int(), (t_arrow((t_array(({:ty_var, a}))), (t_array(({:ty_var, a})))))))))}, {:tuple, "drop", (mk_scheme([a], (t_arrow(t_int(), (t_arrow((t_array(({:ty_var, a}))), (t_array(({:ty_var, a})))))))))}, {:tuple, "elem", (mk_scheme([a], (t_arrow(({:ty_var, a}), (t_arrow((t_array(({:ty_var, a}))), t_bool()))))))}, {:tuple, "find", (mk_scheme([a], (t_arrow((t_arrow(({:ty_var, a}), t_bool())), (t_arrow((t_array(({:ty_var, a}))), (t_maybe(({:ty_var, a})))))))))}, {:tuple, "findIndex", (mk_scheme([a], (t_arrow((t_arrow(({:ty_var, a}), t_bool())), (t_arrow((t_array(({:ty_var, a}))), (t_maybe(t_int()))))))))}, {:tuple, "cons", (mk_scheme([a], (t_arrow(({:ty_var, a}), (t_arrow((t_array(({:ty_var, a}))), (t_array(({:ty_var, a})))))))))}, {:tuple, "snoc", (mk_scheme([a], (t_arrow((t_array(({:ty_var, a}))), (t_arrow(({:ty_var, a}), (t_array(({:ty_var, a})))))))))}, {:tuple, "singleton", (mk_scheme([a], (t_arrow(({:ty_var, a}), (t_array(({:ty_var, a})))))))}, {:tuple, "empty", (mk_scheme([a], (t_array(({:ty_var, a})))))}, {:tuple, "intercalate", (mk_scheme([a], (t_arrow(({:ty_var, a}), (t_arrow((t_array(({:ty_var, a}))), ({:ty_var, a})))))))}, {:tuple, "replicate", (mk_scheme([a], (t_arrow(t_int(), (t_arrow(({:ty_var, a}), (t_array(({:ty_var, a})))))))))}, {:tuple, "concatMap", (mk_scheme([a, b], (t_arrow((t_arrow(({:ty_var, a}), (t_array(({:ty_var, b}))))), (t_arrow((t_array(({:ty_var, a}))), (t_array(({:ty_var, b})))))))))}, {:tuple, "any", (mk_scheme([a], (t_arrow((t_arrow(({:ty_var, a}), t_bool())), (t_arrow((t_array(({:ty_var, a}))), t_bool()))))))}, {:tuple, "all", (mk_scheme([a], (t_arrow((t_arrow(({:ty_var, a}), t_bool())), (t_arrow((t_array(({:ty_var, a}))), t_bool()))))))}, {:tuple, "zipWith", (mk_scheme([a, b, c], (t_arrow((t_arrow(({:ty_var, a}), (t_arrow(({:ty_var, b}), ({:ty_var, c}))))), (t_arrow((t_array(({:ty_var, a}))), (t_arrow((t_array(({:ty_var, b}))), (t_array(({:ty_var, c})))))))))))}, {:tuple, "zip", (mk_scheme([a, b], (t_arrow((t_array(({:ty_var, a}))), (t_arrow((t_array(({:ty_var, b}))), (t_array((t_tuple([{:ty_var, a}, {:ty_var, b}]))))))))))}, {:tuple, "unzip", (mk_scheme([a, b], (t_arrow((t_array((t_tuple([{:ty_var, a}, {:ty_var, b}])))), (t_tuple([t_array(({:ty_var, a})), t_array(({:ty_var, b}))]))))))}, {:tuple, "sortBy", (mk_scheme([a], (t_arrow((t_arrow(({:ty_var, a}), (t_arrow(({:ty_var, a}), t_ordering())))), (t_arrow((t_array(({:ty_var, a}))), (t_array(({:ty_var, a})))))))))}, {:tuple, "sort", (mk_scheme([a], (t_arrow((t_array(({:ty_var, a}))), (t_array(({:ty_var, a})))))))}, {:tuple, "nub", (mk_scheme([a], (t_arrow((t_array(({:ty_var, a}))), (t_array(({:ty_var, a})))))))}, {:tuple, "split", (mk_scheme([], (t_arrow(t_string(), (t_arrow(t_string(), (t_array(t_string()))))))))}, {:tuple, "joinWith", (mk_scheme([], (t_arrow(t_string(), (t_arrow((t_array(t_string())), t_string()))))))}, {:tuple, "trim", (mk_scheme([], (t_arrow(t_string(), t_string()))))}, {:tuple, "toLower", (mk_scheme([], (t_arrow(t_string(), t_string()))))}, {:tuple, "toUpper", (mk_scheme([], (t_arrow(t_string(), t_string()))))}, {:tuple, "contains", (mk_scheme([], (t_arrow(t_string(), (t_arrow(t_string(), t_bool()))))))}, {:tuple, "indexOf", (mk_scheme([], (t_arrow(t_string(), (t_arrow(t_string(), (t_maybe(t_int()))))))))}, {:tuple, "replaceAll", (mk_scheme([], (t_arrow(t_string(), (t_arrow(t_string(), (t_arrow(t_string(), t_string()))))))))}, {:tuple, "charAt", (mk_scheme([], (t_arrow(t_int(), (t_arrow(t_string(), (t_maybe(t_char()))))))))}, {:tuple, "toCharArray", (mk_scheme([], (t_arrow(t_string(), (t_array(t_char()))))))}, {:tuple, "fromCharArray", (mk_scheme([], (t_arrow((t_array(t_char())), t_string()))))}, {:tuple, "otherwise", (mk_scheme([], t_bool()))}, {:tuple, "unit", (mk_scheme([], t_unit()))}]), type_aliases: Nova.Map.empty, expanded_type_aliases: Nova.Map.empty}
  end



  def effect_console_exports() do
    
      a = mk_tvar((-1), "a")
      %{types: Nova.Map.empty, constructors: Nova.Map.empty, values: Nova.Map.from_foldable([{:tuple, "log", (mk_scheme([], (t_arrow(t_string(), t_unit()))))}, {:tuple, "logShow", (mk_scheme([a], (t_arrow(({:ty_var, a}), t_unit()))))}, {:tuple, "warn", (mk_scheme([], (t_arrow(t_string(), t_unit()))))}, {:tuple, "error", (mk_scheme([], (t_arrow(t_string(), t_unit()))))}]), type_aliases: Nova.Map.empty, expanded_type_aliases: Nova.Map.empty}
  end



  def default_registry() do
    Nova.Map.from_foldable([{:tuple, "Prelude", prelude_exports()}, {:tuple, "Effect.Console", effect_console_exports()}])
  end

  # @type module_registry :: map()(string())(module_exports())



  def empty_registry() do
    Nova.Map.empty
  end



  def lookup_module(reg, name) do
    Nova.Map.lookup(name, reg)
  end



  def register_module(reg, name, exports) do
    Nova.Map.insert(name, exports, reg)
  end



  def merge_exports_to_env(env, exports) do
    
      ctor_list = Nova.Map.to_unfoldable(exports.constructors)
      val_list = Nova.Map.to_unfoldable(exports.values)
      env1 = Nova.Array.foldl((fn e -> fn ({:tuple, name, scheme}) -> extend_env(e, name, scheme) end end), env, ctor_list)
      env2 = Nova.Array.foldl((fn e -> fn ({:tuple, name, scheme}) -> extend_env(e, name, scheme) end end), env1, val_list)
      env3 = %{env2 | type_aliases: Nova.Map.union(exports.expanded_type_aliases, env2.type_aliases)}
      env3
  end



  def merge_exports_to_env_with_prefix(env, exports, prefix) do
    
      ctor_list = Nova.Map.to_unfoldable(exports.constructors)
      val_list = Nova.Map.to_unfoldable(exports.values)
      alias_list = Nova.Map.to_unfoldable(exports.expanded_type_aliases)
      env1 = Nova.Array.foldl((fn e -> fn ({:tuple, name, scheme}) -> extend_env(e, (Nova.Runtime.append(Nova.Runtime.append(prefix, "."), name)), scheme) end end), env, ctor_list)
      env2 = Nova.Array.foldl((fn e -> fn ({:tuple, name, scheme}) -> extend_env(e, (Nova.Runtime.append(Nova.Runtime.append(prefix, "."), name)), scheme) end end), env1, val_list)
      new_aliases = Nova.Array.foldl((fn m -> fn ({:tuple, name, ty}) -> Nova.Map.insert((Nova.Runtime.append(Nova.Runtime.append(prefix, "."), name)), ty, m) end end), env2.type_aliases, alias_list)
      env3 = %{env2 | type_aliases: new_aliases}
      env3
  end



  def merge_selected_exports(env, exports, items) do
    
      add_item = fn e -> fn name -> 
        e_prime = case Nova.Map.lookup(name, exports.expanded_type_aliases) do
          {:just, ty} -> %{e | type_aliases: Nova.Map.insert(name, ty, e.type_aliases)}
          :nothing -> e
        end
        case Nova.Map.lookup(name, exports.constructors) do
  {:just, scheme} -> extend_env(e_prime, name, scheme)
  :nothing -> case Nova.Map.lookup(name, exports.values) do
      {:just, scheme} -> extend_env(e_prime, name, scheme)
      :nothing -> e_prime
    end
end end end
      Nova.Array.foldl(add_item, env, items)
  end



  def merge_type_export(env, exports, type_name, ctor_names) do
    
      add_ctor = fn e -> fn ctor_name -> case Nova.Map.lookup(ctor_name, exports.constructors) do
        {:just, scheme} -> extend_env(e, ctor_name, scheme)
        :nothing -> e
      end end end
      Nova.Array.foldl(add_ctor, env, ctor_names)
  end



  def show_type(({:ty_var, v})) do
    v.name
  end

  def show_type(({:ty_con, c})) do
    show_ty_con(c)
  end

  def show_type(({:ty_record, r})) do
    show_record(r)
  end

  def show_type(({:ty_app, f, arg})) do
    Nova.Runtime.append(Nova.Runtime.append(Nova.Runtime.append(Nova.Runtime.append("(", show_type(f)), " "), show_type(arg)), ")")
  end



  def show_ty_con(c) do
    case c.name do
      "Fun" -> case c.args do
          [arg, ret] -> Nova.Runtime.append(Nova.Runtime.append(show_type_arg(arg), " -> "), show_type(ret))
          _ -> Nova.Runtime.append(Nova.Runtime.append(c.name, " "), Nova.String.join_with(" ", (Prelude.map((&show_type_arg/1), c.args))))
        end
      "Array" -> case c.args do
          [elem] -> Nova.Runtime.append("Array ", show_type_arg(elem))
          _ -> "Array"
        end
      "List" -> case c.args do
          [elem] -> Nova.Runtime.append("List ", show_type_arg(elem))
          _ -> "List"
        end
      "Maybe" -> case c.args do
          [elem] -> Nova.Runtime.append("Maybe ", show_type_arg(elem))
          _ -> "Maybe"
        end
      "Either" -> case c.args do
          [l, r] -> Nova.Runtime.append(Nova.Runtime.append(Nova.Runtime.append("Either ", show_type_arg(l)), " "), show_type_arg(r))
          _ -> "Either"
        end
      "Map" -> case c.args do
          [k, v] -> Nova.Runtime.append(Nova.Runtime.append(Nova.Runtime.append("Map ", show_type_arg(k)), " "), show_type_arg(v))
          _ -> "Map"
        end
      "Set" -> case c.args do
          [elem] -> Nova.Runtime.append("Set ", show_type_arg(elem))
          _ -> "Set"
        end
      "Tuple" -> case c.args do
          [] -> "Unit"
          [_] -> Nova.Runtime.append("Tuple ", Nova.String.join_with(" ", (Prelude.map((&show_type_arg/1), c.args))))
          _ -> Nova.Runtime.append(Nova.Runtime.append("(", Nova.String.join_with(", ", (Prelude.map((&show_type/1), c.args)))), ")")
        end
      name ->
        cond do
          (Nova.String.take(5, name) == "Tuple") -> Nova.Runtime.append(Nova.Runtime.append("(", Nova.String.join_with(", ", (Prelude.map((&show_type/1), c.args)))), ")")
          true -> c.name
        end
      _ -> c.name
      _ -> Nova.Runtime.append(Nova.Runtime.append(c.name, " "), Nova.String.join_with(" ", (Prelude.map((&show_type_arg/1), c.args))))
    end
  end



  def show_type_arg(ty) do
    case ty do
      {:ty_var, v} -> v.name
      {:ty_con, c} -> case c.name do
          "Fun" -> Nova.Runtime.append(Nova.Runtime.append("(", show_type(ty)), ")")
          _ ->
            cond do
              not((Nova.Array.null(c.args))) -> Nova.Runtime.append(Nova.Runtime.append("(", show_type(ty)), ")")
              true -> c.name
            end
          _ -> c.name
        end
      {:ty_record, r} -> show_record(r)
      {:ty_app, _, _} -> Nova.Runtime.append(Nova.Runtime.append("(", show_type(ty)), ")")
    end
  end



  def show_record(r) do
    
      fields = Nova.Map.to_unfoldable(r.fields)
      field_strs = Prelude.map((fn ({:tuple, name, ty}) -> Nova.Runtime.append(Nova.Runtime.append(name, " :: "), show_type(ty)) end), fields)
      inner = Nova.String.join_with(", ", field_strs)
      case r.row do
  :nothing -> Nova.Runtime.append(Nova.Runtime.append("{ ", inner), " }")
  {:just, rv} -> Nova.Runtime.append(Nova.Runtime.append(Nova.Runtime.append(Nova.Runtime.append("{ ", inner), " | "), rv.name), " }")
end
  end



  def show_scheme(s) do
    
      ty_str = show_type(s.ty)
      if Nova.Array.null(s.vars) do
  ty_str
else
  Nova.Runtime.append(Nova.Runtime.append(Nova.Runtime.append("forall ", Nova.String.join_with(" ", (Prelude.map(& &1.name, s.vars)))), ". "), ty_str)
end
  end
end
