# This file was auto-generated by the Nova compiler.
# Do not edit this file manually.

defmodule Nova.Compiler.CstToAst do
  # import Prelude

  # import Data.List

  # import Data.List

  # import Data.Maybe

  # import Data.Either

  # import Data.Tuple

  # import Nova.Compiler.Cst

  # import Nova.Compiler.Ast

  # @type separated_data_ctor :: %{head: cst._data_ctor()(void()), tail: list()((tuple()(cst._source_token())((cst._data_ctor()(void())))))}

  # @type separated_instance :: %{head: cst._instance()(void()), tail: list()((tuple()(cst._source_token())((cst._instance()(void())))))}

  # @type separated_pattern_guard :: %{head: cst._pattern_guard()(void()), tail: list()((tuple()(cst._source_token())((cst._pattern_guard()(void())))))}

  # @type separated_binder :: %{head: cst._binder()(void()), tail: list()((tuple()(cst._source_token())((cst._binder()(void())))))}

  # @type labeled_ident_type :: %{label: cst._name()(cst._ident()), separator: cst._source_token(), value: cst._type()(void())}

  # @type wrapped_expr :: %{open: cst._source_token(), value: cst._expr()(void()), close: cst._source_token()}

  # @type cst_import_decl :: cst._import_decl()(void())

  # @type cst_separated_import :: %{head: cst._import()(void()), tail: list()((tuple()(cst._source_token())((cst._import()(void())))))}



  def unwrap_ident(({:ident, s})) do
    s
  end



  def unwrap_proper(({:proper, s})) do
    s
  end



  def unwrap_label(({:label, s})) do
    s
  end



  def unwrap_operator(({:operator, s})) do
    s
  end



  def unwrap_module_name(({:module_name, s})) do
    s
  end



  def qualified_proper_name(qn) do
    case qn.module do
      :nothing -> unwrap_proper(qn.name)
      {:just, mod_name} -> Nova.Runtime.append(Nova.Runtime.append(unwrap_module_name(mod_name), "."), unwrap_proper(qn.name))
    end
  end



  def extract_type_var(({:type_var_kinded, wrapped})) do
    unwrap_ident(wrapped.value.label.name)
  end

  def extract_type_var(({:type_var_name, name})) do
    unwrap_ident(name.name)
  end



  def int_value_to_int(({:small_int, n})) do
    n
  end

  def int_value_to_int(({:big_int, _})) do
    0
  end



  def snd(({:tuple, _, b})) do
    b
  end



  def traverse(f, lst) do
    case lst do
      [] -> {:right, []}
      ([head | tail]) ->     Nova.Runtime.bind(f.(head), fn h ->
      Nova.Runtime.bind(traverse(f, tail), fn t ->
        ((&Prelude.pure/1)).([h | t])
      end)
    end)
    end
  end



  def list_map_with_index(f, list) do
    
      go = Nova.Runtime.fix2(fn go -> fn auto_arg0 -> fn auto_arg1 -> case {auto_arg0, auto_arg1} do
        {_, []} -> []
        {i, ([x | xs])} -> [f.(i).(x) | go.(((i + 1))).(xs)]
      end end end end)
      go.(0).(list)
  end



  def is_underscore(({:expr_ident, qn})) do
    (unwrap_ident(qn.name) == "_")
  end

  def is_underscore(_) do
    false
  end



  def operator_precedence(op) do
    case op do
      "*" -> 7
      "/" -> 7
      "mod" -> 7
      "+" -> 6
      "-" -> 6
      "<>" -> 6
      "++" -> 5
      ":" -> 5
      "==" -> 4
      "/=" -> 4
      "!=" -> 4
      "<" -> 4
      ">" -> 4
      "<=" -> 4
      ">=" -> 4
      "&&" -> 3
      "||" -> 2
      "$" -> 1
      "#" -> 1
      ">>>" -> 1
      ">>=" -> 1
      "<<<" -> 1
      ">>" -> 1
      "<-" -> 0
      _ -> 5
    end
  end



  def operator_is_right_assoc(op) do
    case op do
      ":" -> true
      "$" -> true
      ">>>" -> true
      "<<<" -> true
      _ -> false
    end
  end



  def convert_module(cst_mod) do
        module_name = unwrap_module_name(cst_mod.header.name.name)
  Nova.Runtime.bind(traverse((&convert_import_decl/1), cst_mod.header.imports), fn imports ->
    Nova.Runtime.bind(convert_declarations(cst_mod.body.decls), fn decls ->
            import_decls = Prelude.map(fn a -> Nova.Compiler.Ast.decl_import(a) end, imports)
      Prelude.pure(%{name: module_name, declarations: Nova.Runtime.append(import_decls, decls)})
    end)
  end)
  end



  def convert_import_decl(imp) do
        module_name = unwrap_module_name(imp.module.name)
    alias_ = Prelude.map((fn ({:tuple, _, qual_name}) -> unwrap_module_name(qual_name.name) end), imp.qualified)
  Nova.Runtime.bind(case imp.names do
  :nothing -> Prelude.pure([])
  {:just, ({:tuple, _, delim})} ->   Nova.Runtime.bind(convert_import_items(delim.value), fn import_items ->
    Prelude.pure(import_items)
  end)
end, fn items ->
        is_hiding = case imp.names do
          {:just, ({:tuple, ({:just, _}), _})} -> true
          _ -> false
        end
    Prelude.pure(%{module_name: module_name, alias_: alias_, items: items, hiding: is_hiding})
  end)
  end



  def convert_import_items(sep) do
        all_imports = [sep.head | (Prelude.map((fn ({:tuple, _, i}) -> i end), sep.tail))]
  traverse((&convert_import_item/1), all_imports)
  end



  def convert_import_item(imp) do
    case imp do
      {:import_value, name} -> ((&Prelude.pure/1)).(Nova.Compiler.Ast.import_value((unwrap_ident(name.name))))
      {:import_op, name} -> ((&Prelude.pure/1)).(Nova.Compiler.Ast.import_value((unwrap_operator(name.name))))
      {:import_type, name, m_members} -> 
          type_name = unwrap_proper(name.name)
          spec = convert_data_members(m_members)
          ((&Prelude.pure/1)).(Nova.Compiler.Ast.import_type(type_name, spec))
      {:import_type_op, _, name} -> ((&Prelude.pure/1)).(Nova.Compiler.Ast.import_value((unwrap_operator(name.name))))
      {:import_class, _, name} -> ((&Prelude.pure/1)).(Nova.Compiler.Ast.import_type((unwrap_proper(name.name)), Nova.Compiler.Ast.import_none))
      {:import_error, _} -> {:left, "Cannot convert import error"}
    end
  end



  def convert_data_members(:nothing) do
    Nova.Compiler.Ast.import_none
  end

  def convert_data_members(({:just, ({:data_all, _})})) do
    Nova.Compiler.Ast.import_all
  end

  def convert_data_members(({:just, ({:data_enumerated, delim})})) do
    case delim.value do
      :nothing -> Nova.Compiler.Ast.import_none
      {:just, sep} -> 
          names = [(unwrap_proper(sep.head.name)) | (Prelude.map((fn ({:tuple, _, n}) -> unwrap_proper(n.name) end), sep.tail))]
          Nova.Compiler.Ast.import_some(names)
    end
  end



  def convert_declarations(decls) do
    traverse((&convert_declaration/1), decls)
  end



  def convert_declaration(decl) do
    case decl do
      {:decl_data, head, ctors} -> convert_data_type(head, ctors)
      {:decl_type, head, _, ty} -> convert_type_alias(head, ty)
      {:decl_newtype, head, _, ctor_name, wrapped_ty} -> convert_newtype(head, ctor_name, wrapped_ty)
      {:decl_class, head, methods} -> convert_type_class(head, methods)
      {:decl_instance_chain, chain} -> convert_instance(chain)
      {:decl_derive, _, _, inst_head} -> convert_derive_instance(inst_head)
      {:decl_signature, labeled} -> convert_type_signature(labeled)
      {:decl_value, vbf} -> convert_function(vbf)
      {:decl_fixity, fields} -> convert_fixity(fields)
      {:decl_foreign, _, _, foreign_prime} -> convert_foreign(foreign_prime)
      {:decl_error, _} -> {:left, "Cannot convert error declaration"}
    end
  end



  def convert_data_type(head, m_ctors) do
        name = unwrap_proper(head.name.name)
    type_vars = Prelude.map((&extract_type_var/1), head.vars)
  Nova.Runtime.bind(case m_ctors do
  :nothing -> Prelude.pure([])
  {:just, ({:tuple, _, separated})} -> convert_data_ctors(separated)
end, fn ctors ->
    ((&Prelude.pure/1)).(Nova.Compiler.Ast.decl_data_type(%{name: name, type_vars: type_vars, constructors: ctors}))
  end)
  end



  def convert_data_ctors(sep) do
        all_ctors = [sep.head | (Prelude.map((fn ({:tuple, _, c}) -> c end), sep.tail))]
  traverse((&convert_data_ctor/1), all_ctors)
  end



  def convert_data_ctor(ctor) do
        name = unwrap_proper(ctor.name.name)
  Nova.Runtime.bind(traverse((&convert_type_to_field/1), ctor.fields), fn fields ->
    Prelude.pure(%{name: name, fields: fields, is_record: false})
  end)
  end



  def convert_type_to_field(ty) do
      Nova.Runtime.bind(convert_type(ty), fn ty_expr ->
    Prelude.pure(%{label: "", ty: ty_expr})
  end)
  end



  def convert_type_alias(head, ty) do
        name = unwrap_proper(head.name.name)
    type_vars = Prelude.map((&extract_type_var/1), head.vars)
  Nova.Runtime.bind(convert_type(ty), fn ty_expr ->
    ((&Prelude.pure/1)).(Nova.Compiler.Ast.decl_type_alias(%{name: name, type_vars: type_vars, ty: ty_expr}))
  end)
  end



  def convert_newtype(head, ctor_name, wrapped_ty) do
        name = unwrap_proper(head.name.name)
    type_vars = Prelude.map((&extract_type_var/1), head.vars)
    constructor = unwrap_proper(ctor_name.name)
  Nova.Runtime.bind(convert_type(wrapped_ty), fn wrapped_type ->
    ((&Prelude.pure/1)).(Nova.Compiler.Ast.decl_newtype(%{name: name, type_vars: type_vars, constructor: constructor, wrapped_type: wrapped_type}))
  end)
  end



  def convert_type_class(head, m_methods) do
        name = unwrap_proper(head.name.name)
    type_vars = Prelude.map((&extract_type_var/1), head.vars)
  Nova.Runtime.bind(case m_methods do
  :nothing -> Prelude.pure([])
  {:just, ({:tuple, _, labeled})} -> traverse((&convert_method_sig/1), labeled)
end, fn methods ->
    ((&Prelude.pure/1)).(Nova.Compiler.Ast.decl_type_class(%{name: name, type_vars: type_vars, methods: methods, kind: :nothing}))
  end)
  end



  def convert_method_sig(labeled) do
        name = unwrap_ident(labeled.label.name)
  Nova.Runtime.bind(convert_type(labeled.value), fn ty ->
    Prelude.pure(%{name: name, type_vars: [], constraints: [], ty: ty})
  end)
  end



  def convert_instance(chain) do
        inst = chain.head
    class_name = unwrap_proper(inst.head.class_name.name)
  Nova.Runtime.bind(case inst.head.types do
  ([t | _]) -> convert_type(t)
  [] -> {:left, "Instance needs at least one type"}
end, fn ty ->
    Nova.Runtime.bind(case inst.body do
  :nothing -> Prelude.pure([])
  {:just, ({:tuple, _, bindings})} -> traverse((&convert_instance_binding/1), bindings)
end, fn methods ->
      ((&Prelude.pure/1)).(Nova.Compiler.Ast.decl_type_class_instance(%{class_name: class_name, ty: ty, methods: methods, derived: false}))
    end)
  end)
  end



  def convert_instance_binding(binding) do
    case binding do
      {:instance_binding_signature, _} -> {:left, "Type signatures in instances not yet supported"}
      {:instance_binding_name, vbf} -> convert_value_binding(vbf)
    end
  end



  def convert_derive_instance(head) do
        class_name = unwrap_proper(head.class_name.name)
  Nova.Runtime.bind(case head.types do
  ([t | _]) -> convert_type(t)
  [] -> {:left, "Derived instance needs at least one type"}
end, fn ty ->
    ((&Prelude.pure/1)).(Nova.Compiler.Ast.decl_type_class_instance(%{class_name: class_name, ty: ty, methods: [], derived: true}))
  end)
  end



  def convert_function(vbf) do
      Nova.Runtime.bind(convert_value_binding(vbf), fn func ->
    ((&Prelude.pure/1)).(Nova.Compiler.Ast.decl_function(func))
  end)
  end



  def convert_value_binding(vbf) do
        name = unwrap_ident(vbf.name.name)
  Nova.Runtime.bind(traverse((&convert_binder/1), vbf.binders), fn params ->
    case vbf.guarded do
  {:unconditional, _, wh} ->   Nova.Runtime.bind(convert_where_expr(wh), fn body ->
    Prelude.pure(%{name: name, parameters: params, body: body, guards: [], type_signature: :nothing})
  end)
  {:guarded, guarded_exprs} ->   Nova.Runtime.bind(traverse((&convert_guarded_expr/1), guarded_exprs), fn guards ->
    case guards do
  ([g | _]) -> Prelude.pure(%{name: name, parameters: params, body: g.body, guards: guards, type_signature: :nothing})
  [] -> {:left, "Empty guarded expression"}
end
  end)
end
  end)
  end



  def convert_where_expr(wh) do
      Nova.Runtime.bind(convert_expr(wh.expr), fn expr ->
    case wh.bindings do
  :nothing -> Prelude.pure(expr)
  {:just, ({:tuple, _, bindings})} ->   Nova.Runtime.bind(convert_where_bindings(bindings), fn let_binds ->
    ((&Prelude.pure/1)).(Nova.Compiler.Ast.expr_let(let_binds, expr))
  end)
end
  end)
  end



  def convert_let_bindings(bindings) do
    
      collect_let_signatures = Nova.Runtime.fix(fn collect_let_signatures -> fn auto_arg0 -> case auto_arg0 do
        [] -> []
        ([b | bs]) -> case b do
  {:let_binding_signature, labeled} -> 
      name = unwrap_ident(labeled.label.name)
      [({:tuple, name, labeled.value}) | collect_let_signatures.(bs)]
  _ -> collect_let_signatures.(bs)
end
      end end end)
      lookup_let_sig = Nova.Runtime.fix2(fn lookup_let_sig -> fn auto_arg0 -> fn auto_arg1 -> case {auto_arg0, auto_arg1} do
        {_, []} -> :nothing
        {name, ([({:tuple, n, ty}) | rest])} -> if (name == n) do
  {:just, ty}
else
  lookup_let_sig.(name).(rest)
end
      end end end end)
      get_let_value_binding = fn auto_arg0 -> case auto_arg0 do
        ({:let_binding_name, vbf}) -> {:just, ({:left, vbf})}
        ({:let_binding_pattern, binder, sep, wh}) -> {:just, ({:right, %{binder: binder, sep: sep, wh: wh}})}
        _ -> :nothing
      end end
      convert_let_binding_with_sig = fn auto_arg0 -> fn auto_arg1 -> case {auto_arg0, auto_arg1} do
        {sig_map, ({:left, vbf})} -> name = unwrap_ident(vbf.name.name)
Nova.Runtime.bind(traverse((&convert_binder/1), vbf.binders), fn params ->
  Nova.Runtime.bind(case lookup_let_sig.(name).(sig_map) do
  :nothing -> Prelude.pure(:nothing)
  {:just, cst_ty} ->   Nova.Runtime.bind(convert_type(cst_ty), fn ty ->
    Prelude.pure(({:just, ty}))
  end)
end, fn type_ann ->
    Nova.Runtime.bind(case vbf.guarded do
  {:unconditional, _, wh} -> convert_expr(wh.expr)
  {:guarded, guards} -> case guards do
      ([ge | _]) -> convert_expr(ge.where.expr)
      [] -> {:left, "Empty guarded let binding"}
    end
end, fn body_expr ->
            body = if Nova.List.null(params) do
              body_expr
            else
              Nova.Compiler.Ast.expr_lambda(params, body_expr)
            end
      Prelude.pure(%{pattern: Nova.Compiler.Ast.pat_var(name), value: body, type_ann: type_ann})
    end)
  end)
end)
        {_, ({:right, %{binder: binder, wh: wh}})} -> Nova.Runtime.bind(convert_binder(binder), fn pat ->
  Nova.Runtime.bind(convert_expr(wh.expr), fn body ->
    Prelude.pure(%{pattern: pat, value: body, type_ann: :nothing})
  end)
end)
      end end end
      sig_map = collect_let_signatures.(bindings)
value_bindings = Nova.List.map_maybe(get_let_value_binding, bindings)
traverse((convert_let_binding_with_sig.(sig_map)), value_bindings)
  end



  def convert_where_bindings(bindings) do
    
      collect_signatures = Nova.Runtime.fix(fn collect_signatures -> fn auto_arg0 -> case auto_arg0 do
        [] -> []
        ([b | bs]) -> case b do
  {:let_binding_signature, labeled} -> 
      name = unwrap_ident(labeled.label.name)
      [({:tuple, name, labeled.value}) | collect_signatures.(bs)]
  _ -> collect_signatures.(bs)
end
      end end end)
      lookup_sig = Nova.Runtime.fix2(fn lookup_sig -> fn auto_arg0 -> fn auto_arg1 -> case {auto_arg0, auto_arg1} do
        {_, []} -> :nothing
        {name, ([({:tuple, n, ty}) | rest])} -> if (name == n) do
  {:just, ty}
else
  lookup_sig.(name).(rest)
end
      end end end end)
      get_value_binding = fn auto_arg0 -> case auto_arg0 do
        ({:let_binding_name, vbf}) -> {:just, vbf}
        _ -> :nothing
      end end
      convert_let_bind_with_sig = fn sig_map -> fn vbf ->       bind_name = unwrap_ident(vbf.name.name)
   Nova.Runtime.bind(traverse((&convert_binder/1), vbf.binders), fn bind_params ->
     Nova.Runtime.bind(case lookup_sig.(bind_name).(sig_map) do
  :nothing -> Prelude.pure(:nothing)
  {:just, cst_ty} ->   Nova.Runtime.bind(convert_type(cst_ty), fn ty ->
    Prelude.pure(({:just, ty}))
  end)
end, fn type_ann ->
       case vbf.guarded do
  {:unconditional, _, wh} ->   Nova.Runtime.bind(convert_where_expr(wh), fn bind_body ->
        value = case bind_params do
          [] -> bind_body
          _ -> Nova.Compiler.Ast.expr_lambda(bind_params, bind_body)
        end
    Prelude.pure(%{pattern: Nova.Compiler.Ast.pat_var(bind_name), value: value, type_ann: type_ann})
  end)
  {:guarded, _} -> {:left, "Guarded where bindings not yet supported"}
end
     end)
   end) end end
      sig_map = collect_signatures.(bindings)
value_bindings = Nova.List.map_maybe(get_value_binding, bindings)
traverse((convert_let_bind_with_sig.(sig_map)), value_bindings)
  end



  def convert_guarded_expr(ge) do
      Nova.Runtime.bind(convert_pattern_guards(ge.patterns), fn guards ->
    Nova.Runtime.bind(convert_where_expr(ge.where), fn body ->
      Prelude.pure(%{guards: guards, body: body})
    end)
  end)
  end



  def convert_pattern_guards(sep) do
        all_guards = [sep.head | (Prelude.map((fn ({:tuple, _, g}) -> g end), sep.tail))]
  traverse((&convert_pattern_guard/1), all_guards)
  end



  def convert_pattern_guard(pg) do
    case pg.binder do
      :nothing ->     Nova.Runtime.bind(convert_expr(pg.expr), fn expr ->
      ((&Prelude.pure/1)).(Nova.Compiler.Ast.guard_expr(expr))
    end)
      {:just, ({:tuple, binder, _})} ->     Nova.Runtime.bind(convert_binder(binder), fn pat ->
      Nova.Runtime.bind(convert_expr(pg.expr), fn expr ->
        ((&Prelude.pure/1)).(Nova.Compiler.Ast.guard_pat(pat, expr))
      end)
    end)
    end
  end



  def convert_type_signature(labeled) do
        name = unwrap_ident(labeled.label.name)
  Nova.Runtime.bind(extract_constraints(labeled.value), fn {:tuple, constraints, ty} ->
    Nova.Runtime.bind(convert_type(ty), fn ty_expr ->
      ((&Prelude.pure/1)).(Nova.Compiler.Ast.decl_type_sig(%{name: name, type_vars: [], constraints: constraints, ty: ty_expr}))
    end)
  end)
  end



  def extract_constraints(ty) do
    case ty do
      {:type_constrained, constraint, _, rest} ->     Nova.Runtime.bind(convert_constraint_type(constraint), fn c ->
      Nova.Runtime.bind(extract_constraints(rest), fn {:tuple, rest_cs, rest_ty} ->
        ((&Prelude.pure/1)).({:tuple, ([c | rest_cs]), rest_ty})
      end)
    end)
      _ -> ((&Prelude.pure/1)).({:tuple, [], ty})
    end
  end



  def convert_constraint_type(ty) do
    case ty do
      {:type_constructor, qn} ->         class_name = unwrap_proper(qn.name)
    Prelude.pure(%{class_name: class_name, types: []})
      {:type_app, ({:type_constructor, qn}), args} ->         class_name = unwrap_proper(qn.name)
    Nova.Runtime.bind(traverse((&convert_type/1), args), fn types ->
      Prelude.pure(%{class_name: class_name, types: types})
    end)
      _ -> {:left, "Invalid constraint type"}
    end
  end



  def convert_fixity(fields) do
        assoc = case (snd(fields.keyword)) do
      :infix -> Nova.Compiler.Ast.assoc_none
      :infixl -> Nova.Compiler.Ast.assoc_left
      :infixr -> Nova.Compiler.Ast.assoc_right
    end
    prec = snd(fields.prec)
  case fields.operator do
  {:fixity_value, qn, _, op_name} ->     function_name = case qn.name do
      {:left, ident} -> unwrap_ident(ident)
      {:right, proper} -> unwrap_proper(proper)
    end
    operator = unwrap_operator(op_name.name)
  ((&Prelude.pure/1)).(Nova.Compiler.Ast.decl_infix(%{associativity: assoc, precedence: prec, function_name: function_name, operator: operator}))
  {:fixity_type, _, qn, _, op_name} ->     function_name = unwrap_proper(qn.name)
    operator = unwrap_operator(op_name.name)
  ((&Prelude.pure/1)).(Nova.Compiler.Ast.decl_infix(%{associativity: assoc, precedence: prec, function_name: function_name, operator: operator}))
end
  end



  def convert_foreign(foreign_prime) do
    case foreign_prime do
      {:foreign_value, labeled} ->         function_name = unwrap_ident(labeled.label.name)
    Nova.Runtime.bind(convert_type(labeled.value), fn ty ->
      ((&Prelude.pure/1)).(Nova.Compiler.Ast.decl_foreign_import(%{module_name: "", function_name: function_name, alias_: :nothing, type_signature: ty}))
    end)
      {:foreign_data, _, labeled} ->         name = unwrap_proper(labeled.label.name)
    Nova.Runtime.bind(convert_type(labeled.value), fn ty ->
      ((&Prelude.pure/1)).(Nova.Compiler.Ast.decl_type_alias(%{name: name, type_vars: [], ty: ty}))
    end)
    end
  end



  def convert_type(ty) do
    case ty do
      {:type_var, name} -> ((&Prelude.pure/1)).(Nova.Compiler.Ast.ty_expr_var((unwrap_ident(name.name))))
      {:type_constructor, qn} -> ((&Prelude.pure/1)).(Nova.Compiler.Ast.ty_expr_con((qualified_proper_name(qn))))
      {:type_wildcard, _} -> ((&Prelude.pure/1)).(Nova.Compiler.Ast.ty_expr_var("_"))
      {:type_hole, name} -> ((&Prelude.pure/1)).(Nova.Compiler.Ast.ty_expr_var((Nova.Runtime.append("?", unwrap_ident(name.name)))))
      {:type_string, _, s} -> ((&Prelude.pure/1)).(Nova.Compiler.Ast.ty_expr_con((Nova.Runtime.append(Nova.Runtime.append("\"", s), "\""))))
      {:type_int, _, _} -> ((&Prelude.pure/1)).(Nova.Compiler.Ast.ty_expr_con("Int"))
      {:type_row, wrapped} ->     Nova.Runtime.bind(convert_row(wrapped.value), fn row ->
      ((&Prelude.pure/1)).(Nova.Compiler.Ast.ty_expr_record(row.fields, row.tail))
    end)
      {:type_record, wrapped} ->     Nova.Runtime.bind(convert_row(wrapped.value), fn row ->
      ((&Prelude.pure/1)).(Nova.Compiler.Ast.ty_expr_record(row.fields, row.tail))
    end)
      {:type_forall, _, vars, _, body} ->         var_names = Prelude.map((&extract_type_var/1), vars)
    Nova.Runtime.bind(convert_type(body), fn body_ty ->
      ((&Prelude.pure/1)).(Nova.Compiler.Ast.ty_expr_for_all(var_names, body_ty))
    end)
      {:type_kinded, t, _, _} -> convert_type(t)
      {:type_app, head, args} ->     Nova.Runtime.bind(convert_type(head), fn head_ty ->
      Nova.Runtime.bind(traverse((&convert_type/1), args), fn arg_tys ->
        ((&Prelude.pure/1)).(Nova.List.foldl(fn a, b -> Nova.Compiler.Ast.ty_expr_app(a, b) end, head_ty, arg_tys))
      end)
    end)
      {:type_op, head, ops} ->     Nova.Runtime.bind(convert_type(head), fn head_ty ->
      fold_type_ops(head_ty, ops)
    end)
      {:type_arrow, from, _, to} ->     Nova.Runtime.bind(convert_type(from), fn from_ty ->
      Nova.Runtime.bind(convert_type(to), fn to_ty ->
        ((&Prelude.pure/1)).(Nova.Compiler.Ast.ty_expr_arrow(from_ty, to_ty))
      end)
    end)
      {:type_constrained, constraint, _, body} ->     Nova.Runtime.bind(convert_constraint_type(constraint), fn c ->
      Nova.Runtime.bind(convert_type(body), fn body_ty ->
        ((&Prelude.pure/1)).(Nova.Compiler.Ast.ty_expr_constrained(([c | []]), body_ty))
      end)
    end)
      {:type_parens, wrapped} ->     Nova.Runtime.bind(convert_type(wrapped.value), fn inner ->
      ((&Prelude.pure/1)).(Nova.Compiler.Ast.ty_expr_parens(inner))
    end)
      {:type_error, _} -> {:left, "Cannot convert type error"}
    end
  end



  def fold_type_ops(acc, ops) do
    case ops do
      [] -> Prelude.pure(acc)
      ([{:tuple, op, ty} | rest]) ->         op_name = unwrap_operator(op.name)
    Nova.Runtime.bind(convert_type(ty), fn ty_expr ->
            combined = Nova.Compiler.Ast.ty_expr_app((Nova.Compiler.Ast.ty_expr_app((Nova.Compiler.Ast.ty_expr_con(op_name)), acc)), ty_expr)
      fold_type_ops(combined, rest)
    end)
    end
  end



  def convert_row(row) do
      Nova.Runtime.bind(case row.labels do
  :nothing -> Prelude.pure([])
  {:just, sep} -> convert_row_labels(sep)
end, fn fields ->
        tail = case row.tail do
          :nothing -> :nothing
          {:just, ({:tuple, _, ty})} -> case ty do
              {:type_var, name} -> {:just, (unwrap_ident(name.name))}
              _ -> :nothing
            end
        end
    Prelude.pure(%{fields: fields, tail: tail})
  end)
  end

  # @type labeled_label_type :: %{label: cst._name()(cst._label()), separator: cst._source_token(), value: cst._type()(void())}



  def convert_row_labels(sep) do
        all_labels = [sep.head | (Prelude.map((fn ({:tuple, _, l}) -> l end), sep.tail))]
  traverse((&convert_row_label/1), all_labels)
  end



  def convert_row_label(labeled) do
        label = unwrap_label(labeled.label.name)
  Nova.Runtime.bind(convert_type(labeled.value), fn ty ->
    ((&Prelude.pure/1)).({:tuple, label, ty})
  end)
  end



  def convert_expr(expr) do
    case expr do
      {:expr_hole, name} -> ((&Prelude.pure/1)).(Nova.Compiler.Ast.expr_var((unwrap_ident(name.name))))
      {:expr_section, _} -> ((&Prelude.pure/1)).(Nova.Compiler.Ast.expr_section("_"))
      {:expr_ident, qn} -> case qn.module do
          :nothing -> ((&Prelude.pure/1)).(Nova.Compiler.Ast.expr_var((unwrap_ident(qn.name))))
          {:just, mod_name} -> ((&Prelude.pure/1)).(Nova.Compiler.Ast.expr_qualified((unwrap_module_name(mod_name)), (unwrap_ident(qn.name))))
        end
      {:expr_constructor, qn} -> case qn.module do
          :nothing -> ((&Prelude.pure/1)).(Nova.Compiler.Ast.expr_var((unwrap_proper(qn.name))))
          {:just, mod_name} -> ((&Prelude.pure/1)).(Nova.Compiler.Ast.expr_qualified((unwrap_module_name(mod_name)), (unwrap_proper(qn.name))))
        end
      {:expr_boolean, _, b} -> ((&Prelude.pure/1)).(Nova.Compiler.Ast.expr_lit((Nova.Compiler.Ast.lit_bool(b))))
      {:expr_char, _, c} -> ((&Prelude.pure/1)).(Nova.Compiler.Ast.expr_lit((Nova.Compiler.Ast.lit_char(c))))
      {:expr_string, _, s} -> ((&Prelude.pure/1)).(Nova.Compiler.Ast.expr_lit((Nova.Compiler.Ast.lit_string(s))))
      {:expr_int, _, int_val} -> ((&Prelude.pure/1)).(Nova.Compiler.Ast.expr_lit((Nova.Compiler.Ast.lit_int((int_value_to_int(int_val))))))
      {:expr_number, _, n} -> ((&Prelude.pure/1)).(Nova.Compiler.Ast.expr_lit((Nova.Compiler.Ast.lit_number(n))))
      {:expr_array, del} ->     Nova.Runtime.bind(case del.value do
  :nothing -> Prelude.pure([])
  {:just, sep} ->     all_items = [sep.head | (Prelude.map((fn ({:tuple, _, e}) -> e end), sep.tail))]
  traverse((&convert_expr/1), all_items)
end, fn items ->
      ((&Prelude.pure/1)).(Nova.Compiler.Ast.expr_list(items))
    end)
      {:expr_record, del} ->     Nova.Runtime.bind(case del.value do
  :nothing -> Prelude.pure([])
  {:just, sep} ->     all_fields = [sep.head | (Prelude.map((fn ({:tuple, _, f}) -> f end), sep.tail))]
  traverse((&convert_record_field/1), all_fields)
end, fn fields ->
      ((&Prelude.pure/1)).(Nova.Compiler.Ast.expr_record(fields))
    end)
      {:expr_parens, wrapped} ->     Nova.Runtime.bind(convert_expr(wrapped.value), fn inner ->
      ((&Prelude.pure/1)).(Nova.Compiler.Ast.expr_parens(inner))
    end)
      {:expr_typed, e, _, ty} ->     Nova.Runtime.bind(convert_expr(e), fn expr_prime ->
      Nova.Runtime.bind(convert_type(ty), fn ty_expr ->
        ((&Prelude.pure/1)).(Nova.Compiler.Ast.expr_typed(expr_prime, ty_expr))
      end)
    end)
      {:expr_infix, head, ops} ->     Nova.Runtime.bind(convert_expr(head), fn head_e ->
      fold_infix_ops(head_e, ops)
    end)
      {:expr_op, head, ops} ->     Nova.Runtime.bind(convert_expr(head), fn head_e ->
      fold_bin_ops(head_e, ops)
    end)
      {:expr_op_name, qn} -> case qn.module do
          :nothing -> ((&Prelude.pure/1)).(Nova.Compiler.Ast.expr_var((unwrap_operator(qn.name))))
          {:just, mod_name} -> ((&Prelude.pure/1)).(Nova.Compiler.Ast.expr_qualified((unwrap_module_name(mod_name)), (unwrap_operator(qn.name))))
        end
      {:expr_negate, _, e} ->     Nova.Runtime.bind(convert_expr(e), fn inner ->
      ((&Prelude.pure/1)).(Nova.Compiler.Ast.expr_unary_op("-", inner))
    end)
      {:expr_record_accessor, acc} ->     Nova.Runtime.bind(convert_expr(acc.expr), fn base ->
            path = [acc.path.head | (Prelude.map((fn ({:tuple, _, l}) -> l end), acc.path.tail))]
            labels = Prelude.map((fn l -> unwrap_label(l.name) end), path)
      case labels do
  ([first_label | rest]) ->   ((&Prelude.pure/1)).(Nova.List.foldl(fn a, b -> Nova.Compiler.Ast.expr_record_access(a, b) end, (Nova.Compiler.Ast.expr_record_access(base, first_label)), rest))
  [] -> {:left, "Empty record accessor path"}
end
    end)
      {:expr_record_update, base, updates} ->     Nova.Runtime.bind(convert_expr(base), fn base_e ->
            all_updates = [updates.value.head | (Prelude.map((fn ({:tuple, _, u}) -> u end), updates.value.tail))]
      Nova.Runtime.bind(traverse((&convert_record_update/1), all_updates), fn update_fields ->
        ((&Prelude.pure/1)).(Nova.Compiler.Ast.expr_record_update(base_e, update_fields))
      end)
    end)
      {:expr_app, head, args} ->     Nova.Runtime.bind(convert_expr(head), fn head_e ->
      Nova.Runtime.bind(traverse((&convert_expr/1), args), fn arg_es ->
        ((&Prelude.pure/1)).(Nova.List.foldl(fn a, b -> Nova.Compiler.Ast.expr_app(a, b) end, head_e, arg_es))
      end)
    end)
      {:expr_lambda, lam} ->     Nova.Runtime.bind(traverse((&convert_binder/1), lam.binders), fn params ->
      Nova.Runtime.bind(convert_expr(lam.body), fn body ->
        ((&Prelude.pure/1)).(Nova.Compiler.Ast.expr_lambda(params, body))
      end)
    end)
      {:expr_if, ite} ->     Nova.Runtime.bind(convert_expr(ite.cond_), fn cond_e ->
      Nova.Runtime.bind(convert_expr(ite.then_branch), fn then_e ->
        Nova.Runtime.bind(convert_expr(ite.else_branch), fn else_e ->
          ((&Prelude.pure/1)).(Nova.Compiler.Ast.expr_if(cond_e, then_e, else_e))
        end)
      end)
    end)
      {:expr_case, case_of} ->         all_heads = [case_of.head.head | (Prelude.map((fn ({:tuple, _, e}) -> e end), case_of.head.tail))]
    case all_heads do
  ([single | []]) -> if is_underscore(single) do
         Nova.Runtime.bind(traverse((&convert_case_branch/1), case_of.branches), fn clauses ->
          lam_param = Nova.Compiler.Ast.pat_var("lamcase__")
          lam_body = Nova.Compiler.Ast.expr_case((Nova.Compiler.Ast.expr_var("lamcase__")), clauses)
     ((&Prelude.pure/1)).(Nova.Compiler.Ast.expr_lambda(([lam_param | []]), lam_body))
   end)
    else
         Nova.Runtime.bind(convert_expr(single), fn head_e ->
     Nova.Runtime.bind(traverse((&convert_case_branch/1), case_of.branches), fn clauses ->
       ((&Prelude.pure/1)).(Nova.Compiler.Ast.expr_case(head_e, clauses))
     end)
   end)
    end
  multiple ->   Nova.Runtime.bind(traverse((&convert_expr/1), multiple), fn es ->
    Nova.Runtime.bind(traverse((&convert_case_branch/1), case_of.branches), fn clauses ->
      ((&Prelude.pure/1)).(Nova.Compiler.Ast.expr_case((Nova.Compiler.Ast.expr_tuple(es)), clauses))
    end)
  end)
end
      {:expr_let, let_in} ->     Nova.Runtime.bind(convert_let_bindings(let_in.bindings), fn bindings ->
      Nova.Runtime.bind(convert_expr(let_in.body), fn body ->
        ((&Prelude.pure/1)).(Nova.Compiler.Ast.expr_let(bindings, body))
      end)
    end)
      {:expr_do, do_block} ->     Nova.Runtime.bind(traverse((&convert_do_statement/1), do_block.statements), fn stmts ->
      ((&Prelude.pure/1)).(Nova.Compiler.Ast.expr_do(stmts))
    end)
      {:expr_ado, ado_block} ->     Nova.Runtime.bind(traverse((&convert_do_statement/1), ado_block.statements), fn stmts ->
      Nova.Runtime.bind(convert_expr(ado_block.result), fn result ->
        ((&Prelude.pure/1)).(Nova.Compiler.Ast.expr_do((Nova.Runtime.append(stmts, ([Nova.Compiler.Ast.do_expr(result) | []])))))
      end)
    end)
      {:expr_error, _} -> {:left, "Cannot convert expression error"}
    end
  end



  def fold_bin_ops(first_expr, ops) do
      Nova.Runtime.bind(convert_op_list(ops), fn converted ->
    shunting_yard(first_expr, converted)
  end)
  end



  def convert_op_list(ops) do
    case ops do
      [] -> Prelude.pure([])
      ([{:tuple, op, e} | rest]) ->         op_name = unwrap_operator(op.name)
    Nova.Runtime.bind(convert_expr(e), fn expr_e ->
      Nova.Runtime.bind(convert_op_list(rest), fn rest_converted ->
        ((&Prelude.pure/1)).([({:tuple, op_name, expr_e}) | rest_converted])
      end)
    end)
    end
  end



  def shunting_yard(first_expr, ops) do
    
      pop_higher_prec = Nova.Runtime.fix4(fn pop_higher_prec -> fn output -> fn op_stack -> fn prec -> fn is_right_assoc -> case op_stack do
        [] -> Prelude.pure(%{output: output, op_stack: op_stack})
        ([top_op | rest_ops]) -> 
            top_prec = operator_precedence(top_op)
            should_pop = if is_right_assoc do
              (top_prec > prec)
            else
              (top_prec >= prec)
            end
            if should_pop do
   case output do
  ([right | [left | rest_output]]) ->     combined = Nova.Compiler.Ast.expr_bin_op(top_op, left, right)
  pop_higher_prec.(([combined | rest_output])).(rest_ops).(prec).(is_right_assoc)
  _ -> {:left, "Not enough operands for operator"}
end
else
  Prelude.pure(%{output: output, op_stack: op_stack})
end
      end  end end end end end)
      reduce_all = Nova.Runtime.fix2(fn reduce_all -> fn auto_arg0 -> fn auto_arg1 -> case {auto_arg0, auto_arg1} do
        {output, []} -> case output do
  ([result | []]) -> Prelude.pure(result)
  _ -> {:left, "Invalid expression: multiple values remaining"}
end
        {output, ([op | rest_ops])} -> case output do
  ([right | [left | rest_output]]) ->     combined = Nova.Compiler.Ast.expr_bin_op(op, left, right)
  reduce_all.(([combined | rest_output])).(rest_ops)
  _ -> {:left, "Not enough operands for operator"}
end
      end end end end)
      go = Nova.Runtime.fix3(fn go -> fn auto_arg0 -> fn auto_arg1 -> fn auto_arg2 -> case {auto_arg0, auto_arg1, auto_arg2} do
        {output, op_stack, []} -> reduce_all.(output).(op_stack)
        {output, op_stack, ([({:tuple, op, expr}) | rest])} -> new_prec = operator_precedence(op)
is_right_assoc = operator_is_right_assoc(op)
Nova.Runtime.bind(pop_higher_prec.(output).(op_stack).(new_prec).(is_right_assoc), fn result ->
    new_output = result.output
    new_op_stack = result.op_stack
  go.(([expr | new_output])).(([op | new_op_stack])).(rest)
end)
      end end end end end)
      go.(([first_expr | []])).([]).(ops)
  end



  def fold_infix_ops(acc, ops) do
    case ops do
      [] -> Prelude.pure(acc)
      ([{:tuple, wrapped, e} | rest]) ->     Nova.Runtime.bind(convert_expr(wrapped.value), fn fn_ ->
      Nova.Runtime.bind(convert_expr(e), fn expr_e ->
                combined = Nova.Compiler.Ast.expr_app((Nova.Compiler.Ast.expr_app(fn_, acc)), expr_e)
        fold_infix_ops(combined, rest)
      end)
    end)
    end
  end



  def convert_record_field(field) do
    case field do
      {:record_pun, name} ->         label = unwrap_ident(name.name)
    ((&Prelude.pure/1)).({:tuple, label, (Nova.Compiler.Ast.expr_var(label))})
      {:record_field, name, _, value} ->         label = unwrap_label(name.name)
    Nova.Runtime.bind(convert_expr(value), fn expr ->
      ((&Prelude.pure/1)).({:tuple, label, expr})
    end)
    end
  end



  def convert_record_update(update) do
    case update do
      {:record_update_leaf, name, _, expr} ->         label = unwrap_label(name.name)
    Nova.Runtime.bind(convert_expr(expr), fn e ->
      ((&Prelude.pure/1)).({:tuple, label, e})
    end)
      {:record_update_branch, name, updates} ->         label = unwrap_label(name.name)
        all_updates = [updates.value.head | (Prelude.map((fn ({:tuple, _, u}) -> u end), updates.value.tail))]
    Nova.Runtime.bind(traverse((&convert_record_update/1), all_updates), fn fields ->
      ((&Prelude.pure/1)).({:tuple, label, (Nova.Compiler.Ast.expr_record(fields))})
    end)
    end
  end



  def convert_case_branch(({:tuple, patterns, guarded})) do
        all_pats = [patterns.head | (Prelude.map((fn ({:tuple, _, p}) -> p end), patterns.tail))]
  Nova.Runtime.bind(case all_pats do
  ([single | []]) -> convert_binder(single)
  multiple ->   Nova.Runtime.bind(traverse((&convert_binder/1), multiple), fn ps ->
    ((&Prelude.pure/1)).(Nova.Compiler.Ast.pat_record((list_map_with_index((fn i -> fn p -> {:tuple, (Prelude.show(i)), p} end end), ps))))
  end)
end, fn pat ->
    case guarded do
  {:unconditional, _, wh} ->   Nova.Runtime.bind(convert_expr(wh.expr), fn body ->
    Prelude.pure(%{pattern: pat, guard: :nothing, body: body})
  end)
  {:guarded, guards} -> case guards do
      ([ge | _]) ->     Nova.Runtime.bind(convert_pattern_guards(ge.patterns), fn guard_clauses ->
      Nova.Runtime.bind(convert_expr(ge.where.expr), fn body ->
                guard = case guard_clauses do
                  ([{:guard_expr, e} | _]) -> {:just, e}
                  _ -> :nothing
                end
        Prelude.pure(%{pattern: pat, guard: guard, body: body})
      end)
    end)
      [] -> {:left, "Empty guarded expression in case"}
    end
end
  end)
  end



  def convert_let_binding(binding) do
    case binding do
      {:let_binding_signature, labeled} ->         name = unwrap_ident(labeled.label.name)
    Nova.Runtime.bind(convert_type(labeled.value), fn ty ->
      Prelude.pure(%{pattern: Nova.Compiler.Ast.pat_var(name), value: Nova.Compiler.Ast.expr_var(name), type_ann: {:just, ty}})
    end)
      {:let_binding_name, vbf} ->         name = unwrap_ident(vbf.name.name)
    Nova.Runtime.bind(traverse((&convert_binder/1), vbf.binders), fn params ->
      Nova.Runtime.bind(case vbf.guarded do
  {:unconditional, _, wh} -> convert_expr(wh.expr)
  {:guarded, guards} -> case guards do
      ([ge | _]) -> convert_expr(ge.where.expr)
      [] -> {:left, "Empty guarded let binding"}
    end
end, fn body_expr ->
                body = if Nova.List.null(params) do
                  body_expr
                else
                  Nova.Compiler.Ast.expr_lambda(params, body_expr)
                end
        Prelude.pure(%{pattern: Nova.Compiler.Ast.pat_var(name), value: body, type_ann: :nothing})
      end)
    end)
      {:let_binding_pattern, binder, _, wh} ->     Nova.Runtime.bind(convert_binder(binder), fn pat ->
      Nova.Runtime.bind(convert_expr(wh.expr), fn body ->
        Prelude.pure(%{pattern: pat, value: body, type_ann: :nothing})
      end)
    end)
      {:let_binding_error, _} -> {:left, "Cannot convert let binding error"}
    end
  end



  def convert_do_statement(stmt) do
    case stmt do
      {:do_let, _, bindings} ->     Nova.Runtime.bind(convert_let_bindings(bindings), fn binds ->
      ((&Prelude.pure/1)).(Nova.Compiler.Ast.do_let(binds))
    end)
      {:do_discard, e} ->     Nova.Runtime.bind(convert_expr(e), fn expr ->
      ((&Prelude.pure/1)).(Nova.Compiler.Ast.do_expr(expr))
    end)
      {:do_bind, binder, _, e} ->     Nova.Runtime.bind(convert_binder(binder), fn pat ->
      Nova.Runtime.bind(convert_expr(e), fn expr ->
        ((&Prelude.pure/1)).(Nova.Compiler.Ast.do_bind(pat, expr))
      end)
    end)
      {:do_error, _} -> {:left, "Cannot convert do statement error"}
    end
  end



  def convert_binder(binder) do
    case binder do
      {:binder_wildcard, _} -> Prelude.pure(Nova.Compiler.Ast.pat_wildcard())
      {:binder_var, name} -> ((&Prelude.pure/1)).(Nova.Compiler.Ast.pat_var((unwrap_ident(name.name))))
      {:binder_named, name, _, inner} ->     Nova.Runtime.bind(convert_binder(inner), fn inner_pat ->
      ((&Prelude.pure/1)).(Nova.Compiler.Ast.pat_as((unwrap_ident(name.name)), inner_pat))
    end)
      {:binder_constructor, qn, args} ->         name = qualified_proper_name(qn)
    Nova.Runtime.bind(traverse((&convert_binder/1), args), fn arg_pats ->
      ((&Prelude.pure/1)).(Nova.Compiler.Ast.pat_con(name, arg_pats))
    end)
      {:binder_boolean, _, b} -> ((&Prelude.pure/1)).(Nova.Compiler.Ast.pat_lit((Nova.Compiler.Ast.lit_bool(b))))
      {:binder_char, _, c} -> ((&Prelude.pure/1)).(Nova.Compiler.Ast.pat_lit((Nova.Compiler.Ast.lit_char(c))))
      {:binder_string, _, s} -> ((&Prelude.pure/1)).(Nova.Compiler.Ast.pat_lit((Nova.Compiler.Ast.lit_string(s))))
      {:binder_int, neg, _, int_val} ->         n = int_value_to_int(int_val)
        n_prime = case neg do
          :nothing -> n
          {:just, _} -> -n
        end
    ((&Prelude.pure/1)).(Nova.Compiler.Ast.pat_lit((Nova.Compiler.Ast.lit_int(n_prime))))
      {:binder_number, neg, _, num} ->         n_prime = case neg do
          :nothing -> num
          {:just, _} -> -num
        end
    ((&Prelude.pure/1)).(Nova.Compiler.Ast.pat_lit((Nova.Compiler.Ast.lit_number(n_prime))))
      {:binder_array, del} ->     Nova.Runtime.bind(case del.value do
  :nothing -> Prelude.pure([])
  {:just, sep} ->     all_items = [sep.head | (Prelude.map((fn ({:tuple, _, b}) -> b end), sep.tail))]
  traverse((&convert_binder/1), all_items)
end, fn items ->
      ((&Prelude.pure/1)).(Nova.Compiler.Ast.pat_list(items))
    end)
      {:binder_record, del} ->     Nova.Runtime.bind(case del.value do
  :nothing -> Prelude.pure([])
  {:just, sep} ->     all_fields = [sep.head | (Prelude.map((fn ({:tuple, _, f}) -> f end), sep.tail))]
  traverse((&convert_record_binder/1), all_fields)
end, fn fields ->
      ((&Prelude.pure/1)).(Nova.Compiler.Ast.pat_record(fields))
    end)
      {:binder_parens, wrapped} ->     Nova.Runtime.bind(convert_binder(wrapped.value), fn inner ->
      ((&Prelude.pure/1)).(Nova.Compiler.Ast.pat_parens(inner))
    end)
      {:binder_typed, inner, _, _} ->     convert_binder(inner)
      {:binder_op, head, ops} ->     Nova.Runtime.bind(convert_binder(head), fn head_pat ->
      fold_binder_ops(head_pat, ops)
    end)
      {:binder_error, _} -> {:left, "Cannot convert binder error"}
    end
  end



  def fold_binder_ops(acc, ops) do
    case ops do
      [] -> Prelude.pure(acc)
      ([{:tuple, op, b} | rest]) ->         op_name = unwrap_operator(op.name)
    Nova.Runtime.bind(convert_binder(b), fn binder_pat ->
      if (op_name == ":") do
   Nova.Runtime.bind(fold_binder_ops(binder_pat, rest), fn tail_pat ->
   ((&Prelude.pure/1)).(Nova.Compiler.Ast.pat_cons(acc, tail_pat))
 end)
else
    combined = Nova.Compiler.Ast.pat_con(op_name, ([acc | [binder_pat | []]]))
 fold_binder_ops(combined, rest)
end
    end)
    end
  end



  def convert_record_binder(field) do
    case field do
      {:record_pun, name} ->         label = unwrap_ident(name.name)
    ((&Prelude.pure/1)).({:tuple, label, (Nova.Compiler.Ast.pat_var(label))})
      {:record_field, name, _, binder} ->         label = unwrap_label(name.name)
    Nova.Runtime.bind(convert_binder(binder), fn pat ->
      ((&Prelude.pure/1)).({:tuple, label, pat})
    end)
    end
  end
end
