# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

Nova Lang is a compiler written in PureScript that compiles a PureScript-like language to Elixir. The project implements a full compiler pipeline: tokenization → parsing → type checking → code generation.

**Bootstrapping Goal:** We are bootstrapping a self-hosted version of the compiler that will run on the BEAM VM. The PureScript compiler in `src/` compiles itself to Elixir, producing the output in `nova_lang/`. Once complete, the compiled Elixir version will be able to compile its own source code.

## Directory Structure

- `src/Nova/Compiler/` - **Source**: The PureScript compiler source code
- `nova_lang/` - **Compiled Output**: Elixir code generated by compiling the PureScript source
- `scripts/regenerate.js` - Script to recompile PureScript source to Elixir output
- `test/` - PureScript tests for the compiler

## Build Commands

```bash
npx spago build                    # Build PureScript compiler
npx spago test                     # Run PureScript tests
node scripts/regenerate.js         # Recompile source to Elixir (regenerate nova_lang/)
cd nova_lang && mix test           # Run tests on compiled Elixir output
```

## Compiler Architecture

The compiler lives in `src/Nova/Compiler/` with these core modules:

- **Tokenizer.purs** - Lexical analysis producing tokens with position info
- **Parser.purs** - Recursive descent parser producing AST from tokens
- **Ast.purs** - AST type definitions (Module, Declaration, Expr, Pattern, TypeExpr)
- **Types.purs** - Internal type representation for type checking (TVar, TCon, TyRecord, substitutions)
- **TypeChecker.purs** - Hindley-Milner type inference (Algorithm W) with constraints
- **Unify.purs** - Robinson unification algorithm for types
- **CodeGen.purs** - Elixir code generation from typed AST
- **Dependencies.purs** - Dependency extraction and graph management

### Key Types

The AST distinguishes between:
- `Declaration` - Top-level items (functions, data types, newtypes, type classes, imports, infix)
- `Expr` - Expressions (literals, variables, application, lambdas, case, do, let)
- `Pattern` - Pattern matching (variables, constructors, records, lists)
- `TypeExpr` - Surface syntax types (what user writes)
- `Type` - Internal type representation (used by type checker)

### Parser Design

The parser uses explicit token manipulation with helpers like `skipNewlines`, `expectKeyword`, `expectDelimiter`. Parse results are `Either String (Tuple a (Array Token))`.

## Development Workflow

After making changes to the PureScript source:

1. Build: `npx spago build`
2. Test PureScript: `npx spago test`
3. Regenerate Elixir: `node scripts/regenerate.js`
4. Test compiled output: `cd nova_lang && mix test`

**Important:** After every round of changes, verify the compiler can still compile its own source code by running `node scripts/regenerate.js`.

## Current Status

### Working
- Tokenization (complete)
- Parsing (~95% - supports functions, data types, newtypes, type classes, instances, imports, infixl/r, where clauses)
- Type inference (Hindley-Milner with basic type class support)
- Code generation to Elixir (functions, data types, newtypes, case expressions, do-notation)

### In Progress
- Self-compilation: Some type errors remain when compiling full compiler source (`Map.toUnfoldable`, `lookupModule`)
- Type class instance method dispatch in generated code

## Test Structure

- `test/` - PureScript tests (parser tests in `test/parser/`)
- `nova_lang/test/` - Elixir tests for compiled output (namespace service, code generation)
